/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.federation/entry.b6ace3e62ebeee3273eefa6e13da0b93.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.federation/entry.b6ace3e62ebeee3273eefa6e13da0b93.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_webpack_bundler_runtime_0_1_18_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js */ \"./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\");\n/* harmony import */ var _Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_webpack_bundler_runtime_0_1_18_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_webpack_bundler_runtime_0_1_18_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_nextjs_mf_8_3_19_next_14_2_3_react_dom_18_3_1_react_18_3_1_typescript_5_4_5_webpack_5_91_0_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js */ \"./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\");\n\n\n\nvar prevFederation = __webpack_require__.federation;\n__webpack_require__.federation = {}\nfor(var key in (_Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_webpack_bundler_runtime_0_1_18_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())){\n\t__webpack_require__.federation[key] = (_Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_webpack_bundler_runtime_0_1_18_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())[key];\n}\nfor(var key in prevFederation){\n\t__webpack_require__.federation[key] = prevFederation[key];\n}\nif(!__webpack_require__.federation.instance){\n\tconst pluginsToAdd = [\n\t\t_Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_nextjs_mf_8_3_19_next_14_2_3_react_dom_18_3_1_react_18_3_1_typescript_5_4_5_webpack_5_91_0_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? (0,_Users_dhanjyotirabha_Documents_React_step_by_step_Module_Federation_server_server_nextjs_client_node_modules_pnpm_module_federation_nextjs_mf_8_3_19_next_14_2_3_react_dom_18_3_1_react_18_3_1_typescript_5_4_5_webpack_5_91_0_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])() : false,\n\t].filter(Boolean);\n\t__webpack_require__.federation.initOptions.plugins = __webpack_require__.federation.initOptions.plugins ? \n\t__webpack_require__.federation.initOptions.plugins.concat(pluginsToAdd) : pluginsToAdd;\n\t__webpack_require__.federation.instance = __webpack_require__.federation.runtime.init(__webpack_require__.federation.initOptions);\n\tif(__webpack_require__.federation.attachShareScopeMap){\n\t\t__webpack_require__.federation.attachShareScopeMap(__webpack_require__)\n\t}\n\tif(__webpack_require__.federation.installInitialConsumes){\n\t\t__webpack_require__.federation.installInitialConsumes()\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLmZlZGVyYXRpb24vZW50cnkuYjZhY2UzZTYyZWJlZWUzMjczZWVmYTZlMTNkYTBiOTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUF5UTtBQUNzRTs7QUFFL1UscUJBQXFCLG1CQUFtQjtBQUN4QyxtQkFBbUI7QUFDbkIsZUFBZSxxUkFBVTtBQUN6QixDQUFDLG1CQUFtQixtQkFBbUIscVJBQVU7QUFDakQ7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQSxFQUFFLDRWQUFRLEdBQUcsZ1dBQVE7QUFDckI7QUFDQSxDQUFDLG1CQUFtQixrQ0FBa0MsbUJBQW1CO0FBQ3pFLENBQUMsbUJBQW1CO0FBQ3BCLENBQUMsbUJBQW1CLHVCQUF1QixtQkFBbUIseUJBQXlCLG1CQUFtQjtBQUMxRyxJQUFJLG1CQUFtQjtBQUN2QixFQUFFLG1CQUFtQixnQ0FBZ0MsbUJBQW1CO0FBQ3hFO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkIsRUFBRSxtQkFBbUI7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLmZlZGVyYXRpb24vZW50cnkuYjZhY2UzZTYyZWJlZWUzMjczZWVmYTZlMTNkYTBiOTMuanM/YWVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmVkZXJhdGlvbiBmcm9tICcvVXNlcnMvZGhhbmp5b3RpcmFiaGEvRG9jdW1lbnRzL1JlYWN0LXN0ZXAtYnktc3RlcC9Nb2R1bGVfRmVkZXJhdGlvbi9zZXJ2ZXItc2VydmVyLW5leHRqcy9jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0Btb2R1bGUtZmVkZXJhdGlvbit3ZWJwYWNrLWJ1bmRsZXItcnVudGltZUAwLjEuMTgvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi93ZWJwYWNrLWJ1bmRsZXItcnVudGltZS9kaXN0L2luZGV4LmNqcy5qcyc7XG5pbXBvcnQgcGx1Z2luXzAgZnJvbSAnL1VzZXJzL2RoYW5qeW90aXJhYmhhL0RvY3VtZW50cy9SZWFjdC1zdGVwLWJ5LXN0ZXAvTW9kdWxlX0ZlZGVyYXRpb24vc2VydmVyLXNlcnZlci1uZXh0anMvY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AbW9kdWxlLWZlZGVyYXRpb24rbmV4dGpzLW1mQDguMy4xOV9uZXh0QDE0LjIuM19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV90eXBlc2NyaXB0QDUuNC41X3dlYnBhY2tANS45MS4wL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vbmV4dGpzLW1mL2Rpc3Qvc3JjL3BsdWdpbnMvY29udGFpbmVyL3J1bnRpbWVQbHVnaW4uanMnO1xuXG52YXIgcHJldkZlZGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb247XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24gPSB7fVxuZm9yKHZhciBrZXkgaW4gZmVkZXJhdGlvbil7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbltrZXldID0gZmVkZXJhdGlvbltrZXldO1xufVxuZm9yKHZhciBrZXkgaW4gcHJldkZlZGVyYXRpb24pe1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb25ba2V5XSA9IHByZXZGZWRlcmF0aW9uW2tleV07XG59XG5pZighX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlKXtcblx0Y29uc3QgcGx1Z2luc1RvQWRkID0gW1xuXHRcdHBsdWdpbl8wID8gcGx1Z2luXzAoKSA6IGZhbHNlLFxuXHRdLmZpbHRlcihCb29sZWFuKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMucGx1Z2lucyA/IFxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMucGx1Z2lucy5jb25jYXQocGx1Z2luc1RvQWRkKSA6IHBsdWdpbnNUb0FkZDtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLnJ1bnRpbWUuaW5pdChfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMpO1xuXHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uYXR0YWNoU2hhcmVTY29wZU1hcCl7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXAoX193ZWJwYWNrX3JlcXVpcmVfXylcblx0fVxuXHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5zdGFsbEluaXRpYWxDb25zdW1lcyl7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbGxJbml0aWFsQ29uc3VtZXMoKVxuXHR9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.federation/entry.b6ace3e62ebeee3273eefa6e13da0b93.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/index.esm.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/index.esm.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FederationHost: () => (/* binding */ FederationHost),\n/* harmony export */   getRemoteEntry: () => (/* binding */ getRemoteEntry),\n/* harmony export */   getRemoteInfo: () => (/* binding */ getRemoteInfo),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadRemote: () => (/* binding */ loadRemote),\n/* harmony export */   loadScript: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript),\n/* harmony export */   loadScriptNode: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode),\n/* harmony export */   loadShare: () => (/* binding */ loadShare),\n/* harmony export */   loadShareSync: () => (/* binding */ loadShareSync),\n/* harmony export */   preloadRemote: () => (/* binding */ preloadRemote),\n/* harmony export */   registerGlobalPlugins: () => (/* reexport safe */ _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   registerPlugins: () => (/* binding */ registerPlugins),\n/* harmony export */   registerRemotes: () => (/* binding */ registerRemotes)\n/* harmony export */ });\n/* harmony import */ var _share_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share.esm.js */ \"./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/share.esm.js\");\n/* harmony import */ var _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.esm.js\");\n\n\n\n\n\n// Function to match a remote with its name and expose\n// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n// id: alias(app1) + expose(button) = app1/button\n// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\nfunction matchRemoteWithNameAndExpose(remotes, id) {\n    for (const remote of remotes){\n        // match pkgName\n        const isNameMatched = id.startsWith(remote.name);\n        let expose = id.replace(remote.name, '');\n        if (isNameMatched) {\n            if (expose.startsWith('/')) {\n                const pkgNameOrAlias = remote.name;\n                expose = `.${expose}`;\n                return {\n                    pkgNameOrAlias,\n                    expose,\n                    remote\n                };\n            } else if (expose === '') {\n                return {\n                    pkgNameOrAlias: remote.name,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n        // match alias\n        const isAliasMatched = remote.alias && id.startsWith(remote.alias);\n        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');\n        if (remote.alias && isAliasMatched) {\n            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {\n                const pkgNameOrAlias = remote.alias;\n                exposeWithAlias = `.${exposeWithAlias}`;\n                return {\n                    pkgNameOrAlias,\n                    expose: exposeWithAlias,\n                    remote\n                };\n            } else if (exposeWithAlias === '') {\n                return {\n                    pkgNameOrAlias: remote.alias,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n    }\n    return;\n}\n// Function to match a remote with its name or alias\nfunction matchRemote(remotes, nameOrAlias) {\n    for (const remote of remotes){\n        const isNameMatched = nameOrAlias === remote.name;\n        if (isNameMatched) {\n            return remote;\n        }\n        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;\n        if (isAliasMatched) {\n            return remote;\n        }\n    }\n    return;\n}\n\nfunction registerPlugins$1(plugins, hookInstances) {\n    const globalPlugins = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    // Incorporate global plugins\n    if (globalPlugins.length > 0) {\n        globalPlugins.forEach((plugin)=>{\n            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {\n                plugins.push(plugin);\n            }\n        });\n    }\n    if (plugins && plugins.length > 0) {\n        plugins.forEach((plugin)=>{\n            hookInstances.forEach((hookInstance)=>{\n                hookInstance.applyPlugin(plugin);\n            });\n        });\n    }\n    return plugins;\n}\n\nfunction _extends$7() {\n    _extends$7 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$7.apply(this, arguments);\n}\nasync function loadEsmEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                // eslint-disable-next-line no-eval\n                new Function('callbacks', `import(\"${entry}\").then(callbacks[0]).catch(callbacks[1])`)([\n                    resolve,\n                    reject\n                ]);\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nasync function loadEntryScript({ name, globalName, entry, createScriptHook }) {\n    const { entryExports: remoteEntryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (typeof document === 'undefined') {\n        return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode)(entry, {\n            attrs: {\n                name,\n                globalName\n            },\n            createScriptHook\n        }).then(()=>{\n            const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n        Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n        Possible reasons could be:\\n\n        1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n        2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n      `);\n            return entryExports;\n        }).catch((e)=>{\n            throw e;\n        });\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript)(entry, {\n        attrs: {},\n        createScriptHook\n    }).then(()=>{\n        const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n      Possible reasons could be:\\n\n      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n    `);\n        return entryExports;\n    }).catch((e)=>{\n        throw e;\n    });\n}\nfunction getRemoteEntryUniqueKey(remoteInfo) {\n    const { entry, name } = remoteInfo;\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(name, entry);\n}\nasync function getRemoteEntry({ remoteEntryExports, remoteInfo, createScriptHook }) {\n    const { entry, name, type, entryGlobalName } = remoteInfo;\n    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (!_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey]) {\n        if ([\n            'esm',\n            'module'\n        ].includes(type)) {\n            _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEsmEntry({\n                entry,\n                remoteEntryExports\n            });\n        } else {\n            _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEntryScript({\n                name,\n                globalName: entryGlobalName,\n                entry,\n                createScriptHook\n            });\n        }\n    }\n    return _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey];\n}\nfunction getRemoteInfo(remote) {\n    return _extends$7({}, remote, {\n        entry: 'entry' in remote ? remote.entry : '',\n        type: remote.type || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D,\n        entryGlobalName: remote.entryGlobalName || remote.name,\n        shareScope: remote.shareScope || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b\n    });\n}\n\nfunction _extends$6() {\n    _extends$6 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$6.apply(this, arguments);\n}\nlet Module = class Module {\n    async getEntry() {\n        if (this.remoteEntryExports) {\n            return this.remoteEntryExports;\n        }\n        // Get remoteEntry.js\n        const remoteEntryExports = await getRemoteEntry({\n            remoteInfo: this.remoteInfo,\n            remoteEntryExports: this.remoteEntryExports,\n            createScriptHook: (url)=>{\n                const res = this.host.loaderHook.lifecycle.createScript.emit({\n                    url\n                });\n                if (!res) return;\n                if (typeof document === 'undefined') {\n                    //todo: needs real fix\n                    return res;\n                }\n                if (res instanceof HTMLScriptElement) {\n                    return res;\n                }\n                if ('script' in res || 'timeout' in res) {\n                    return res;\n                }\n                return;\n            }\n        });\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteEntryExports, `remoteEntryExports is undefined \\n ${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)(this.remoteInfo)}`);\n        this.remoteEntryExports = remoteEntryExports;\n        return this.remoteEntryExports;\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    async get(id, expose, options) {\n        const { loadFactory = true } = options || {\n            loadFactory: true\n        };\n        // Get remoteEntry.js\n        const remoteEntryExports = await this.getEntry();\n        if (!this.inited) {\n            const localShareScopeMap = this.host.shareScopeMap;\n            const remoteShareScope = this.remoteInfo.shareScope || 'default';\n            if (!localShareScopeMap[remoteShareScope]) {\n                localShareScopeMap[remoteShareScope] = {};\n            }\n            const shareScope = localShareScopeMap[remoteShareScope];\n            const initScope = [];\n            const remoteEntryInitOptions = {\n                version: this.remoteInfo.version || ''\n            };\n            // Help to find host instance\n            Object.defineProperty(remoteEntryInitOptions, 'hostId', {\n                value: this.host.options.id || this.host.name,\n                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed\n                enumerable: false\n            });\n            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({\n                shareScope,\n                // @ts-ignore hostId will be set by Object.defineProperty\n                remoteEntryInitOptions,\n                initScope,\n                remoteInfo: this.remoteInfo,\n                origin: this.host\n            });\n            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);\n            await this.host.hooks.lifecycle.initContainer.emit(_extends$6({}, initContainerOptions, {\n                remoteEntryExports\n            }));\n        }\n        this.lib = remoteEntryExports;\n        this.inited = true;\n        // get exposeGetter\n        const moduleFactory = await remoteEntryExports.get(expose);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(moduleFactory, `${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(this.remoteInfo)} remote don't export ${expose}.`);\n        const wrapModuleFactory = this.wraperFactory(moduleFactory, id);\n        if (!loadFactory) {\n            return wrapModuleFactory;\n        }\n        const exposeContent = await wrapModuleFactory();\n        return exposeContent;\n    }\n    wraperFactory(moduleFactory, id) {\n        function defineModuleId(res, id) {\n            if (res && typeof res === 'object' && !Object.getOwnPropertyDescriptor(res, Symbol.for('mf_module_id'))) {\n                Object.defineProperty(res, Symbol.for('mf_module_id'), {\n                    value: id,\n                    enumerable: false\n                });\n            }\n        }\n        if (moduleFactory instanceof Promise) {\n            return async ()=>{\n                const res = await moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        } else {\n            return ()=>{\n                const res = moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        }\n    }\n    constructor({ remoteInfo, host }){\n        this.inited = false;\n        this.lib = undefined;\n        this.remoteInfo = remoteInfo;\n        this.host = host;\n    }\n};\n\nclass SyncHook {\n    on(fn) {\n        if (typeof fn === 'function') {\n            this.listeners.add(fn);\n        }\n    }\n    once(fn) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        this.on(function wrapper(...args) {\n            self.remove(wrapper);\n            // eslint-disable-next-line prefer-spread\n            return fn.apply(null, args);\n        });\n    }\n    emit(...data) {\n        let result;\n        if (this.listeners.size > 0) {\n            // eslint-disable-next-line prefer-spread\n            this.listeners.forEach((fn)=>{\n                result = fn(...data);\n            });\n        }\n        return result;\n    }\n    remove(fn) {\n        this.listeners.delete(fn);\n    }\n    removeAll() {\n        this.listeners.clear();\n    }\n    constructor(type){\n        this.type = '';\n        this.listeners = new Set();\n        if (type) {\n            this.type = type;\n        }\n    }\n}\n\nclass AsyncHook extends SyncHook {\n    emit(...data) {\n        let result;\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const call = (prev)=>{\n                if (prev === false) {\n                    return false; // Abort process\n                } else if (i < ls.length) {\n                    return Promise.resolve(ls[i++].apply(null, data)).then(call);\n                } else {\n                    return prev;\n                }\n            };\n            result = call();\n        }\n        return Promise.resolve(result);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction checkReturnData(originalData, returnedData) {\n    if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(returnedData)) {\n        return false;\n    }\n    if (originalData !== returnedData) {\n        // eslint-disable-next-line no-restricted-syntax\n        for(const key in originalData){\n            if (!(key in returnedData)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nclass SyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The data for the \"${this.type}\" hook should be an object.`);\n        }\n        for (const fn of this.listeners){\n            try {\n                const tempData = fn(data);\n                if (checkReturnData(data, tempData)) {\n                    data = tempData;\n                } else {\n                    this.onerror(`A plugin returned an unacceptable value for the \"${this.type}\" type.`);\n                    break;\n                }\n            } catch (e) {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n            }\n        }\n        return data;\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass AsyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The response data for the \"${this.type}\" hook must be an object.`);\n        }\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const processError = (e)=>{\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n                return data;\n            };\n            const call = (prevData)=>{\n                if (checkReturnData(data, prevData)) {\n                    data = prevData;\n                    if (i < ls.length) {\n                        try {\n                            return Promise.resolve(ls[i++](data)).then(call, processError);\n                        } catch (e) {\n                            return processError(e);\n                        }\n                    }\n                } else {\n                    this.onerror(`A plugin returned an incorrect value for the \"${this.type}\" type.`);\n                }\n                return data;\n            };\n            return Promise.resolve(call(data));\n        }\n        return Promise.resolve(data);\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass PluginSystem {\n    applyPlugin(plugin) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.h)(plugin), 'Plugin configuration is invalid.');\n        // The plugin's name is mandatory and must be unique\n        const pluginName = plugin.name;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name must be provided by the plugin.');\n        if (!this.registerPlugins[pluginName]) {\n            this.registerPlugins[pluginName] = plugin;\n            Object.keys(this.lifecycle).forEach((key)=>{\n                const pluginLife = plugin[key];\n                if (pluginLife) {\n                    this.lifecycle[key].on(pluginLife);\n                }\n            });\n        }\n    }\n    removePlugin(pluginName) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name is required.');\n        const plugin = this.registerPlugins[pluginName];\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(plugin, `The plugin \"${pluginName}\" is not registered.`);\n        Object.keys(plugin).forEach((key)=>{\n            if (key !== 'name') {\n                this.lifecycle[key].remove(plugin[key]);\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    inherit({ lifecycle, registerPlugins }) {\n        Object.keys(lifecycle).forEach((hookName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.lifecycle[hookName], `The hook \"${hookName}\" has a conflict and cannot be inherited.`);\n            this.lifecycle[hookName] = lifecycle[hookName];\n        });\n        Object.keys(registerPlugins).forEach((pluginName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.registerPlugins[pluginName], `The plugin \"${pluginName}\" has a conflict and cannot be inherited.`);\n            this.applyPlugin(registerPlugins[pluginName]);\n        });\n    }\n    constructor(lifecycle){\n        this.registerPlugins = {};\n        this.lifecycle = lifecycle;\n        this.lifecycleKeys = Object.keys(lifecycle);\n    }\n}\n\nfunction _extends$5() {\n    _extends$5 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$5.apply(this, arguments);\n}\nfunction defaultPreloadArgs(preloadConfig) {\n    return _extends$5({\n        resourceCategory: 'sync',\n        share: true,\n        depsRemote: true,\n        prefetchInterface: false\n    }, preloadConfig);\n}\nfunction formatPreloadArgs(remotes, preloadArgs) {\n    return preloadArgs.map((args)=>{\n        const remoteInfo = matchRemote(remotes, args.nameOrAlias);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)({\n            remoteInfo,\n            remotes\n        })}`);\n        return {\n            remote: remoteInfo,\n            preloadConfig: defaultPreloadArgs(args)\n        };\n    });\n}\nfunction normalizePreloadExposes(exposes) {\n    if (!exposes) {\n        return [];\n    }\n    return exposes.map((expose)=>{\n        if (expose === '.') {\n            return expose;\n        }\n        if (expose.startsWith('./')) {\n            return expose.replace('./', '');\n        }\n        return expose;\n    });\n}\nfunction preloadAssets(remoteInfo, host, assets) {\n    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;\n    if (host.options.inBrowser) {\n        entryAssets.forEach((asset)=>{\n            const { moduleInfo } = asset;\n            const module = host.moduleCache.get(remoteInfo.name);\n            if (module) {\n                getRemoteEntry({\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: module.remoteEntryExports,\n                    createScriptHook: (url)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url\n                        });\n                        if (!res) return;\n                        if (typeof document === 'undefined') {\n                            //todo: needs real fix\n                            return res;\n                        }\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        if ('script' in res || 'timeout' in res) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n            } else {\n                getRemoteEntry({\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: undefined,\n                    createScriptHook: (url)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url\n                        });\n                        if (!res) return;\n                        if (typeof document === 'undefined') {\n                            //todo: needs real fix\n                            return res;\n                        }\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        if ('script' in res || 'timeout' in res) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n            }\n        });\n        const fragment = document.createDocumentFragment();\n        cssAssets.forEach((cssUrl)=>{\n            const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)(cssUrl, ()=>{}, {\n                rel: 'preload',\n                as: 'style'\n            }, (url)=>{\n                const res = host.loaderHook.lifecycle.createLink.emit({\n                    url\n                });\n                if (res instanceof HTMLLinkElement) {\n                    return res;\n                }\n                return;\n            });\n            needAttach && fragment.appendChild(cssEl);\n        });\n        jsAssetsWithoutEntry.forEach((jsUrl)=>{\n            const { link: linkEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)(jsUrl, ()=>{\n            // noop\n            }, {\n                rel: 'preload',\n                as: 'script'\n            }, (url)=>{\n                const res = host.loaderHook.lifecycle.createLink.emit({\n                    url\n                });\n                if (res instanceof HTMLLinkElement) {\n                    return res;\n                }\n                return;\n            });\n            needAttach && document.head.appendChild(linkEl);\n        });\n        document.head.appendChild(fragment);\n    }\n}\n\nfunction _extends$4() {\n    _extends$4 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$4.apply(this, arguments);\n}\nfunction assignRemoteInfo(remoteInfo, remoteSnapshot) {\n    if (!('remoteEntry' in remoteSnapshot) || !remoteSnapshot.remoteEntry) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The attribute remoteEntry of ${name} must not be undefined.`);\n    }\n    const { remoteEntry } = remoteSnapshot;\n    let entryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(remoteSnapshot, remoteEntry);\n    if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)() && !entryUrl.startsWith('http')) {\n        entryUrl = `https:${entryUrl}`;\n    }\n    remoteInfo.type = remoteSnapshot.remoteEntryType;\n    remoteInfo.entryGlobalName = remoteSnapshot.globalName;\n    remoteInfo.entry = entryUrl;\n    remoteInfo.version = remoteSnapshot.version;\n    remoteInfo.buildVersion = remoteSnapshot.buildVersion;\n}\nfunction snapshotPlugin() {\n    return {\n        name: 'snapshot-plugin',\n        async afterResolve (args) {\n            const { remote, pkgNameOrAlias, expose, origin, remoteInfo } = args;\n            if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) || !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo(remote);\n                assignRemoteInfo(remoteInfo, remoteSnapshot);\n                // preloading assets\n                const preloadOptions = {\n                    remote,\n                    preloadConfig: {\n                        nameOrAlias: pkgNameOrAlias,\n                        exposes: [\n                            expose\n                        ],\n                        resourceCategory: 'sync',\n                        share: false,\n                        depsRemote: false\n                    }\n                };\n                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({\n                    origin,\n                    preloadOptions,\n                    remoteInfo,\n                    remote,\n                    remoteSnapshot,\n                    globalSnapshot\n                });\n                if (assets) {\n                    preloadAssets(remoteInfo, origin, assets);\n                }\n                return _extends$4({}, args, {\n                    remoteSnapshot\n                });\n            }\n            return args;\n        }\n    };\n}\n\n// name\n// name:version\nfunction splitId(id) {\n    const splitInfo = id.split(':');\n    if (splitInfo.length === 1) {\n        return {\n            name: splitInfo[0],\n            version: undefined\n        };\n    } else if (splitInfo.length === 2) {\n        return {\n            name: splitInfo[0],\n            version: splitInfo[1]\n        };\n    } else {\n        return {\n            name: splitInfo[1],\n            version: splitInfo[2]\n        };\n    }\n}\n// Traverse all nodes in moduleInfo and traverse the entire snapshot\nfunction traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {\n    const id = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(remoteInfo);\n    const { value: snapshotValue } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)(globalSnapshot, id);\n    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;\n    if (effectiveRemoteSnapshot && !(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(effectiveRemoteSnapshot)) {\n        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);\n        if (effectiveRemoteSnapshot.remotesInfo) {\n            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);\n            for (const key of remoteKeys){\n                if (memo[key]) {\n                    continue;\n                }\n                memo[key] = true;\n                const subRemoteInfo = splitId(key);\n                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];\n                traverseModuleInfo(globalSnapshot, {\n                    name: subRemoteInfo.name,\n                    version: remoteValue.matchedVersion\n                }, traverse, false, memo, undefined);\n            }\n        }\n    }\n}\n// eslint-disable-next-line max-lines-per-function\nfunction generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {\n    const cssAssets = [];\n    const jsAssets = [];\n    const entryAssets = [];\n    const loadedSharedJsAssets = new Set();\n    const loadedSharedCssAssets = new Set();\n    const { options } = origin;\n    const { preloadConfig: rootPreloadConfig } = preloadOptions;\n    const { depsRemote } = rootPreloadConfig;\n    const memo = {};\n    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{\n        let preloadConfig;\n        if (isRoot) {\n            preloadConfig = rootPreloadConfig;\n        } else {\n            if (Array.isArray(depsRemote)) {\n                // eslint-disable-next-line array-callback-return\n                const findPreloadConfig = depsRemote.find((remoteConfig)=>{\n                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!findPreloadConfig) {\n                    return;\n                }\n                preloadConfig = defaultPreloadArgs(findPreloadConfig);\n            } else if (depsRemote === true) {\n                preloadConfig = rootPreloadConfig;\n            } else {\n                return;\n            }\n        }\n        const remoteEntryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, 'remoteEntry' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntry : '');\n        if (remoteEntryUrl) {\n            entryAssets.push({\n                name: remoteInfo.name,\n                moduleInfo: {\n                    name: remoteInfo.name,\n                    entry: remoteEntryUrl,\n                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',\n                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,\n                    shareScope: '',\n                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined\n                },\n                url: remoteEntryUrl\n            });\n        }\n        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];\n        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);\n        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {\n            var _moduleInfoSnapshot_modules;\n            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{\n                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {\n                    assets.push(moduleAssetInfo);\n                }\n                return assets;\n            }, []);\n        }\n        function handleAssets(assets) {\n            const assetsRes = assets.map((asset)=>(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, asset));\n            if (preloadConfig.filter) {\n                return assetsRes.filter(preloadConfig.filter);\n            }\n            return assetsRes;\n        }\n        if (moduleAssetsInfo) {\n            const assetsLength = moduleAssetsInfo.length;\n            for(let index = 0; index < assetsLength; index++){\n                const assetsInfo = moduleAssetsInfo[index];\n                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;\n                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({\n                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,\n                    name: remoteInfo.name,\n                    remoteSnapshot: moduleInfoSnapshot,\n                    preloadConfig,\n                    remote: remoteInfo,\n                    origin\n                });\n                const preloaded = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(exposeFullPath);\n                if (preloaded) {\n                    continue;\n                }\n                if (preloadConfig.resourceCategory === 'all') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                // eslint-disable-next-line no-constant-condition\n                } else if (preloadConfig.resourceCategory = 'sync') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                }\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(exposeFullPath);\n            }\n        }\n    }, true, memo, remoteSnapshot);\n    if (remoteSnapshot.shared) {\n        const collectSharedAssets = (shareInfo, snapshotShared)=>{\n            const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);\n            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.\n            if (registeredShared && typeof registeredShared.lib === 'function') {\n                snapshotShared.assets.js.sync.forEach((asset)=>{\n                    loadedSharedJsAssets.add(asset);\n                });\n                snapshotShared.assets.css.sync.forEach((asset)=>{\n                    loadedSharedCssAssets.add(asset);\n                });\n            }\n        };\n        remoteSnapshot.shared.forEach((shared)=>{\n            var _options_shared;\n            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];\n            if (!shareInfos) {\n                return;\n            }\n            // if no version, preload all shared\n            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;\n            if (!sharedOptions) {\n                return;\n            }\n            const arrayShareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(sharedOptions);\n            arrayShareInfo.forEach((s)=>{\n                collectSharedAssets(s, shared);\n            });\n        });\n    }\n    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset));\n    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset));\n    return {\n        cssAssets: needPreloadCssAssets,\n        jsAssetsWithoutEntry: needPreloadJsAssets,\n        entryAssets\n    };\n}\nconst generatePreloadAssetsPlugin = function() {\n    return {\n        name: 'generate-preload-assets-plugin',\n        async generatePreloadAssets (args) {\n            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                return {\n                    cssAssets: [],\n                    jsAssetsWithoutEntry: [],\n                    entryAssets: [\n                        {\n                            name: remote.name,\n                            url: remote.entry,\n                            moduleInfo: {\n                                name: remoteInfo.name,\n                                entry: remote.entry,\n                                type: 'global',\n                                entryGlobalName: '',\n                                shareScope: ''\n                            }\n                        }\n                    ]\n                };\n            }\n            assignRemoteInfo(remoteInfo, remoteSnapshot);\n            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);\n            return assets;\n        }\n    };\n};\n\nfunction _extends$3() {\n    _extends$3 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$3.apply(this, arguments);\n}\nclass SnapshotHandler {\n    async loadSnapshot(moduleInfo) {\n        const { options } = this.HostInstance;\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        return {\n            remoteSnapshot: globalRemoteSnapshot,\n            globalSnapshot: globalSnapshotRes\n        };\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async loadRemoteSnapshotInfo(moduleInfo) {\n        const { options } = this.HostInstance;\n        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({\n            options,\n            moduleInfo\n        });\n        let hostSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        if (!hostSnapshot) {\n            hostSnapshot = {\n                version: this.HostInstance.options.version || '',\n                remoteEntry: '',\n                remotesInfo: {}\n            };\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)({\n                [this.HostInstance.options.name]: hostSnapshot\n            });\n        }\n        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.\n        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.\n        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)(hostSnapshot.remotesInfo, moduleInfo.name).value) {\n            if ('version' in moduleInfo || 'entry' in moduleInfo) {\n                hostSnapshot.remotesInfo = _extends$3({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {\n                    [moduleInfo.name]: {\n                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry\n                    }\n                });\n            }\n        }\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        // global snapshot includes manifest or module info includes manifest\n        if (globalRemoteSnapshot) {\n            if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(globalRemoteSnapshot)) {\n                const moduleSnapshot = await this.getManifestJson(globalRemoteSnapshot.remoteEntry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(_extends$3({}, moduleInfo, {\n                    // The global remote may be overridden\n                    // Therefore, set the snapshot key to the global address of the actual request\n                    entry: globalRemoteSnapshot.remoteEntry\n                }), moduleSnapshot);\n                return {\n                    remoteSnapshot: moduleSnapshot,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: globalRemoteSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            }\n        } else {\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(moduleInfo)) {\n                // get from manifest.json and merge remote info from remote server\n                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(moduleInfo, moduleSnapshot);\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: moduleSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`\n          Cannot get remoteSnapshot with the name: '${moduleInfo.name}', version: '${moduleInfo.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\\n\n          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\\n\n          2. The remote '${moduleInfo.name}' version '${moduleInfo.version}' is not released.\\n\n          The transformed module info: ${JSON.stringify(globalSnapshotRes)}\n        `);\n            }\n        }\n    }\n    getGlobalRemoteInfo(moduleInfo) {\n        const hostGlobalSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        // get remote detail info from global\n        const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;\n        if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {\n            return {\n                hostGlobalSnapshot,\n                globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(),\n                remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)({\n                    name: moduleInfo.name,\n                    version: globalRemoteInfo.matchedVersion\n                })\n            };\n        }\n        return {\n            hostGlobalSnapshot: undefined,\n            globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(),\n            remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)({\n                name: moduleInfo.name,\n                version: 'version' in moduleInfo ? moduleInfo.version : undefined\n            })\n        };\n    }\n    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {\n        const getManifest = async ()=>{\n            let manifestJson = this.manifestCache.get(manifestUrl);\n            if (manifestJson) {\n                return manifestJson;\n            }\n            try {\n                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});\n                if (!res || !(res instanceof Response)) {\n                    res = await fetch(manifestUrl, {});\n                }\n                manifestJson = await res.json();\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);\n                this.manifestCache.set(manifestUrl, manifestJson);\n                return manifestJson;\n            } catch (err) {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`Failed to get manifestJson for ${moduleInfo.name}. The manifest URL is ${manifestUrl}. Please ensure that the manifestUrl is accessible.\n          \\n Error message:\n          \\n ${err}`);\n            }\n        };\n        const asyncLoadProcess = async ()=>{\n            const manifestJson = await getManifest();\n            const remoteSnapshot = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.generateSnapshotFromManifest)(manifestJson, {\n                version: manifestUrl\n            });\n            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                options: this.HostInstance.options,\n                moduleInfo,\n                manifestJson,\n                remoteSnapshot,\n                manifestUrl,\n                from: 'manifest'\n            });\n            return remoteSnapshotRes;\n        };\n        if (!this.manifestLoading[manifestUrl]) {\n            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);\n        }\n        return this.manifestLoading[manifestUrl];\n    }\n    constructor(HostInstance){\n        this.loadingHostSnapshot = null;\n        this.manifestCache = new Map();\n        this.hooks = new PluginSystem({\n            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),\n            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),\n            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot')\n        });\n        this.manifestLoading = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.G.__FEDERATION__.__MANIFEST_LOADING__;\n        this.HostInstance = HostInstance;\n        this.loaderHook = HostInstance.loaderHook;\n    }\n}\n\nfunction _extends$2() {\n    _extends$2 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$2.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nclass SharedHandler {\n    // register shared in shareScopeMap\n    registerShared(globalOptions, userOptions) {\n        const { shareInfos, shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(globalOptions, userOptions);\n        const sharedKeys = Object.keys(shareInfos);\n        sharedKeys.forEach((sharedKey)=>{\n            const sharedVals = shareInfos[sharedKey];\n            sharedVals.forEach((sharedVal)=>{\n                const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);\n                if (!registeredShared && sharedVal && sharedVal.lib) {\n                    this.setShared({\n                        pkgName: sharedKey,\n                        lib: sharedVal.lib,\n                        get: sharedVal.get,\n                        loaded: true,\n                        shared: sharedVal,\n                        from: userOptions.name\n                    });\n                }\n            });\n        });\n        return {\n            shareInfos,\n            shared\n        };\n    }\n    async loadShare(pkgName, extraOptions) {\n        const { host } = this;\n        // This function performs the following steps:\n        // 1. Checks if the currently loaded share already exists, if not, it throws an error\n        // 2. Searches globally for a matching share, if found, it uses it directly\n        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            await Promise.all(shareInfo.scope.map(async (shareScope)=>{\n                await Promise.all(this.initializeSharing(shareScope, shareInfo.strategy));\n                return;\n            }));\n        }\n        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({\n            pkgName,\n            shareInfo,\n            shared: host.options.shared,\n            origin: host\n        });\n        const { shareInfo: shareInfoRes } = loadShareRes;\n        // Assert that shareInfoRes exists, if not, throw an error\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);\n        // Retrieve from cache\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(shared.useIn, host.options.name);\n        };\n        if (registeredShared && registeredShared.lib) {\n            addUseIn(registeredShared);\n            return registeredShared.lib;\n        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {\n            const factory = await registeredShared.loading;\n            registeredShared.loaded = true;\n            if (!registeredShared.lib) {\n                registeredShared.lib = factory;\n            }\n            addUseIn(registeredShared);\n            return factory;\n        } else if (registeredShared) {\n            const asyncLoadProcess = async ()=>{\n                const factory = await registeredShared.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: registeredShared,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        } else {\n            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {\n                return false;\n            }\n            const asyncLoadProcess = async ()=>{\n                const factory = await shareInfoRes.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: shareInfoRes,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        }\n    }\n    /**\n   * This function initializes the sharing sequence (executed only once per share scope).\n   * It accepts one argument, the name of the share scope.\n   * If the share scope does not exist, it creates one.\n   */ // eslint-disable-next-line @typescript-eslint/member-ordering\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, strategy) {\n        const { host } = this;\n        const shareScope = this.shareScopeMap;\n        const hostName = host.options.name;\n        // Creates a new share scope if necessary\n        if (!shareScope[shareScopeName]) {\n            shareScope[shareScopeName] = {};\n        }\n        // Executes all initialization snippets from all accessible modules\n        const scope = shareScope[shareScopeName];\n        const register = (name, shared)=>{\n            var _activeVersion_shareConfig;\n            const { version, eager } = shared;\n            scope[name] = scope[name] || {};\n            const versions = scope[name];\n            const activeVersion = versions[version];\n            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));\n            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {\n                versions[version] = shared;\n            }\n        };\n        const promises = [];\n        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName]);\n        const initRemoteModule = async (key)=>{\n            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({\n                id: key\n            });\n            if (module.getEntry) {\n                const entry = await module.getEntry();\n                if (!module.inited) {\n                    initFn(entry);\n                    module.inited = true;\n                }\n            }\n        };\n        Object.keys(host.options.shared).forEach((shareName)=>{\n            const sharedArr = host.options.shared[shareName];\n            sharedArr.forEach((shared)=>{\n                if (shared.scope.includes(shareScopeName)) {\n                    register(shareName, shared);\n                }\n            });\n        });\n        if (strategy === 'version-first') {\n            host.options.remotes.forEach((remote)=>{\n                if (remote.shareScope === shareScopeName) {\n                    promises.push(initRemoteModule(remote.name));\n                }\n            });\n        }\n        return promises;\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        const { host } = this;\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            shareInfo.scope.forEach((shareScope)=>{\n                this.initializeSharing(shareScope, shareInfo.strategy);\n            });\n        }\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(shared.useIn, host.options.name);\n        };\n        if (registeredShared) {\n            if (typeof registeredShared.lib === 'function') {\n                addUseIn(registeredShared);\n                if (!registeredShared.loaded) {\n                    registeredShared.loaded = true;\n                    if (registeredShared.from === host.options.name) {\n                        shareInfo.loaded = true;\n                    }\n                }\n                return registeredShared.lib;\n            }\n            if (typeof registeredShared.get === 'function') {\n                const module = registeredShared.get();\n                if (!(module instanceof Promise)) {\n                    addUseIn(registeredShared);\n                    this.setShared({\n                        pkgName,\n                        loaded: true,\n                        from: host.options.name,\n                        lib: module,\n                        shared: registeredShared\n                    });\n                    return module;\n                }\n            }\n        }\n        if (shareInfo.lib) {\n            if (!shareInfo.loaded) {\n                shareInfo.loaded = true;\n            }\n            return shareInfo.lib;\n        }\n        if (shareInfo.get) {\n            const module = shareInfo.get();\n            if (module instanceof Promise) {\n                throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n            }\n            shareInfo.lib = module;\n            this.setShared({\n                pkgName,\n                loaded: true,\n                from: host.options.name,\n                lib: shareInfo.lib,\n                shared: shareInfo\n            });\n            return shareInfo.lib;\n        }\n        throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n    }\n    initShareScopeMap(scopeName, shareScope) {\n        const { host } = this;\n        this.shareScopeMap[scopeName] = shareScope;\n        this.hooks.lifecycle.initContainerShareScopeMap.emit({\n            shareScope,\n            options: host.options,\n            origin: host\n        });\n    }\n    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {\n        const { version, scope = 'default' } = shared, shareInfo = _object_without_properties_loose(shared, [\n            \"version\",\n            \"scope\"\n        ]);\n        const scopes = Array.isArray(scope) ? scope : [\n            scope\n        ];\n        scopes.forEach((sc)=>{\n            if (!this.shareScopeMap[sc]) {\n                this.shareScopeMap[sc] = {};\n            }\n            if (!this.shareScopeMap[sc][pkgName]) {\n                this.shareScopeMap[sc][pkgName] = {};\n            }\n            if (this.shareScopeMap[sc][pkgName][version]) {\n                return;\n            }\n            this.shareScopeMap[sc][pkgName][version] = _extends$2({\n                version,\n                scope: [\n                    'default'\n                ]\n            }, shareInfo, {\n                lib,\n                loaded,\n                loading\n            });\n            if (get) {\n                this.shareScopeMap[sc][pkgName][version].get = get;\n            }\n        });\n    }\n    _setGlobalShareScopeMap(hostOptions) {\n        const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)();\n        const identifier = hostOptions.id || hostOptions.name;\n        if (identifier && !globalShareScopeMap[identifier]) {\n            globalShareScopeMap[identifier] = this.shareScopeMap;\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            afterResolve: new AsyncWaterfallHook('afterResolve'),\n            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),\n            // not used yet\n            loadShare: new AsyncHook(),\n            resolveShare: new SyncWaterfallHook('resolveShare'),\n            // maybe will change, temporarily for internal use only\n            initContainerShareScopeMap: new AsyncWaterfallHook('initContainer')\n        });\n        this.host = host;\n        this.shareScopeMap = {};\n        this._setGlobalShareScopeMap(host.options);\n    }\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nclass RemoteHandler {\n    formatAndRegisterRemote(globalOptions, userOptions) {\n        const userRemotes = userOptions.remotes || [];\n        return userRemotes.reduce((res, remote)=>{\n            this.registerRemote(remote, res, {\n                force: false\n            });\n            return res;\n        }, globalOptions.remotes);\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        const { host } = this;\n        try {\n            const { loadFactory = true } = options || {\n                loadFactory: true\n            };\n            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.\n            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.\n            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)\n            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get\n            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n            // id: alias(app1) + expose(button) = app1/button\n            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\n            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({\n                id\n            });\n            const { pkgNameOrAlias, remote, expose, id: idRes } = remoteMatchInfo;\n            const moduleOrFactory = await module.get(idRes, expose, options);\n            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({\n                id: idRes,\n                pkgNameOrAlias,\n                expose,\n                exposeModule: loadFactory ? moduleOrFactory : undefined,\n                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,\n                remote,\n                options: moduleOptions,\n                moduleInstance: module,\n                origin: host\n            });\n            if (typeof moduleWrapper === 'function') {\n                return moduleWrapper;\n            }\n            return moduleOrFactory;\n        } catch (error) {\n            const { from = 'runtime' } = options || {\n                from: 'runtime'\n            };\n            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                error,\n                from,\n                lifecycle: 'onLoad',\n                origin: host\n            });\n            if (!failOver) {\n                throw error;\n            }\n            return failOver;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        const { host } = this;\n        await this.hooks.lifecycle.beforePreloadRemote.emit({\n            preloadOps: preloadOptions,\n            options: host.options,\n            origin: host\n        });\n        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);\n        await Promise.all(preloadOps.map(async (ops)=>{\n            const { remote } = ops;\n            const remoteInfo = getRemoteInfo(remote);\n            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo(remote);\n            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({\n                origin: host,\n                preloadOptions: ops,\n                remote,\n                remoteInfo,\n                globalSnapshot,\n                remoteSnapshot\n            });\n            if (!assets) {\n                return;\n            }\n            preloadAssets(remoteInfo, host, assets);\n        }));\n    }\n    registerRemotes(remotes, options) {\n        const { host } = this;\n        remotes.forEach((remote)=>{\n            this.registerRemote(remote, host.options.remotes, {\n                force: options == null ? void 0 : options.force\n            });\n        });\n    }\n    async getRemoteModuleAndOptions(options) {\n        const { host } = this;\n        const { id } = options;\n        let loadRemoteArgs;\n        try {\n            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({\n                id,\n                options: host.options,\n                origin: host\n            });\n        } catch (error) {\n            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                options: host.options,\n                origin: host,\n                from: 'runtime',\n                error,\n                lifecycle: 'beforeRequest'\n            });\n            if (!loadRemoteArgs) {\n                throw error;\n            }\n        }\n        const { id: idRes } = loadRemoteArgs;\n        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteSplitInfo, `\n        Unable to locate ${idRes} in ${host.options.name}. Potential reasons for failure include:\\n\n        1. ${idRes} was not included in the 'remotes' parameter of ${host.options.name || 'the host'}.\\n\n        2. ${idRes} could not be found in the 'remotes' of ${host.options.name} with either 'name' or 'alias' attributes.\n        3. ${idRes} is not online, injected, or loaded.\n        4. ${idRes}  cannot be accessed on the expected.\n        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${idRes}.\n      `);\n        const { remote: rawRemote } = remoteSplitInfo;\n        const remoteInfo = getRemoteInfo(rawRemote);\n        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(_extends$1({\n            id: idRes\n        }, remoteSplitInfo, {\n            options: host.options,\n            origin: host,\n            remoteInfo\n        }));\n        const { remote, expose } = matchInfo;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);\n        let module = host.moduleCache.get(remote.name);\n        const moduleOptions = {\n            host: host,\n            remoteInfo\n        };\n        if (!module) {\n            module = new Module(moduleOptions);\n            host.moduleCache.set(remote.name, module);\n        }\n        return {\n            module,\n            moduleOptions,\n            remoteMatchInfo: matchInfo\n        };\n    }\n    registerRemote(remote, targetRemotes, options) {\n        const normalizeRemote = ()=>{\n            if (remote.alias) {\n                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error\n                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported\n                const findEqual = targetRemotes.find((item)=>{\n                    var _item_alias;\n                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));\n                });\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);\n            }\n            // Set the remote entry to a complete path\n            if ('entry' in remote) {\n                if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() && !remote.entry.startsWith('http')) {\n                    remote.entry = new URL(remote.entry, window.location.origin).href;\n                }\n            }\n            if (!remote.shareScope) {\n                remote.shareScope = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b;\n            }\n            if (!remote.type) {\n                remote.type = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D;\n            }\n        };\n        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);\n        if (!registeredRemote) {\n            normalizeRemote();\n            targetRemotes.push(remote);\n        } else {\n            const messages = [\n                `The remote \"${remote.name}\" is already registered.`,\n                (options == null ? void 0 : options.force) ? 'Hope you have known that OVERRIDE it may have some unexpected errors' : 'If you want to merge the remote, you can set \"force: true\".'\n            ];\n            if (options == null ? void 0 : options.force) {\n                // remove registered remote\n                this.removeRemote(registeredRemote);\n                normalizeRemote();\n                targetRemotes.push(remote);\n            }\n            (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.warn)(messages.join(' '));\n        }\n    }\n    removeRemote(remote) {\n        const { host } = this;\n        const { name } = remote;\n        const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);\n        if (remoteIndex !== -1) {\n            host.options.remotes.splice(remoteIndex, 1);\n        }\n        const loadedModule = host.moduleCache.get(remote.name);\n        if (loadedModule) {\n            var _Object_getOwnPropertyDescriptor;\n            const remoteInfo = loadedModule.remoteInfo;\n            const key = remoteInfo.entryGlobalName;\n            if (globalThis[key] && ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(globalThis, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable)) {\n                delete globalThis[key];\n            }\n            const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);\n            if (_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey]) {\n                delete _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey];\n            }\n            // delete un loaded shared and instance\n            let remoteInsId = remoteInfo.buildVersion ? (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;\n            const remoteInsIndex = globalThis.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{\n                if (remoteInfo.buildVersion) {\n                    return ins.options.id === remoteInsId;\n                } else {\n                    return ins.name === remoteInsId;\n                }\n            });\n            if (remoteInsIndex !== -1) {\n                const remoteIns = globalThis.__FEDERATION__.__INSTANCES__[remoteInsIndex];\n                remoteInsId = remoteIns.options.id || remoteInsId;\n                const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)();\n                let isAllSharedNotUsed = true;\n                const needDeleteKeys = [];\n                Object.keys(globalShareScopeMap).forEach((instId)=>{\n                    Object.keys(globalShareScopeMap[instId]).forEach((shareScope)=>{\n                        Object.keys(globalShareScopeMap[instId][shareScope]).forEach((shareName)=>{\n                            Object.keys(globalShareScopeMap[instId][shareScope][shareName]).forEach((shareVersion)=>{\n                                const shared = globalShareScopeMap[instId][shareScope][shareName][shareVersion];\n                                if (shared.from === remoteInfo.name) {\n                                    if (shared.loaded || shared.loading) {\n                                        shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);\n                                        if (shared.useIn.length) {\n                                            isAllSharedNotUsed = false;\n                                        } else {\n                                            needDeleteKeys.push([\n                                                instId,\n                                                shareScope,\n                                                shareName,\n                                                shareVersion\n                                            ]);\n                                        }\n                                    } else {\n                                        needDeleteKeys.push([\n                                            instId,\n                                            shareScope,\n                                            shareName,\n                                            shareVersion\n                                        ]);\n                                    }\n                                }\n                            });\n                        });\n                    });\n                });\n                if (isAllSharedNotUsed) {\n                    remoteIns.shareScopeMap = {};\n                    delete globalShareScopeMap[remoteInsId];\n                }\n                needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{\n                    var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;\n                    (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];\n                });\n                globalThis.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);\n            }\n            host.moduleCache.delete(remote.name);\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            beforeRequest: new AsyncWaterfallHook('beforeRequest'),\n            onLoad: new AsyncHook('onLoad'),\n            handlePreloadModule: new SyncHook('handlePreloadModule'),\n            errorLoadRemote: new AsyncHook('errorLoadRemote'),\n            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),\n            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),\n            // not used yet\n            afterPreloadRemote: new AsyncHook()\n        });\n        this.host = host;\n    }\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nclass FederationHost {\n    initOptions(userOptions) {\n        this.registerPlugins(userOptions.plugins);\n        const options = this.formatOptions(this.options, userOptions);\n        this.options = options;\n        return options;\n    }\n    async loadShare(pkgName, extraOptions) {\n        return this.sharedHandler.loadShare(pkgName, extraOptions);\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        return this.sharedHandler.loadShareSync(pkgName, extraOptions);\n    }\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, strategy) {\n        return this.sharedHandler.initializeSharing(shareScopeName, strategy);\n    }\n    initRawContainer(name, url, container) {\n        const remoteInfo = getRemoteInfo({\n            name,\n            entry: url\n        });\n        const module = new Module({\n            host: this,\n            remoteInfo\n        });\n        module.remoteEntryExports = container;\n        this.moduleCache.set(name, module);\n        return module;\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        return this.remoteHandler.loadRemote(id, options);\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        return this.remoteHandler.preloadRemote(preloadOptions);\n    }\n    initShareScopeMap(scopeName, shareScope) {\n        this.sharedHandler.initShareScopeMap(scopeName, shareScope);\n    }\n    formatOptions(globalOptions, userOptions) {\n        const { shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(globalOptions, userOptions);\n        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({\n            origin: this,\n            userOptions,\n            options: globalOptions,\n            shareInfo: shared\n        });\n        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);\n        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);\n        const plugins = [\n            ...globalOptionsRes.plugins\n        ];\n        if (userOptionsRes.plugins) {\n            userOptionsRes.plugins.forEach((plugin)=>{\n                if (!plugins.includes(plugin)) {\n                    plugins.push(plugin);\n                }\n            });\n        }\n        const optionsRes = _extends({}, globalOptions, userOptions, {\n            plugins,\n            remotes,\n            shared: handledShared\n        });\n        this.hooks.lifecycle.init.emit({\n            origin: this,\n            options: optionsRes\n        });\n        return optionsRes;\n    }\n    registerPlugins(plugins) {\n        const pluginRes = registerPlugins$1(plugins, [\n            this.hooks,\n            this.remoteHandler.hooks,\n            this.sharedHandler.hooks,\n            this.snapshotHandler.hooks,\n            this.loaderHook\n        ]);\n        // Merge plugin\n        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{\n            if (!plugin) return res;\n            if (res && !res.find((item)=>item.name === plugin.name)) {\n                res.push(plugin);\n            }\n            return res;\n        }, pluginRes || []);\n    }\n    registerRemotes(remotes, options) {\n        return this.remoteHandler.registerRemotes(remotes, options);\n    }\n    constructor(userOptions){\n        this.hooks = new PluginSystem({\n            beforeInit: new SyncWaterfallHook('beforeInit'),\n            init: new SyncHook(),\n            // maybe will change, temporarily for internal use only\n            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),\n            // maybe will change, temporarily for internal use only\n            initContainer: new AsyncWaterfallHook('initContainer')\n        });\n        this.version = \"0.1.18\";\n        this.moduleCache = new Map();\n        this.loaderHook = new PluginSystem({\n            // FIXME: may not be suitable , not open to the public yet\n            getModuleInfo: new SyncHook(),\n            createScript: new SyncHook(),\n            createLink: new SyncHook(),\n            // only work for manifest , so not open to the public yet\n            fetch: new AsyncHook('fetch')\n        });\n        // TODO: Validate the details of the options\n        // Initialize options with default values\n        const defaultOptions = {\n            id: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(),\n            name: userOptions.name,\n            plugins: [\n                snapshotPlugin(),\n                generatePreloadAssetsPlugin()\n            ],\n            remotes: [],\n            shared: {},\n            inBrowser: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)()\n        };\n        this.name = userOptions.name;\n        this.options = defaultOptions;\n        this.snapshotHandler = new SnapshotHandler(this);\n        this.sharedHandler = new SharedHandler(this);\n        this.remoteHandler = new RemoteHandler(this);\n        this.shareScopeMap = this.sharedHandler.shareScopeMap;\n        this.registerPlugins([\n            ...defaultOptions.plugins,\n            ...userOptions.plugins || []\n        ]);\n        this.options = this.formatOptions(defaultOptions, userOptions);\n    }\n}\n\nlet FederationInstance = null;\nfunction init(options) {\n    // Retrieve the same instance with the same name\n    const instance = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.name, options.version);\n    if (!instance) {\n        // Retrieve debug constructor\n        const FederationConstructor = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)() || FederationHost;\n        FederationInstance = new FederationConstructor(options);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(FederationInstance);\n        return FederationInstance;\n    } else {\n        // Merge options\n        instance.initOptions(options);\n        if (!FederationInstance) {\n            FederationInstance = instance;\n        }\n        return instance;\n    }\n}\nfunction loadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadRemote1 = FederationInstance.loadRemote;\n    // eslint-disable-next-line prefer-spread\n    return loadRemote1.apply(FederationInstance, args);\n}\nfunction loadShare(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    const loadShare1 = FederationInstance.loadShare;\n    return loadShare1.apply(FederationInstance, args);\n}\nfunction loadShareSync(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadShareSync1 = FederationInstance.loadShareSync;\n    // eslint-disable-next-line prefer-spread\n    return loadShareSync1.apply(FederationInstance, args);\n}\nfunction preloadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.preloadRemote.apply(FederationInstance, args);\n}\nfunction registerRemotes(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerRemotes.apply(FederationInstance, args);\n}\nfunction registerPlugins(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerPlugins.apply(FederationInstance, args);\n}\n// Inject for debug\n(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(FederationHost);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3J1bnRpbWVAMC4xLjE4L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcTBCO0FBQ3p3QjtBQUMrSjtBQUN2Sjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZ0RBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RSxZQUFZLG1DQUFtQyxFQUFFLGdEQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0VBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULG9CQUFvQiwrQkFBK0IsRUFBRSxnREFBcUI7QUFDMUUsWUFBWSxnREFBTTtBQUNsQiw0QkFBNEIsS0FBSyxNQUFNLE1BQU0sYUFBYSxlQUFlO0FBQ3pFO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxXQUFXLGtFQUFVO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTCxnQkFBZ0IsK0JBQStCLEVBQUUsZ0RBQXFCO0FBQ3RFLFFBQVEsZ0RBQU07QUFDZCwwQkFBMEIsS0FBSyxNQUFNLE1BQU0sYUFBYSxlQUFlO0FBQ3ZFO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixXQUFXLCtFQUF1QjtBQUNsQztBQUNBLGdDQUFnQyxrREFBa0Q7QUFDbEYsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRDQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVixZQUFZLDRDQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLDRDQUFhO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw2QkFBNkIsNENBQW1CO0FBQ2hEO0FBQ0EseUNBQXlDLDRDQUFhO0FBQ3RELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsZ0RBQU0sMkRBQTJELGdEQUFZLGtCQUFrQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNLG1CQUFtQixnREFBTyxtQkFBbUIsc0JBQXNCLE9BQU87QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsZ0RBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQVE7QUFDckIsWUFBWSxnREFBSyxzQkFBc0IsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUZBQXFGLFVBQVU7QUFDL0Y7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsZ0RBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQUs7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdEQUFRO0FBQ3JCLFlBQVksZ0RBQUssK0JBQStCLFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtGQUFrRixVQUFVO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBSztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsZ0RBQU0sQ0FBQyxnREFBYTtBQUM1QjtBQUNBO0FBQ0EsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBLFFBQVEsZ0RBQU0sd0JBQXdCLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsWUFBWSxnREFBTSx5Q0FBeUMsU0FBUztBQUNwRTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksZ0RBQU0sbURBQW1ELFdBQVc7QUFDaEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU0sa0NBQWtDLGtCQUFrQiwyQkFBMkIsZUFBZSxnREFBWTtBQUN4SDtBQUNBO0FBQ0EsU0FBUyxFQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEIsRUFBRSxrRUFBVSxlQUFlO0FBQ3pFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQiwyQkFBMkIsRUFBRSxrRUFBVTtBQUMzRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSyxpQ0FBaUMsTUFBTTtBQUNwRDtBQUNBLFlBQVksY0FBYztBQUMxQixtQkFBbUIsc0VBQWM7QUFDakMsU0FBUyxnREFBWTtBQUNyQiw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFxRDtBQUN6RSxpQkFBaUIsZ0RBQXFCLGFBQWEsZ0RBQWlCO0FBQ3BFLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixlQUFlLGdEQUFPO0FBQ3RCLFlBQVksdUJBQXVCLEVBQUUsZ0RBQWtCO0FBQ3ZEO0FBQ0Esb0NBQW9DLDBFQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksbUNBQW1DO0FBQy9DLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0RBQWtELHNFQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBLDBDQUEwQyxnQkFBZ0IsR0FBRyxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDLGdEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVk7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLGdEQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFZO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUE2RTtBQUNqRyxnQkFBZ0IsZ0RBQXFCLFlBQVksZ0RBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixxREFBcUQ7QUFDckUsZ0JBQWdCLDBFQUEwRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQixnREFBaUM7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFpQjtBQUM3QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0RBQWtCO0FBQ2hGO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRSxnQkFBZ0IsMEVBQTBFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQiwwRUFBa0I7QUFDbEMsa0hBQWtIO0FBQ2xIO0FBQ0EsMENBQTBDLGdEQUFpQyxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCLGdEQUFxQjtBQUNyQztBQUNBLGtHQUFrRztBQUNsRztBQUNBLDBDQUEwQyxnREFBaUM7QUFDM0Usd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsZ0RBQUs7QUFDckIsc0RBQXNELGdCQUFnQixlQUFlLG1CQUFtQjtBQUN4RztBQUNBLDJCQUEyQixnQkFBZ0IsYUFBYSxtQkFBbUI7QUFDM0UseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQWlDO0FBQ3BFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnSUFBZ0ksZ0RBQWtCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBaUI7QUFDakQsZ0NBQWdDLGdEQUFpQztBQUNqRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFpQjtBQUM3Qyw0QkFBNEIsZ0RBQWlDO0FBQzdEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQU0sMEVBQTBFLGFBQWE7QUFDN0c7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsZ0RBQUssbUNBQW1DLGdCQUFnQix3QkFBd0IsWUFBWTtBQUM1RztBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvRkFBNEI7QUFDL0Q7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IsNENBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCLEVBQUUsZ0RBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0EsUUFBUSxnREFBTSw4QkFBOEIsU0FBUyxlQUFlLGtCQUFrQiwyQkFBMkIsU0FBUztBQUMxSDtBQUNBLGlDQUFpQyxnREFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUFhO0FBQ3BELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsMEJBQTBCLGdEQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLGdEQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRLFFBQVEsU0FBUyx3QkFBd0Isa0JBQWtCO0FBQzNIO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRLFFBQVEsU0FBUyx3QkFBd0Isa0JBQWtCO0FBQzNIO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEUsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQiw0Q0FBNEM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBLFFBQVEsZ0RBQU07QUFDZCwyQkFBMkIsT0FBTyxLQUFLLGtCQUFrQjtBQUN6RCxhQUFhLE9BQU8saURBQWlELGdDQUFnQztBQUNyRyxhQUFhLE9BQU8seUNBQXlDLG1CQUFtQjtBQUNoRixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLHVIQUF1SCxNQUFNO0FBQzdIO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixpQkFBaUI7QUFDakMsUUFBUSxnREFBTSw0SUFBNEksTUFBTTtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQixnREFBTSwwQkFBMEIsY0FBYyxZQUFZLGFBQWEscUNBQXFDLDZCQUE2QjtBQUN6SjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQWE7QUFDakQ7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQWE7QUFDN0IsdUJBQXVCLDRDQUFhO0FBQ3BDO0FBQ0E7QUFDQSx3REFBd0QsK0VBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnREFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0Q0FBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxFQUFFLGdEQUFrQjtBQUM3QyxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLGdEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUEyQjtBQUNoRDtBQUNBO0FBQ0Esc0NBQXNDLGdEQUE4QjtBQUNwRTtBQUNBLFFBQVEsZ0RBQTJCO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUE4Qjs7QUFFd0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQxLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb2R1bGUtZmVkZXJhdGlvbitydW50aW1lQDAuMS4xOC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC9pbmRleC5lc20uanM/MzhjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnIGFzIGdldEdsb2JhbEhvc3RQbHVnaW5zLCBhIGFzIGdsb2JhbExvYWRpbmcsIEQgYXMgREVGQVVMVF9SRU1PVEVfVFlQRSwgYiBhcyBERUZBVUxUX1NDT1BFLCBjIGFzIGdldFJlbW90ZUVudHJ5RXhwb3J0cywgZCBhcyBhc3NlcnQsIHMgYXMgc2FmZVRvU3RyaW5nLCBlIGFzIGdldEZNSWQsIGkgYXMgaXNPYmplY3QsIGYgYXMgZXJyb3IsIHcgYXMgd2FybiwgaCBhcyBpc1BsYWluT2JqZWN0LCBqIGFzIGlzUmVtb3RlSW5mb1dpdGhFbnRyeSwgayBhcyBpc1B1cmVSZW1vdGVFbnRyeSwgbCBhcyBpc0Jyb3dzZXJFbnYsIG0gYXMgZ2V0SW5mb1dpdGhvdXRUeXBlLCBuIGFzIGdldFByZWxvYWRlZCwgbyBhcyBzZXRQcmVsb2FkZWQsIHAgYXMgZ2V0UmVnaXN0ZXJlZFNoYXJlLCBxIGFzIGFycmF5T3B0aW9ucywgciBhcyBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8sIHQgYXMgYWRkR2xvYmFsU25hcHNob3QsIHUgYXMgc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvLCB2IGFzIGdldEdsb2JhbFNuYXBzaG90LCBHIGFzIEdsb2JhbCwgeCBhcyBmb3JtYXRTaGFyZUNvbmZpZ3MsIHkgYXMgZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucywgeiBhcyBnZXRHbG9iYWxTaGFyZVNjb3BlLCBBIGFzIGFkZFVuaXF1ZUl0ZW0sIEIgYXMgZ2V0QnVpbGRlcklkLCBDIGFzIHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgRSBhcyBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UsIEYgYXMgZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBIIGFzIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSB9IGZyb20gJy4vc2hhcmUuZXNtLmpzJztcbmV4cG9ydCB7IEkgYXMgcmVnaXN0ZXJHbG9iYWxQbHVnaW5zIH0gZnJvbSAnLi9zaGFyZS5lc20uanMnO1xuaW1wb3J0IHsgbG9hZFNjcmlwdE5vZGUsIGxvYWRTY3JpcHQsIGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yLCBjcmVhdGVMaW5rLCBnZXRSZXNvdXJjZVVybCwgaXNNYW5pZmVzdFByb3ZpZGVyLCBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0LCB3YXJuIGFzIHdhcm4kMSwgaXNCcm93c2VyRW52IGFzIGlzQnJvd3NlckVudiQxIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL3Nkayc7XG5leHBvcnQgeyBsb2FkU2NyaXB0LCBsb2FkU2NyaXB0Tm9kZSB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsnO1xuXG4vLyBGdW5jdGlvbiB0byBtYXRjaCBhIHJlbW90ZSB3aXRoIGl0cyBuYW1lIGFuZCBleHBvc2Vcbi8vIGlkOiBwa2dOYW1lKEBmZWRlcmF0aW9uL2FwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBAZmVkZXJhdGlvbi9hcHAxL2J1dHRvblxuLy8gaWQ6IGFsaWFzKGFwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBhcHAxL2J1dHRvblxuLy8gaWQ6IGFsaWFzKGFwcDEvdXRpbHMpICsgZXhwb3NlKGxvYWRhc2gvc29ydCkgPSBhcHAxL3V0aWxzL2xvYWRhc2gvc29ydFxuZnVuY3Rpb24gbWF0Y2hSZW1vdGVXaXRoTmFtZUFuZEV4cG9zZShyZW1vdGVzLCBpZCkge1xuICAgIGZvciAoY29uc3QgcmVtb3RlIG9mIHJlbW90ZXMpe1xuICAgICAgICAvLyBtYXRjaCBwa2dOYW1lXG4gICAgICAgIGNvbnN0IGlzTmFtZU1hdGNoZWQgPSBpZC5zdGFydHNXaXRoKHJlbW90ZS5uYW1lKTtcbiAgICAgICAgbGV0IGV4cG9zZSA9IGlkLnJlcGxhY2UocmVtb3RlLm5hbWUsICcnKTtcbiAgICAgICAgaWYgKGlzTmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtnTmFtZU9yQWxpYXMgPSByZW1vdGUubmFtZTtcbiAgICAgICAgICAgICAgICBleHBvc2UgPSBgLiR7ZXhwb3NlfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3NlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlOiAnLicsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggYWxpYXNcbiAgICAgICAgY29uc3QgaXNBbGlhc01hdGNoZWQgPSByZW1vdGUuYWxpYXMgJiYgaWQuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpO1xuICAgICAgICBsZXQgZXhwb3NlV2l0aEFsaWFzID0gcmVtb3RlLmFsaWFzICYmIGlkLnJlcGxhY2UocmVtb3RlLmFsaWFzLCAnJyk7XG4gICAgICAgIGlmIChyZW1vdGUuYWxpYXMgJiYgaXNBbGlhc01hdGNoZWQpIHtcbiAgICAgICAgICAgIGlmIChleHBvc2VXaXRoQWxpYXMgJiYgZXhwb3NlV2l0aEFsaWFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrZ05hbWVPckFsaWFzID0gcmVtb3RlLmFsaWFzO1xuICAgICAgICAgICAgICAgIGV4cG9zZVdpdGhBbGlhcyA9IGAuJHtleHBvc2VXaXRoQWxpYXN9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlOiBleHBvc2VXaXRoQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9zZVdpdGhBbGlhcyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhczogcmVtb3RlLmFsaWFzLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6ICcuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyBGdW5jdGlvbiB0byBtYXRjaCBhIHJlbW90ZSB3aXRoIGl0cyBuYW1lIG9yIGFsaWFzXG5mdW5jdGlvbiBtYXRjaFJlbW90ZShyZW1vdGVzLCBuYW1lT3JBbGlhcykge1xuICAgIGZvciAoY29uc3QgcmVtb3RlIG9mIHJlbW90ZXMpe1xuICAgICAgICBjb25zdCBpc05hbWVNYXRjaGVkID0gbmFtZU9yQWxpYXMgPT09IHJlbW90ZS5uYW1lO1xuICAgICAgICBpZiAoaXNOYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0FsaWFzTWF0Y2hlZCA9IHJlbW90ZS5hbGlhcyAmJiBuYW1lT3JBbGlhcyA9PT0gcmVtb3RlLmFsaWFzO1xuICAgICAgICBpZiAoaXNBbGlhc01hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbnMkMShwbHVnaW5zLCBob29rSW5zdGFuY2VzKSB7XG4gICAgY29uc3QgZ2xvYmFsUGx1Z2lucyA9IGdldEdsb2JhbEhvc3RQbHVnaW5zKCk7XG4gICAgLy8gSW5jb3Jwb3JhdGUgZ2xvYmFsIHBsdWdpbnNcbiAgICBpZiAoZ2xvYmFsUGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdsb2JhbFBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKT0+e1xuICAgICAgICAgICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuZmluZCgoaXRlbSk9Pml0ZW0ubmFtZSAhPT0gcGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGx1Z2lucyAmJiBwbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgICAgICBob29rSW5zdGFuY2VzLmZvckVhY2goKGhvb2tJbnN0YW5jZSk9PntcbiAgICAgICAgICAgICAgICBob29rSW5zdGFuY2UuYXBwbHlQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDcoKSB7XG4gICAgX2V4dGVuZHMkNyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQ3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRXNtRW50cnkoeyBlbnRyeSwgcmVtb3RlRW50cnlFeHBvcnRzIH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV2YWxcbiAgICAgICAgICAgICAgICBuZXcgRnVuY3Rpb24oJ2NhbGxiYWNrcycsIGBpbXBvcnQoXCIke2VudHJ5fVwiKS50aGVuKGNhbGxiYWNrc1swXSkuY2F0Y2goY2FsbGJhY2tzWzFdKWApKFtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVtb3RlRW50cnlFeHBvcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRW50cnlTY3JpcHQoeyBuYW1lLCBnbG9iYWxOYW1lLCBlbnRyeSwgY3JlYXRlU2NyaXB0SG9vayB9KSB7XG4gICAgY29uc3QgeyBlbnRyeUV4cG9ydHM6IHJlbW90ZUVudHJ5RXhwb3J0cyB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRTY3JpcHROb2RlKGVudHJ5LCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZ2xvYmFsTmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgfSkudGhlbigoKT0+e1xuICAgICAgICAgICAgY29uc3QgeyByZW1vdGVFbnRyeUtleSwgZW50cnlFeHBvcnRzIH0gPSBnZXRSZW1vdGVFbnRyeUV4cG9ydHMobmFtZSwgZ2xvYmFsTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQoZW50cnlFeHBvcnRzLCBgXG4gICAgICAgIFVuYWJsZSB0byB1c2UgdGhlICR7bmFtZX0ncyAnJHtlbnRyeX0nIFVSTCB3aXRoICR7cmVtb3RlRW50cnlLZXl9J3MgZ2xvYmFsTmFtZSB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cy5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBjb3VsZCBiZTpcXG5cbiAgICAgICAgMS4gJyR7ZW50cnl9JyBpcyBub3QgdGhlIGNvcnJlY3QgVVJMLCBvciB0aGUgcmVtb3RlRW50cnkgcmVzb3VyY2Ugb3IgbmFtZSBpcyBpbmNvcnJlY3QuXFxuXG4gICAgICAgIDIuICR7cmVtb3RlRW50cnlLZXl9IGNhbm5vdCBiZSB1c2VkIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzIGluIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAgYCk7XG4gICAgICAgICAgICByZXR1cm4gZW50cnlFeHBvcnRzO1xuICAgICAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZFNjcmlwdChlbnRyeSwge1xuICAgICAgICBhdHRyczoge30sXG4gICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICB9KS50aGVuKCgpPT57XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlRW50cnlLZXksIGVudHJ5RXhwb3J0cyB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgICAgICBhc3NlcnQoZW50cnlFeHBvcnRzLCBgXG4gICAgICBVbmFibGUgdG8gdXNlIHRoZSAke25hbWV9J3MgJyR7ZW50cnl9JyBVUkwgd2l0aCAke3JlbW90ZUVudHJ5S2V5fSdzIGdsb2JhbE5hbWUgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMuXG4gICAgICBQb3NzaWJsZSByZWFzb25zIGNvdWxkIGJlOlxcblxuICAgICAgMS4gJyR7ZW50cnl9JyBpcyBub3QgdGhlIGNvcnJlY3QgVVJMLCBvciB0aGUgcmVtb3RlRW50cnkgcmVzb3VyY2Ugb3IgbmFtZSBpcyBpbmNvcnJlY3QuXFxuXG4gICAgICAyLiAke3JlbW90ZUVudHJ5S2V5fSBjYW5ub3QgYmUgdXNlZCB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cyBpbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICBgKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5RXhwb3J0cztcbiAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBuYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIHJldHVybiBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcihuYW1lLCBlbnRyeSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVFbnRyeSh7IHJlbW90ZUVudHJ5RXhwb3J0cywgcmVtb3RlSW5mbywgY3JlYXRlU2NyaXB0SG9vayB9KSB7XG4gICAgY29uc3QgeyBlbnRyeSwgbmFtZSwgdHlwZSwgZW50cnlHbG9iYWxOYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIGNvbnN0IHVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgaWYgKCFnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0pIHtcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICdlc20nLFxuICAgICAgICAgICAgJ21vZHVsZSdcbiAgICAgICAgXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgICAgZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVzbUVudHJ5KHtcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVudHJ5U2NyaXB0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWU6IGVudHJ5R2xvYmFsTmFtZSxcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlSW5mbyhyZW1vdGUpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMkNyh7fSwgcmVtb3RlLCB7XG4gICAgICAgIGVudHJ5OiAnZW50cnknIGluIHJlbW90ZSA/IHJlbW90ZS5lbnRyeSA6ICcnLFxuICAgICAgICB0eXBlOiByZW1vdGUudHlwZSB8fCBERUZBVUxUX1JFTU9URV9UWVBFLFxuICAgICAgICBlbnRyeUdsb2JhbE5hbWU6IHJlbW90ZS5lbnRyeUdsb2JhbE5hbWUgfHwgcmVtb3RlLm5hbWUsXG4gICAgICAgIHNoYXJlU2NvcGU6IHJlbW90ZS5zaGFyZVNjb3BlIHx8IERFRkFVTFRfU0NPUEVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkNigpIHtcbiAgICBfZXh0ZW5kcyQ2ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmxldCBNb2R1bGUgPSBjbGFzcyBNb2R1bGUge1xuICAgIGFzeW5jIGdldEVudHJ5KCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgcmVtb3RlRW50cnkuanNcbiAgICAgICAgY29uc3QgcmVtb3RlRW50cnlFeHBvcnRzID0gYXdhaXQgZ2V0UmVtb3RlRW50cnkoe1xuICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cyxcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5ob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvL3RvZG86IG5lZWRzIHJlYWwgZml4XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gcmVzIHx8ICd0aW1lb3V0JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZUVudHJ5RXhwb3J0cywgYHJlbW90ZUVudHJ5RXhwb3J0cyBpcyB1bmRlZmluZWQgXFxuICR7c2FmZVRvU3RyaW5nKHRoaXMucmVtb3RlSW5mbyl9YCk7XG4gICAgICAgIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzID0gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgYXN5bmMgZ2V0KGlkLCBleHBvc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeSA9IHRydWUgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2V0IHJlbW90ZUVudHJ5LmpzXG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5RXhwb3J0cyA9IGF3YWl0IHRoaXMuZ2V0RW50cnkoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTaGFyZVNjb3BlTWFwID0gdGhpcy5ob3N0LnNoYXJlU2NvcGVNYXA7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVTaGFyZVNjb3BlID0gdGhpcy5yZW1vdGVJbmZvLnNoYXJlU2NvcGUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgaWYgKCFsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV07XG4gICAgICAgICAgICBjb25zdCBpbml0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5yZW1vdGVJbmZvLnZlcnNpb24gfHwgJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBIZWxwIHRvIGZpbmQgaG9zdCBpbnN0YW5jZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMsICdob3N0SWQnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaG9zdC5vcHRpb25zLmlkIHx8IHRoaXMuaG9zdC5uYW1lLFxuICAgICAgICAgICAgICAgIC8vIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgd2lsbCBiZSB0cmF2ZXJzZWQgYW5kIGFzc2lnbmVkIGR1cmluZyBjb250YWluZXIgaW5pdCwgLHNvIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHRyYXZlcnNlZFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRDb250YWluZXJPcHRpb25zID0gYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVJbml0Q29udGFpbmVyLmVtaXQoe1xuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBob3N0SWQgd2lsbCBiZSBzZXQgYnkgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnlJbml0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbml0U2NvcGUsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5ob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZUVudHJ5RXhwb3J0cy5pbml0KGluaXRDb250YWluZXJPcHRpb25zLnNoYXJlU2NvcGUsIGluaXRDb250YWluZXJPcHRpb25zLmluaXRTY29wZSwgaW5pdENvbnRhaW5lck9wdGlvbnMucmVtb3RlRW50cnlJbml0T3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhvc3QuaG9va3MubGlmZWN5Y2xlLmluaXRDb250YWluZXIuZW1pdChfZXh0ZW5kcyQ2KHt9LCBpbml0Q29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGliID0gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIC8vIGdldCBleHBvc2VHZXR0ZXJcbiAgICAgICAgY29uc3QgbW9kdWxlRmFjdG9yeSA9IGF3YWl0IHJlbW90ZUVudHJ5RXhwb3J0cy5nZXQoZXhwb3NlKTtcbiAgICAgICAgYXNzZXJ0KG1vZHVsZUZhY3RvcnksIGAke2dldEZNSWQodGhpcy5yZW1vdGVJbmZvKX0gcmVtb3RlIGRvbid0IGV4cG9ydCAke2V4cG9zZX0uYCk7XG4gICAgICAgIGNvbnN0IHdyYXBNb2R1bGVGYWN0b3J5ID0gdGhpcy53cmFwZXJGYWN0b3J5KG1vZHVsZUZhY3RvcnksIGlkKTtcbiAgICAgICAgaWYgKCFsb2FkRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBNb2R1bGVGYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9zZUNvbnRlbnQgPSBhd2FpdCB3cmFwTW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gZXhwb3NlQ29udGVudDtcbiAgICB9XG4gICAgd3JhcGVyRmFjdG9yeShtb2R1bGVGYWN0b3J5LCBpZCkge1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVNb2R1bGVJZChyZXMsIGlkKSB7XG4gICAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlcywgU3ltYm9sLmZvcignbWZfbW9kdWxlX2lkJykpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgU3ltYm9sLmZvcignbWZfbW9kdWxlX2lkJyksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVGYWN0b3J5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGJyaWRnZSBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgICBkZWZpbmVNb2R1bGVJZChyZXMsIGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1vZHVsZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIGZvciBicmlkZ2UgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgZGVmaW5lTW9kdWxlSWQocmVzLCBpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyByZW1vdGVJbmZvLCBob3N0IH0pe1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZW1vdGVJbmZvID0gcmVtb3RlSW5mbztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG59O1xuXG5jbGFzcyBTeW5jSG9vayB7XG4gICAgb24oZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuYWRkKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbmNlKGZuKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vbihmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKHdyYXBwZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoLi4uZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChmbik9PntcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbiguLi5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZShmbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoZm4pO1xuICAgIH1cbiAgICByZW1vdmVBbGwoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUpe1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBc3luY0hvb2sgZXh0ZW5kcyBTeW5jSG9vayB7XG4gICAgZW1pdCguLi5kYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGxzID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycyk7XG4gICAgICAgIGlmIChscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gKHByZXYpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gQWJvcnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10uYXBwbHkobnVsbCwgZGF0YSkpLnRoZW4oY2FsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gY2hlY2tSZXR1cm5EYXRhKG9yaWdpbmFsRGF0YSwgcmV0dXJuZWREYXRhKSB7XG4gICAgaWYgKCFpc09iamVjdChyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRGF0YSAhPT0gcmV0dXJuZWREYXRhKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IoY29uc3Qga2V5IGluIG9yaWdpbmFsRGF0YSl7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gcmV0dXJuZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgc2hvdWxkIGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMubGlzdGVuZXJzKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcERhdGEgPSBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZXR1cm5EYXRhKGRhdGEsIHRlbXBEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGVtcERhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiB1bmFjY2VwdGFibGUgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgQXN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIHJlc3BvbnNlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHMgPSBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgaWYgKGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAocHJldkRhdGEpPT57XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUmV0dXJuRGF0YShkYXRhLCBwcmV2RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHByZXZEYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10oZGF0YSkpLnRoZW4oY2FsbCwgcHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiBpbmNvcnJlY3QgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FsbChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgICBhcHBseVBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgYXNzZXJ0KGlzUGxhaW5PYmplY3QocGx1Z2luKSwgJ1BsdWdpbiBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuJyk7XG4gICAgICAgIC8vIFRoZSBwbHVnaW4ncyBuYW1lIGlzIG1hbmRhdG9yeSBhbmQgbXVzdCBiZSB1bmlxdWVcbiAgICAgICAgY29uc3QgcGx1Z2luTmFtZSA9IHBsdWdpbi5uYW1lO1xuICAgICAgICBhc3NlcnQocGx1Z2luTmFtZSwgJ0EgbmFtZSBtdXN0IGJlIHByb3ZpZGVkIGJ5IHRoZSBwbHVnaW4uJyk7XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5saWZlY3ljbGUpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBwbHVnaW5MaWZlID0gcGx1Z2luW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbkxpZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVba2V5XS5vbihwbHVnaW5MaWZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVQbHVnaW4ocGx1Z2luTmFtZSkge1xuICAgICAgICBhc3NlcnQocGx1Z2luTmFtZSwgJ0EgbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICAgIGFzc2VydChwbHVnaW4sIGBUaGUgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIGlzIG5vdCByZWdpc3RlcmVkLmApO1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW4pLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlW2tleV0ucmVtb3ZlKHBsdWdpbltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgaW5oZXJpdCh7IGxpZmVjeWNsZSwgcmVnaXN0ZXJQbHVnaW5zIH0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlKS5mb3JFYWNoKChob29rTmFtZSk9PntcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5saWZlY3ljbGVbaG9va05hbWVdLCBgVGhlIGhvb2sgXCIke2hvb2tOYW1lfVwiIGhhcyBhIGNvbmZsaWN0IGFuZCBjYW5ub3QgYmUgaW5oZXJpdGVkLmApO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVbaG9va05hbWVdID0gbGlmZWN5Y2xlW2hvb2tOYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdGVyUGx1Z2lucykuZm9yRWFjaCgocGx1Z2luTmFtZSk9PntcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0sIGBUaGUgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIGhhcyBhIGNvbmZsaWN0IGFuZCBjYW5ub3QgYmUgaW5oZXJpdGVkLmApO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBsdWdpbihyZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlmZWN5Y2xlKXtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlS2V5cyA9IE9iamVjdC5rZXlzKGxpZmVjeWNsZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ1KCkge1xuICAgIF9leHRlbmRzJDUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFByZWxvYWRBcmdzKHByZWxvYWRDb25maWcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMkNSh7XG4gICAgICAgIHJlc291cmNlQ2F0ZWdvcnk6ICdzeW5jJyxcbiAgICAgICAgc2hhcmU6IHRydWUsXG4gICAgICAgIGRlcHNSZW1vdGU6IHRydWUsXG4gICAgICAgIHByZWZldGNoSW50ZXJmYWNlOiBmYWxzZVxuICAgIH0sIHByZWxvYWRDb25maWcpO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJlbG9hZEFyZ3MocmVtb3RlcywgcHJlbG9hZEFyZ3MpIHtcbiAgICByZXR1cm4gcHJlbG9hZEFyZ3MubWFwKChhcmdzKT0+e1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gbWF0Y2hSZW1vdGUocmVtb3RlcywgYXJncy5uYW1lT3JBbGlhcyk7XG4gICAgICAgIGFzc2VydChyZW1vdGVJbmZvLCBgVW5hYmxlIHRvIHByZWxvYWQgJHthcmdzLm5hbWVPckFsaWFzfSBhcyBpdCBpcyBub3QgaW5jbHVkZWQgaW4gJHshcmVtb3RlSW5mbyAmJiBzYWZlVG9TdHJpbmcoe1xuICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZXNcbiAgICAgICAgfSl9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGU6IHJlbW90ZUluZm8sXG4gICAgICAgICAgICBwcmVsb2FkQ29uZmlnOiBkZWZhdWx0UHJlbG9hZEFyZ3MoYXJncylcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKGV4cG9zZXMpIHtcbiAgICBpZiAoIWV4cG9zZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3Nlcy5tYXAoKGV4cG9zZSk9PntcbiAgICAgICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9zZS5yZXBsYWNlKCcuLycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBob3N0LCBhc3NldHMpIHtcbiAgICBjb25zdCB7IGNzc0Fzc2V0cywganNBc3NldHNXaXRob3V0RW50cnksIGVudHJ5QXNzZXRzIH0gPSBhc3NldHM7XG4gICAgaWYgKGhvc3Qub3B0aW9ucy5pbkJyb3dzZXIpIHtcbiAgICAgICAgZW50cnlBc3NldHMuZm9yRWFjaCgoYXNzZXQpPT57XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZUluZm8gfSA9IGFzc2V0O1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlSW5mby5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0cyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG86IG5lZWRzIHJlYWwgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gcmVzIHx8ICd0aW1lb3V0JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFJlbW90ZUVudHJ5KHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiBuZWVkcyByZWFsIGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIHJlcyB8fCAndGltZW91dCcgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGNzc0Fzc2V0cy5mb3JFYWNoKChjc3NVcmwpPT57XG4gICAgICAgICAgICBjb25zdCB7IGxpbms6IGNzc0VsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVMaW5rKGNzc1VybCwgKCk9Pnt9LCB7XG4gICAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgICAgYXM6ICdzdHlsZSdcbiAgICAgICAgICAgIH0sICh1cmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVMaW5rLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBmcmFnbWVudC5hcHBlbmRDaGlsZChjc3NFbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeS5mb3JFYWNoKChqc1VybCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbGluazogbGlua0VsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVMaW5rKGpzVXJsLCAoKT0+e1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0J1xuICAgICAgICAgICAgfSwgKHVybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua0VsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkNCgpIHtcbiAgICBfZXh0ZW5kcyQ0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpIHtcbiAgICBpZiAoISgncmVtb3RlRW50cnknIGluIHJlbW90ZVNuYXBzaG90KSB8fCAhcmVtb3RlU25hcHNob3QucmVtb3RlRW50cnkpIHtcbiAgICAgICAgZXJyb3IoYFRoZSBhdHRyaWJ1dGUgcmVtb3RlRW50cnkgb2YgJHtuYW1lfSBtdXN0IG5vdCBiZSB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVtb3RlRW50cnkgfSA9IHJlbW90ZVNuYXBzaG90O1xuICAgIGxldCBlbnRyeVVybCA9IGdldFJlc291cmNlVXJsKHJlbW90ZVNuYXBzaG90LCByZW1vdGVFbnRyeSk7XG4gICAgaWYgKCFpc0Jyb3dzZXJFbnYoKSAmJiAhZW50cnlVcmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgIGVudHJ5VXJsID0gYGh0dHBzOiR7ZW50cnlVcmx9YDtcbiAgICB9XG4gICAgcmVtb3RlSW5mby50eXBlID0gcmVtb3RlU25hcHNob3QucmVtb3RlRW50cnlUeXBlO1xuICAgIHJlbW90ZUluZm8uZW50cnlHbG9iYWxOYW1lID0gcmVtb3RlU25hcHNob3QuZ2xvYmFsTmFtZTtcbiAgICByZW1vdGVJbmZvLmVudHJ5ID0gZW50cnlVcmw7XG4gICAgcmVtb3RlSW5mby52ZXJzaW9uID0gcmVtb3RlU25hcHNob3QudmVyc2lvbjtcbiAgICByZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbiA9IHJlbW90ZVNuYXBzaG90LmJ1aWxkVmVyc2lvbjtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90UGx1Z2luKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdzbmFwc2hvdC1wbHVnaW4nLFxuICAgICAgICBhc3luYyBhZnRlclJlc29sdmUgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlLCBwa2dOYW1lT3JBbGlhcywgZXhwb3NlLCBvcmlnaW4sIHJlbW90ZUluZm8gfSA9IGFyZ3M7XG4gICAgICAgICAgICBpZiAoIWlzUmVtb3RlSW5mb1dpdGhFbnRyeShyZW1vdGUpIHx8ICFpc1B1cmVSZW1vdGVFbnRyeShyZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3QgfSA9IGF3YWl0IG9yaWdpbi5zbmFwc2hvdEhhbmRsZXIubG9hZFJlbW90ZVNuYXBzaG90SW5mbyhyZW1vdGUpO1xuICAgICAgICAgICAgICAgIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIC8vIHByZWxvYWRpbmcgYXNzZXRzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZU9yQWxpYXM6IHBrZ05hbWVPckFsaWFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlQ2F0ZWdvcnk6ICdzeW5jJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHNSZW1vdGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IG9yaWdpbi5yZW1vdGVIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5nZW5lcmF0ZVByZWxvYWRBc3NldHMuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIG9yaWdpbiwgYXNzZXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzJDQoe30sIGFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gbmFtZVxuLy8gbmFtZTp2ZXJzaW9uXG5mdW5jdGlvbiBzcGxpdElkKGlkKSB7XG4gICAgY29uc3Qgc3BsaXRJbmZvID0gaWQuc3BsaXQoJzonKTtcbiAgICBpZiAoc3BsaXRJbmZvLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogc3BsaXRJbmZvWzBdLFxuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzcGxpdEluZm8ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMF0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBzcGxpdEluZm9bMV1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogc3BsaXRJbmZvWzFdLFxuICAgICAgICAgICAgdmVyc2lvbjogc3BsaXRJbmZvWzJdXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gVHJhdmVyc2UgYWxsIG5vZGVzIGluIG1vZHVsZUluZm8gYW5kIHRyYXZlcnNlIHRoZSBlbnRpcmUgc25hcHNob3RcbmZ1bmN0aW9uIHRyYXZlcnNlTW9kdWxlSW5mbyhnbG9iYWxTbmFwc2hvdCwgcmVtb3RlSW5mbywgdHJhdmVyc2UsIGlzUm9vdCwgbWVtbyA9IHt9LCByZW1vdGVTbmFwc2hvdCkge1xuICAgIGNvbnN0IGlkID0gZ2V0Rk1JZChyZW1vdGVJbmZvKTtcbiAgICBjb25zdCB7IHZhbHVlOiBzbmFwc2hvdFZhbHVlIH0gPSBnZXRJbmZvV2l0aG91dFR5cGUoZ2xvYmFsU25hcHNob3QsIGlkKTtcbiAgICBjb25zdCBlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdCA9IHJlbW90ZVNuYXBzaG90IHx8IHNuYXBzaG90VmFsdWU7XG4gICAgaWYgKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90ICYmICFpc01hbmlmZXN0UHJvdmlkZXIoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QpKSB7XG4gICAgICAgIHRyYXZlcnNlKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LCByZW1vdGVJbmZvLCBpc1Jvb3QpO1xuICAgICAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QucmVtb3Rlc0luZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUtleXMgPSBPYmplY3Qua2V5cyhlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mbyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZW1vdGVLZXlzKXtcbiAgICAgICAgICAgICAgICBpZiAobWVtb1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlJlbW90ZUluZm8gPSBzcGxpdElkKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlVmFsdWUgPSBlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mb1trZXldO1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlTW9kdWxlSW5mbyhnbG9iYWxTbmFwc2hvdCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJSZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHJlbW90ZVZhbHVlLm1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICAgICAgfSwgdHJhdmVyc2UsIGZhbHNlLCBtZW1vLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlbG9hZEFzc2V0cyhvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGUsIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCkge1xuICAgIGNvbnN0IGNzc0Fzc2V0cyA9IFtdO1xuICAgIGNvbnN0IGpzQXNzZXRzID0gW107XG4gICAgY29uc3QgZW50cnlBc3NldHMgPSBbXTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRKc0Fzc2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRDc3NBc3NldHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcmlnaW47XG4gICAgY29uc3QgeyBwcmVsb2FkQ29uZmlnOiByb290UHJlbG9hZENvbmZpZyB9ID0gcHJlbG9hZE9wdGlvbnM7XG4gICAgY29uc3QgeyBkZXBzUmVtb3RlIH0gPSByb290UHJlbG9hZENvbmZpZztcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGUsIChtb2R1bGVJbmZvU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk9PntcbiAgICAgICAgbGV0IHByZWxvYWRDb25maWc7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIHByZWxvYWRDb25maWcgPSByb290UHJlbG9hZENvbmZpZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcHNSZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRQcmVsb2FkQ29uZmlnID0gZGVwc1JlbW90ZS5maW5kKChyZW1vdGVDb25maWcpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8ubmFtZSB8fCByZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8uYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmRQcmVsb2FkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZyA9IGRlZmF1bHRQcmVsb2FkQXJncyhmaW5kUHJlbG9hZENvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHNSZW1vdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnID0gcm9vdFByZWxvYWRDb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVybCA9IGdldFJlc291cmNlVXJsKG1vZHVsZUluZm9TbmFwc2hvdCwgJ3JlbW90ZUVudHJ5JyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QucmVtb3RlRW50cnkgOiAnJyk7XG4gICAgICAgIGlmIChyZW1vdGVFbnRyeVVybCkge1xuICAgICAgICAgICAgZW50cnlBc3NldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIG1vZHVsZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeTogcmVtb3RlRW50cnlVcmwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdGVFbnRyeVR5cGUnIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5yZW1vdGVFbnRyeVR5cGUgOiAnZ2xvYmFsJyxcbiAgICAgICAgICAgICAgICAgICAgZW50cnlHbG9iYWxOYW1lOiAnZ2xvYmFsTmFtZScgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90Lmdsb2JhbE5hbWUgOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAndmVyc2lvbicgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90LnZlcnNpb24gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogcmVtb3RlRW50cnlVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2R1bGVBc3NldHNJbmZvID0gJ21vZHVsZXMnIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5tb2R1bGVzIDogW107XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3NlcyA9IG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKHByZWxvYWRDb25maWcuZXhwb3Nlcyk7XG4gICAgICAgIGlmIChub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMubGVuZ3RoICYmICdtb2R1bGVzJyBpbiBtb2R1bGVJbmZvU25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciBfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXM7XG4gICAgICAgICAgICBtb2R1bGVBc3NldHNJbmZvID0gbW9kdWxlSW5mb1NuYXBzaG90ID09IG51bGwgPyB2b2lkIDAgOiAoX21vZHVsZUluZm9TbmFwc2hvdF9tb2R1bGVzID0gbW9kdWxlSW5mb1NuYXBzaG90Lm1vZHVsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXMucmVkdWNlKChhc3NldHMsIG1vZHVsZUFzc2V0SW5mbyk9PntcbiAgICAgICAgICAgICAgICBpZiAoKG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3NlcyA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXplZFByZWxvYWRFeHBvc2VzLmluZGV4T2YobW9kdWxlQXNzZXRJbmZvLm1vZHVsZU5hbWUpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXRzLnB1c2gobW9kdWxlQXNzZXRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBc3NldHMoYXNzZXRzKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NldHNSZXMgPSBhc3NldHMubWFwKChhc3NldCk9PmdldFJlc291cmNlVXJsKG1vZHVsZUluZm9TbmFwc2hvdCwgYXNzZXQpKTtcbiAgICAgICAgICAgIGlmIChwcmVsb2FkQ29uZmlnLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NldHNSZXMuZmlsdGVyKHByZWxvYWRDb25maWcuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc3NldHNSZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZUFzc2V0c0luZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0c0xlbmd0aCA9IG1vZHVsZUFzc2V0c0luZm8ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXNzZXRzTGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NldHNJbmZvID0gbW9kdWxlQXNzZXRzSW5mb1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3NlRnVsbFBhdGggPSBgJHtyZW1vdGVJbmZvLm5hbWV9LyR7YXNzZXRzSW5mby5tb2R1bGVOYW1lfWA7XG4gICAgICAgICAgICAgICAgb3JpZ2luLnJlbW90ZUhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmhhbmRsZVByZWxvYWRNb2R1bGUuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBhc3NldHNJbmZvLm1vZHVsZU5hbWUgPT09ICcuJyA/IHJlbW90ZUluZm8ubmFtZSA6IGV4cG9zZUZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBtb2R1bGVJbmZvU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZTogcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZGVkID0gZ2V0UHJlbG9hZGVkKGV4cG9zZUZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJlbG9hZENvbmZpZy5yZXNvdXJjZUNhdGVnb3J5ID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuY3NzLmFzeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5jc3Muc3luYykpO1xuICAgICAgICAgICAgICAgICAgICBqc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5qcy5hc3luYykpO1xuICAgICAgICAgICAgICAgICAgICBqc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5qcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlbG9hZENvbmZpZy5yZXNvdXJjZUNhdGVnb3J5ID0gJ3N5bmMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5jc3Muc3luYykpO1xuICAgICAgICAgICAgICAgICAgICBqc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5qcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFByZWxvYWRlZChleHBvc2VGdWxsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0cnVlLCBtZW1vLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgaWYgKHJlbW90ZVNuYXBzaG90LnNoYXJlZCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0U2hhcmVkQXNzZXRzID0gKHNoYXJlSW5mbywgc25hcHNob3RTaGFyZWQpPT57XG4gICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKG9yaWdpbi5zaGFyZVNjb3BlTWFwLCBzbmFwc2hvdFNoYXJlZC5zaGFyZWROYW1lLCBzaGFyZUluZm8sIG9yaWdpbi5zaGFyZWRIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGdsb2JhbCBzaGFyZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGxpYiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgaXQgbWVhbnMgdGhhdCB0aGUgc2hhcmVkIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0IGFuZCBjYW4gYmUgcHJlbG9hZGVkLlxuICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQgJiYgdHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQubGliID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc25hcHNob3RTaGFyZWQuYXNzZXRzLmpzLnN5bmMuZm9yRWFjaCgoYXNzZXQpPT57XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZFNoYXJlZEpzQXNzZXRzLmFkZChhc3NldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc25hcHNob3RTaGFyZWQuYXNzZXRzLmNzcy5zeW5jLmZvckVhY2goKGFzc2V0KT0+e1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWRTaGFyZWRDc3NBc3NldHMuYWRkKGFzc2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVtb3RlU25hcHNob3Quc2hhcmVkLmZvckVhY2goKHNoYXJlZCk9PntcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zaGFyZWQ7XG4gICAgICAgICAgICBjb25zdCBzaGFyZUluZm9zID0gKF9vcHRpb25zX3NoYXJlZCA9IG9wdGlvbnMuc2hhcmVkKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnNfc2hhcmVkW3NoYXJlZC5zaGFyZWROYW1lXTtcbiAgICAgICAgICAgIGlmICghc2hhcmVJbmZvcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vIHZlcnNpb24sIHByZWxvYWQgYWxsIHNoYXJlZFxuICAgICAgICAgICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHNoYXJlZC52ZXJzaW9uID8gc2hhcmVJbmZvcy5maW5kKChzKT0+cy52ZXJzaW9uID09PSBzaGFyZWQudmVyc2lvbikgOiBzaGFyZUluZm9zO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyYXlTaGFyZUluZm8gPSBhcnJheU9wdGlvbnMoc2hhcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICBhcnJheVNoYXJlSW5mby5mb3JFYWNoKChzKT0+e1xuICAgICAgICAgICAgICAgIGNvbGxlY3RTaGFyZWRBc3NldHMocywgc2hhcmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbmVlZFByZWxvYWRKc0Fzc2V0cyA9IGpzQXNzZXRzLmZpbHRlcigoYXNzZXQpPT4hbG9hZGVkU2hhcmVkSnNBc3NldHMuaGFzKGFzc2V0KSk7XG4gICAgY29uc3QgbmVlZFByZWxvYWRDc3NBc3NldHMgPSBjc3NBc3NldHMuZmlsdGVyKChhc3NldCk9PiFsb2FkZWRTaGFyZWRDc3NBc3NldHMuaGFzKGFzc2V0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3NzQXNzZXRzOiBuZWVkUHJlbG9hZENzc0Fzc2V0cyxcbiAgICAgICAganNBc3NldHNXaXRob3V0RW50cnk6IG5lZWRQcmVsb2FkSnNBc3NldHMsXG4gICAgICAgIGVudHJ5QXNzZXRzXG4gICAgfTtcbn1cbmNvbnN0IGdlbmVyYXRlUHJlbG9hZEFzc2V0c1BsdWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdnZW5lcmF0ZS1wcmVsb2FkLWFzc2V0cy1wbHVnaW4nLFxuICAgICAgICBhc3luYyBnZW5lcmF0ZVByZWxvYWRBc3NldHMgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3JpZ2luLCBwcmVsb2FkT3B0aW9ucywgcmVtb3RlSW5mbywgcmVtb3RlLCBnbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QgfSA9IGFyZ3M7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdGVJbmZvV2l0aEVudHJ5KHJlbW90ZSkgJiYgaXNQdXJlUmVtb3RlRW50cnkocmVtb3RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0czogW10sXG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW50cnlBc3NldHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJlbW90ZS5lbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IHJlbW90ZS5lbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dsb2JhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5R2xvYmFsTmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGU6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gZ2VuZXJhdGVQcmVsb2FkQXNzZXRzKG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZUluZm8sIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDMoKSB7XG4gICAgX2V4dGVuZHMkMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jbGFzcyBTbmFwc2hvdEhhbmRsZXIge1xuICAgIGFzeW5jIGxvYWRTbmFwc2hvdChtb2R1bGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5Ib3N0SW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHsgaG9zdEdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3QgfSA9IHRoaXMuZ2V0R2xvYmFsUmVtb3RlSW5mbyhtb2R1bGVJbmZvKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdDogZ2xvYmFsUmVtb3RlU25hcHNob3QsIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICBob3N0R2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IGdsb2JhbFJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG4gICAgYXN5bmMgbG9hZFJlbW90ZVNuYXBzaG90SW5mbyhtb2R1bGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5Ib3N0SW5zdGFuY2U7XG4gICAgICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtb2R1bGVJbmZvXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaG9zdFNuYXBzaG90ID0gZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFob3N0U25hcHNob3QpIHtcbiAgICAgICAgICAgIGhvc3RTbmFwc2hvdCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLnZlcnNpb24gfHwgJycsXG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnk6ICcnLFxuICAgICAgICAgICAgICAgIHJlbW90ZXNJbmZvOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZEdsb2JhbFNuYXBzaG90KHtcbiAgICAgICAgICAgICAgICBbdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lXTogaG9zdFNuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBkeW5hbWljIGxvYWRSZW1vdGUgc2NlbmFyaW9zLCBpbmNvbXBsZXRlIHJlbW90ZXNJbmZvIGRlbGl2ZXJ5IG1heSBvY2N1ci4gSW4gc3VjaCBjYXNlcywgdGhlIHJlbW90ZXNJbmZvIGluIHRoZSBob3N0IG5lZWRzIHRvIGJlIGNvbXBsZXRlZCBpbiB0aGUgc25hcHNob3QgYXQgcnVudGltZS5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBzbmFwc2hvdCdzIGludGVncml0eSBhbmQgaGVscHMgdGhlIGNocm9tZSBwbHVnaW4gY29ycmVjdGx5IGlkZW50aWZ5IGFsbCBwcm9kdWNlciBtb2R1bGVzLCBlbnN1cmluZyB0aGF0IHByb3h5YWJsZSBwcm9kdWNlciBtb2R1bGVzIHdpbGwgbm90IGJlIG1pc3NpbmcuXG4gICAgICAgIGlmIChob3N0U25hcHNob3QgJiYgJ3JlbW90ZXNJbmZvJyBpbiBob3N0U25hcHNob3QgJiYgIWdldEluZm9XaXRob3V0VHlwZShob3N0U25hcHNob3QucmVtb3Rlc0luZm8sIG1vZHVsZUluZm8ubmFtZSkudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbW9kdWxlSW5mbyB8fCAnZW50cnknIGluIG1vZHVsZUluZm8pIHtcbiAgICAgICAgICAgICAgICBob3N0U25hcHNob3QucmVtb3Rlc0luZm8gPSBfZXh0ZW5kcyQzKHt9LCBob3N0U25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywge1xuICAgICAgICAgICAgICAgICAgICBbbW9kdWxlSW5mby5uYW1lXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvID8gbW9kdWxlSW5mby52ZXJzaW9uIDogbW9kdWxlSW5mby5lbnRyeVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gdGhpcy5nZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGdsb2JhbCBzbmFwc2hvdCBpbmNsdWRlcyBtYW5pZmVzdCBvciBtb2R1bGUgaW5mbyBpbmNsdWRlcyBtYW5pZmVzdFxuICAgICAgICBpZiAoZ2xvYmFsUmVtb3RlU25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmIChpc01hbmlmZXN0UHJvdmlkZXIoZ2xvYmFsUmVtb3RlU25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU25hcHNob3QgPSBhd2FpdCB0aGlzLmdldE1hbmlmZXN0SnNvbihnbG9iYWxSZW1vdGVTbmFwc2hvdC5yZW1vdGVFbnRyeSwgbW9kdWxlSW5mbywge30pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU25hcHNob3RSZXMgPSBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oX2V4dGVuZHMkMyh7fSwgbW9kdWxlSW5mbywge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ2xvYmFsIHJlbW90ZSBtYXkgYmUgb3ZlcnJpZGRlblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHNldCB0aGUgc25hcHNob3Qga2V5IHRvIHRoZSBnbG9iYWwgYWRkcmVzcyBvZiB0aGUgYWN0dWFsIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgZW50cnk6IGdsb2JhbFJlbW90ZVNuYXBzaG90LnJlbW90ZUVudHJ5XG4gICAgICAgICAgICAgICAgfSksIG1vZHVsZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbW9kdWxlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ2dsb2JhbCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdGVJbmZvV2l0aEVudHJ5KG1vZHVsZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGZyb20gbWFuaWZlc3QuanNvbiBhbmQgbWVyZ2UgcmVtb3RlIGluZm8gZnJvbSByZW1vdGUgc2VydmVyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU25hcHNob3QgPSBhd2FpdCB0aGlzLmdldE1hbmlmZXN0SnNvbihtb2R1bGVJbmZvLmVudHJ5LCBtb2R1bGVJbmZvLCB7fSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTbmFwc2hvdFJlcyA9IHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhtb2R1bGVJbmZvLCBtb2R1bGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1vZHVsZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAnZ2xvYmFsJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYFxuICAgICAgICAgIENhbm5vdCBnZXQgcmVtb3RlU25hcHNob3Qgd2l0aCB0aGUgbmFtZTogJyR7bW9kdWxlSW5mby5uYW1lfScsIHZlcnNpb246ICcke21vZHVsZUluZm8udmVyc2lvbn0nIGZyb20gX19GRURFUkFUSU9OX18ubW9kdWxlSW5mby4gVGhlIGZvbGxvd2luZyByZWFzb25zIG1heSBiZSBjYXVzaW5nIHRoZSBwcm9ibGVtOlxcblxuICAgICAgICAgIDEuIFRoZSBEZXBsb3kgcGxhdGZvcm0gZGlkIG5vdCBkZWxpdmVyIHRoZSBjb3JyZWN0IGRhdGEuIFlvdSBjYW4gdXNlIF9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8gdG8gY2hlY2sgdGhlIHJlbW90ZUluZm8uXFxuXG4gICAgICAgICAgMi4gVGhlIHJlbW90ZSAnJHttb2R1bGVJbmZvLm5hbWV9JyB2ZXJzaW9uICcke21vZHVsZUluZm8udmVyc2lvbn0nIGlzIG5vdCByZWxlYXNlZC5cXG5cbiAgICAgICAgICBUaGUgdHJhbnNmb3JtZWQgbW9kdWxlIGluZm86ICR7SlNPTi5zdHJpbmdpZnkoZ2xvYmFsU25hcHNob3RSZXMpfVxuICAgICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pIHtcbiAgICAgICAgY29uc3QgaG9zdEdsb2JhbFNuYXBzaG90ID0gZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2V0IHJlbW90ZSBkZXRhaWwgaW5mbyBmcm9tIGdsb2JhbFxuICAgICAgICBjb25zdCBnbG9iYWxSZW1vdGVJbmZvID0gaG9zdEdsb2JhbFNuYXBzaG90ICYmICdyZW1vdGVzSW5mbycgaW4gaG9zdEdsb2JhbFNuYXBzaG90ICYmIGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbyAmJiBnZXRJbmZvV2l0aG91dFR5cGUoaG9zdEdsb2JhbFNuYXBzaG90LnJlbW90ZXNJbmZvLCBtb2R1bGVJbmZvLm5hbWUpLnZhbHVlO1xuICAgICAgICBpZiAoZ2xvYmFsUmVtb3RlSW5mbyAmJiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3QoKSxcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbW9kdWxlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdldEdsb2JhbFNuYXBzaG90KCksXG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gPyBtb2R1bGVJbmZvLnZlcnNpb24gOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldE1hbmlmZXN0SnNvbihtYW5pZmVzdFVybCwgbW9kdWxlSW5mbywgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGdldE1hbmlmZXN0ID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGxldCBtYW5pZmVzdEpzb24gPSB0aGlzLm1hbmlmZXN0Q2FjaGUuZ2V0KG1hbmlmZXN0VXJsKTtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdEpzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3RKc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy5sb2FkZXJIb29rLmxpZmVjeWNsZS5mZXRjaC5lbWl0KG1hbmlmZXN0VXJsLCB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2gobWFuaWZlc3RVcmwsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuaWZlc3RKc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQobWFuaWZlc3RKc29uLm1ldGFEYXRhICYmIG1hbmlmZXN0SnNvbi5leHBvc2VzICYmIG1hbmlmZXN0SnNvbi5zaGFyZWQsIGAke21hbmlmZXN0VXJsfSBpcyBub3QgYSBmZWRlcmF0aW9uIG1hbmlmZXN0YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdENhY2hlLnNldChtYW5pZmVzdFVybCwgbWFuaWZlc3RKc29uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3RKc29uO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYEZhaWxlZCB0byBnZXQgbWFuaWZlc3RKc29uIGZvciAke21vZHVsZUluZm8ubmFtZX0uIFRoZSBtYW5pZmVzdCBVUkwgaXMgJHttYW5pZmVzdFVybH0uIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgbWFuaWZlc3RVcmwgaXMgYWNjZXNzaWJsZS5cbiAgICAgICAgICBcXG4gRXJyb3IgbWVzc2FnZTpcbiAgICAgICAgICBcXG4gJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFzeW5jTG9hZFByb2Nlc3MgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3RKc29uID0gYXdhaXQgZ2V0TWFuaWZlc3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZVNuYXBzaG90ID0gZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdChtYW5pZmVzdEpzb24sIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtYW5pZmVzdFVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzb24sXG4gICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgbWFuaWZlc3RVcmwsXG4gICAgICAgICAgICAgICAgZnJvbTogJ21hbmlmZXN0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlU25hcHNob3RSZXM7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5tYW5pZmVzdExvYWRpbmdbbWFuaWZlc3RVcmxdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF0gPSBhc3luY0xvYWRQcm9jZXNzKCkudGhlbigocmVzKT0+cmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdExvYWRpbmdbbWFuaWZlc3RVcmxdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihIb3N0SW5zdGFuY2Upe1xuICAgICAgICB0aGlzLmxvYWRpbmdIb3N0U25hcHNob3QgPSBudWxsO1xuICAgICAgICB0aGlzLm1hbmlmZXN0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZUxvYWRSZW1vdGVTbmFwc2hvdDogbmV3IEFzeW5jSG9vaygnYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90JyksXG4gICAgICAgICAgICBsb2FkU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2xvYWRHbG9iYWxTbmFwc2hvdCcpLFxuICAgICAgICAgICAgbG9hZFJlbW90ZVNuYXBzaG90OiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdsb2FkUmVtb3RlU25hcHNob3QnKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYW5pZmVzdExvYWRpbmcgPSBHbG9iYWwuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX187XG4gICAgICAgIHRoaXMuSG9zdEluc3RhbmNlID0gSG9zdEluc3RhbmNlO1xuICAgICAgICB0aGlzLmxvYWRlckhvb2sgPSBIb3N0SW5zdGFuY2UubG9hZGVySG9vaztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDIoKSB7XG4gICAgX2V4dGVuZHMkMiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY2xhc3MgU2hhcmVkSGFuZGxlciB7XG4gICAgLy8gcmVnaXN0ZXIgc2hhcmVkIGluIHNoYXJlU2NvcGVNYXBcbiAgICByZWdpc3RlclNoYXJlZChnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNoYXJlSW5mb3MsIHNoYXJlZCB9ID0gZm9ybWF0U2hhcmVDb25maWdzKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKHNoYXJlSW5mb3MpO1xuICAgICAgICBzaGFyZWRLZXlzLmZvckVhY2goKHNoYXJlZEtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHMgPSBzaGFyZUluZm9zW3NoYXJlZEtleV07XG4gICAgICAgICAgICBzaGFyZWRWYWxzLmZvckVhY2goKHNoYXJlZFZhbCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgc2hhcmVkS2V5LCBzaGFyZWRWYWwsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkICYmIHNoYXJlZFZhbCAmJiBzaGFyZWRWYWwubGliKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZ05hbWU6IHNoYXJlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYjogc2hhcmVkVmFsLmxpYixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogc2hhcmVkVmFsLmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVkVmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdXNlck9wdGlvbnMubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFyZUluZm9zLFxuICAgICAgICAgICAgc2hhcmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTaGFyZShwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgICAgIC8vIDEuIENoZWNrcyBpZiB0aGUgY3VycmVudGx5IGxvYWRlZCBzaGFyZSBhbHJlYWR5IGV4aXN0cywgaWYgbm90LCBpdCB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gMi4gU2VhcmNoZXMgZ2xvYmFsbHkgZm9yIGEgbWF0Y2hpbmcgc2hhcmUsIGlmIGZvdW5kLCBpdCB1c2VzIGl0IGRpcmVjdGx5XG4gICAgICAgIC8vIDMuIElmIG5vdCBmb3VuZCwgaXQgcmV0cmlldmVzIGl0IGZyb20gdGhlIGN1cnJlbnQgc2hhcmUgYW5kIHN0b3JlcyB0aGUgb2J0YWluZWQgc2hhcmUgZ2xvYmFsbHkuXG4gICAgICAgIGNvbnN0IHNoYXJlSW5mbyA9IGdldFRhcmdldFNoYXJlZE9wdGlvbnMoe1xuICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgIGV4dHJhT3B0aW9ucyxcbiAgICAgICAgICAgIHNoYXJlSW5mb3M6IGhvc3Qub3B0aW9ucy5zaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaGFyZUluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHNoYXJlSW5mby5zY29wZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc2hhcmVJbmZvLnNjb3BlLm1hcChhc3luYyAoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGUsIHNoYXJlSW5mby5zdHJhdGVneSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkU2hhcmVSZXMgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVMb2FkU2hhcmUuZW1pdCh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgc2hhcmVJbmZvLFxuICAgICAgICAgICAgc2hhcmVkOiBob3N0Lm9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHNoYXJlSW5mbzogc2hhcmVJbmZvUmVzIH0gPSBsb2FkU2hhcmVSZXM7XG4gICAgICAgIC8vIEFzc2VydCB0aGF0IHNoYXJlSW5mb1JlcyBleGlzdHMsIGlmIG5vdCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgYXNzZXJ0KHNoYXJlSW5mb1JlcywgYENhbm5vdCBmaW5kICR7cGtnTmFtZX0gU2hhcmUgaW4gdGhlICR7aG9zdC5vcHRpb25zLm5hbWV9LiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlICR7cGtnTmFtZX0gU2hhcmUgcGFyYW1ldGVycyBoYXZlIGJlZW4gaW5qZWN0ZWRgKTtcbiAgICAgICAgLy8gUmV0cmlldmUgZnJvbSBjYWNoZVxuICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvUmVzLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICBjb25zdCBhZGRVc2VJbiA9IChzaGFyZWQpPT57XG4gICAgICAgICAgICBpZiAoIXNoYXJlZC51c2VJbikge1xuICAgICAgICAgICAgICAgIHNoYXJlZC51c2VJbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVW5pcXVlSXRlbShzaGFyZWQudXNlSW4sIGhvc3Qub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQgJiYgcmVnaXN0ZXJlZFNoYXJlZC5saWIpIHtcbiAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTaGFyZWQubGliO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZ2lzdGVyZWRTaGFyZWQgJiYgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkaW5nICYmICFyZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCkge1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHJlZ2lzdGVyZWRTaGFyZWQubG9hZGluZztcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghcmVnaXN0ZXJlZFNoYXJlZC5saWIpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9IGVsc2UgaWYgKHJlZ2lzdGVyZWRTaGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzeW5jTG9hZFByb2Nlc3MgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCByZWdpc3RlcmVkU2hhcmVkLmdldCgpO1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mb1Jlcy5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mb1Jlcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZFVzZUluKHNoYXJlSW5mb1Jlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ1NoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlSW5mb1JlcywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ1NoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9IGFzeW5jTG9hZFByb2Nlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hhcmVkOiByZWdpc3RlcmVkU2hhcmVkLFxuICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGxpYjogbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZXh0cmFPcHRpb25zLmN1c3RvbVNoYXJlSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFzeW5jTG9hZFByb2Nlc3MgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCBzaGFyZUluZm9SZXMuZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4oc2hhcmVJbmZvUmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvUmVzLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICAgICAgICAgIGlmIChnU2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gYXN5bmNMb2FkUHJvY2VzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHNoYXJlSW5mb1JlcyxcbiAgICAgICAgICAgICAgICBmcm9tOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBsaWI6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgc2hhcmluZyBzZXF1ZW5jZSAoZXhlY3V0ZWQgb25seSBvbmNlIHBlciBzaGFyZSBzY29wZSkuXG4gICAqIEl0IGFjY2VwdHMgb25lIGFyZ3VtZW50LCB0aGUgbmFtZSBvZiB0aGUgc2hhcmUgc2NvcGUuXG4gICAqIElmIHRoZSBzaGFyZSBzY29wZSBkb2VzIG5vdCBleGlzdCwgaXQgY3JlYXRlcyBvbmUuXG4gICAqLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGVOYW1lID0gREVGQVVMVF9TQ09QRSwgc3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzaGFyZVNjb3BlID0gdGhpcy5zaGFyZVNjb3BlTWFwO1xuICAgICAgICBjb25zdCBob3N0TmFtZSA9IGhvc3Qub3B0aW9ucy5uYW1lO1xuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IHNoYXJlIHNjb3BlIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdKSB7XG4gICAgICAgICAgICBzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGVzIGFsbCBpbml0aWFsaXphdGlvbiBzbmlwcGV0cyBmcm9tIGFsbCBhY2Nlc3NpYmxlIG1vZHVsZXNcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgc2hhcmVkKT0+e1xuICAgICAgICAgICAgdmFyIF9hY3RpdmVWZXJzaW9uX3NoYXJlQ29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBlYWdlciB9ID0gc2hhcmVkO1xuICAgICAgICAgICAgc2NvcGVbbmFtZV0gPSBzY29wZVtuYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gc2NvcGVbbmFtZV07XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWZXJzaW9uID0gdmVyc2lvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWZXJzaW9uRWFnZXIgPSBCb29sZWFuKGFjdGl2ZVZlcnNpb24gJiYgKGFjdGl2ZVZlcnNpb24uZWFnZXIgfHwgKChfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZyA9IGFjdGl2ZVZlcnNpb24uc2hhcmVDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZy5lYWdlcikpKTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlVmVyc2lvbiB8fCBhY3RpdmVWZXJzaW9uLnN0cmF0ZWd5ICE9PSAnbG9hZGVkLWZpcnN0JyAmJiAhYWN0aXZlVmVyc2lvbi5sb2FkZWQgJiYgKEJvb2xlYW4oIWVhZ2VyKSAhPT0gIWFjdGl2ZVZlcnNpb25FYWdlciA/IGVhZ2VyIDogaG9zdE5hbWUgPiBhY3RpdmVWZXJzaW9uLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbnNbdmVyc2lvbl0gPSBzaGFyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IGluaXRGbiA9IChtb2QpPT5tb2QgJiYgbW9kLmluaXQgJiYgbW9kLmluaXQoc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV0pO1xuICAgICAgICBjb25zdCBpbml0UmVtb3RlTW9kdWxlID0gYXN5bmMgKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kdWxlIH0gPSBhd2FpdCBob3N0LnJlbW90ZUhhbmRsZXIuZ2V0UmVtb3RlTW9kdWxlQW5kT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmdldEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBtb2R1bGUuZ2V0RW50cnkoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZS5pbml0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEZuKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmluaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhob3N0Lm9wdGlvbnMuc2hhcmVkKS5mb3JFYWNoKChzaGFyZU5hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRBcnIgPSBob3N0Lm9wdGlvbnMuc2hhcmVkW3NoYXJlTmFtZV07XG4gICAgICAgICAgICBzaGFyZWRBcnIuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuc2NvcGUuaW5jbHVkZXMoc2hhcmVTY29wZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKHNoYXJlTmFtZSwgc2hhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ3ZlcnNpb24tZmlyc3QnKSB7XG4gICAgICAgICAgICBob3N0Lm9wdGlvbnMucmVtb3Rlcy5mb3JFYWNoKChyZW1vdGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZS5zaGFyZVNjb3BlID09PSBzaGFyZVNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGluaXRSZW1vdGVNb2R1bGUocmVtb3RlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgfVxuICAgIC8vIFRoZSBsaWIgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgc2hhcmVkIHNldCBieSBlYWdlciBvciBydW50aW1lIGluaXQgaXMgc2V0IG9yIHRoZSBzaGFyZWQgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAvLyAxLiBJZiB0aGUgbG9hZGVkIHNoYXJlZCBhbHJlYWR5IGV4aXN0cyBnbG9iYWxseSwgdGhlbiBpdCB3aWxsIGJlIHJldXNlZFxuICAgIC8vIDIuIElmIGxpYiBleGlzdHMgaW4gbG9jYWwgc2hhcmVkLCBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICAvLyAzLiBJZiB0aGUgbG9jYWwgZ2V0IHJldHVybnMgc29tZXRoaW5nIG90aGVyIHRoYW4gUHJvbWlzZSwgdGhlbiBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBsb2FkU2hhcmVTeW5jKHBrZ05hbWUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNoYXJlSW5mbyA9IGdldFRhcmdldFNoYXJlZE9wdGlvbnMoe1xuICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgIGV4dHJhT3B0aW9ucyxcbiAgICAgICAgICAgIHNoYXJlSW5mb3M6IGhvc3Qub3B0aW9ucy5zaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaGFyZUluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHNoYXJlSW5mby5zY29wZSkge1xuICAgICAgICAgICAgc2hhcmVJbmZvLnNjb3BlLmZvckVhY2goKHNoYXJlU2NvcGUpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlLCBzaGFyZUluZm8uc3RyYXRlZ3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlSW5mbywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgY29uc3QgYWRkVXNlSW4gPSAoc2hhcmVkKT0+e1xuICAgICAgICAgICAgaWYgKCFzaGFyZWQudXNlSW4pIHtcbiAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVuaXF1ZUl0ZW0oc2hhcmVkLnVzZUluLCBob3N0Lm9wdGlvbnMubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQubGliID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkLmZyb20gPT09IGhvc3Qub3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZUluZm8ubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gcmVnaXN0ZXJlZFNoYXJlZC5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGliOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZUluZm8ubGliKSB7XG4gICAgICAgICAgICBpZiAoIXNoYXJlSW5mby5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm8ubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFyZUluZm8ubGliO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZUluZm8uZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBzaGFyZUluZm8uZ2V0KCk7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIFRoZSBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gbG9hZCAke3BrZ05hbWV9LiBUaGUgJHtwa2dOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gJHtob3N0Lm9wdGlvbnMubmFtZX0uXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgZm9yIGZhaWx1cmU6IFxcblxuICAgICAgICAxLiBUaGUgJHtwa2dOYW1lfSBzaGFyZSB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZ2V0JyBhdHRyaWJ1dGUsIGJ1dCBsb2FkU2hhcmUgd2FzIG5vdCB1c2VkIGJlZm9yZWhhbmQuXFxuXG4gICAgICAgIDIuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnbGliJyBhdHRyaWJ1dGUuXFxuXG4gICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXJlSW5mby5saWIgPSBtb2R1bGU7XG4gICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBzaGFyZUluZm8ubGliLFxuICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVJbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzaGFyZUluZm8ubGliO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIFRoZSBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gbG9hZCAke3BrZ05hbWV9LiBUaGUgJHtwa2dOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gJHtob3N0Lm9wdGlvbnMubmFtZX0uXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgZm9yIGZhaWx1cmU6IFxcblxuICAgICAgICAxLiBUaGUgJHtwa2dOYW1lfSBzaGFyZSB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZ2V0JyBhdHRyaWJ1dGUsIGJ1dCBsb2FkU2hhcmUgd2FzIG5vdCB1c2VkIGJlZm9yZWhhbmQuXFxuXG4gICAgICAgIDIuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnbGliJyBhdHRyaWJ1dGUuXFxuXG4gICAgICBgKTtcbiAgICB9XG4gICAgaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3Njb3BlTmFtZV0gPSBzaGFyZVNjb3BlO1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcC5lbWl0KHtcbiAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFNoYXJlZCh7IHBrZ05hbWUsIHNoYXJlZCwgZnJvbSwgbGliLCBsb2FkaW5nLCBsb2FkZWQsIGdldCB9KSB7XG4gICAgICAgIGNvbnN0IHsgdmVyc2lvbiwgc2NvcGUgPSAnZGVmYXVsdCcgfSA9IHNoYXJlZCwgc2hhcmVJbmZvID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uoc2hhcmVkLCBbXG4gICAgICAgICAgICBcInZlcnNpb25cIixcbiAgICAgICAgICAgIFwic2NvcGVcIlxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gQXJyYXkuaXNBcnJheShzY29wZSkgPyBzY29wZSA6IFtcbiAgICAgICAgICAgIHNjb3BlXG4gICAgICAgIF07XG4gICAgICAgIHNjb3Blcy5mb3JFYWNoKChzYyk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZVNjb3BlTWFwW3NjXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY10gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVt2ZXJzaW9uXSA9IF9leHRlbmRzJDIoe1xuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgc2hhcmVJbmZvLCB7XG4gICAgICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dLmdldCA9IGdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXRHbG9iYWxTaGFyZVNjb3BlTWFwKGhvc3RPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbFNoYXJlU2NvcGVNYXAgPSBnZXRHbG9iYWxTaGFyZVNjb3BlKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBob3N0T3B0aW9ucy5pZCB8fCBob3N0T3B0aW9ucy5uYW1lO1xuICAgICAgICBpZiAoaWRlbnRpZmllciAmJiAhZ2xvYmFsU2hhcmVTY29wZU1hcFtpZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgZ2xvYmFsU2hhcmVTY29wZU1hcFtpZGVudGlmaWVyXSA9IHRoaXMuc2hhcmVTY29wZU1hcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihob3N0KXtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYWZ0ZXJSZXNvbHZlOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdhZnRlclJlc29sdmUnKSxcbiAgICAgICAgICAgIGJlZm9yZUxvYWRTaGFyZTogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlTG9hZFNoYXJlJyksXG4gICAgICAgICAgICAvLyBub3QgdXNlZCB5ZXRcbiAgICAgICAgICAgIGxvYWRTaGFyZTogbmV3IEFzeW5jSG9vaygpLFxuICAgICAgICAgICAgcmVzb2x2ZVNoYXJlOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ3Jlc29sdmVTaGFyZScpLFxuICAgICAgICAgICAgLy8gbWF5YmUgd2lsbCBjaGFuZ2UsIHRlbXBvcmFyaWx5IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICAgICAgaW5pdENvbnRhaW5lclNoYXJlU2NvcGVNYXA6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2luaXRDb250YWluZXInKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwID0ge307XG4gICAgICAgIHRoaXMuX3NldEdsb2JhbFNoYXJlU2NvcGVNYXAoaG9zdC5vcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDEoKSB7XG4gICAgX2V4dGVuZHMkMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jbGFzcyBSZW1vdGVIYW5kbGVyIHtcbiAgICBmb3JtYXRBbmRSZWdpc3RlclJlbW90ZShnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB1c2VyUmVtb3RlcyA9IHVzZXJPcHRpb25zLnJlbW90ZXMgfHwgW107XG4gICAgICAgIHJldHVybiB1c2VyUmVtb3Rlcy5yZWR1Y2UoKHJlcywgcmVtb3RlKT0+e1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclJlbW90ZShyZW1vdGUsIHJlcywge1xuICAgICAgICAgICAgICAgIGZvcmNlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBnbG9iYWxPcHRpb25zLnJlbW90ZXMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgbG9hZFJlbW90ZShpZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvYWRGYWN0b3J5ID0gdHJ1ZSB9ID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAxLiBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgcmV0cmlldmVkIG1vZHVsZS4gVGhlcmUgYXJlIHR3byBtb2R1bGUgcmVxdWVzdCBtZXRob2RzOiBwa2dOYW1lICsgZXhwb3NlIGFuZCBhbGlhcyArIGV4cG9zZS5cbiAgICAgICAgICAgIC8vIDIuIFJlcXVlc3QgdGhlIHNuYXBzaG90IGluZm9ybWF0aW9uIG9mIHRoZSBjdXJyZW50IGhvc3QgYW5kIGdsb2JhbGx5IHN0b3JlIHRoZSBvYnRhaW5lZCBzbmFwc2hvdCBpbmZvcm1hdGlvbi4gVGhlIHJldHJpZXZlZCBtb2R1bGUgaW5mb3JtYXRpb24gaXMgcGFydGlhbGx5IG9mZmxpbmUgYW5kIHBhcnRpYWxseSBvbmxpbmUuIFRoZSBvbmxpbmUgbW9kdWxlIGluZm9ybWF0aW9uIHdpbGwgcmV0cmlldmUgdGhlIG1vZHVsZXMgdXNlZCBvbmxpbmUuXG4gICAgICAgICAgICAvLyAzLiBSZXRyaWV2ZSB0aGUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb2YgdGhlIGN1cnJlbnQgbW9kdWxlIGZyb20gZ2xvYmFsIChyZW1vdGVFbnRyeSBhZGRyZXNzLCBleHBvc2UgcmVzb3VyY2UgYWRkcmVzcylcbiAgICAgICAgICAgIC8vIDQuIEFmdGVyIHJldHJpZXZpbmcgcmVtb3RlRW50cnksIGNhbGwgdGhlIGluaXQgb2YgdGhlIG1vZHVsZSwgYW5kIHRoZW4gcmV0cmlldmUgdGhlIGV4cG9ydGVkIGNvbnRlbnQgb2YgdGhlIG1vZHVsZSB0aHJvdWdoIGdldFxuICAgICAgICAgICAgLy8gaWQ6IHBrZ05hbWUoQGZlZGVyYXRpb24vYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IEBmZWRlcmF0aW9uL2FwcDEvYnV0dG9uXG4gICAgICAgICAgICAvLyBpZDogYWxpYXMoYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IGFwcDEvYnV0dG9uXG4gICAgICAgICAgICAvLyBpZDogYWxpYXMoYXBwMS91dGlscykgKyBleHBvc2UobG9hZGFzaC9zb3J0KSA9IGFwcDEvdXRpbHMvbG9hZGFzaC9zb3J0XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZSwgbW9kdWxlT3B0aW9ucywgcmVtb3RlTWF0Y2hJbmZvIH0gPSBhd2FpdCB0aGlzLmdldFJlbW90ZU1vZHVsZUFuZE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtnTmFtZU9yQWxpYXMsIHJlbW90ZSwgZXhwb3NlLCBpZDogaWRSZXMgfSA9IHJlbW90ZU1hdGNoSW5mbztcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZU9yRmFjdG9yeSA9IGF3YWl0IG1vZHVsZS5nZXQoaWRSZXMsIGV4cG9zZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVXcmFwcGVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFJlcyxcbiAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICBleHBvc2UsXG4gICAgICAgICAgICAgICAgZXhwb3NlTW9kdWxlOiBsb2FkRmFjdG9yeSA/IG1vZHVsZU9yRmFjdG9yeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGVGYWN0b3J5OiBsb2FkRmFjdG9yeSA/IHVuZGVmaW5lZCA6IG1vZHVsZU9yRmFjdG9yeSxcbiAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbnN0YW5jZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlV3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVPckZhY3Rvcnk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20gPSAncnVudGltZScgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxPdmVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlOiAnb25Mb2FkJyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmYWlsT3Zlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhaWxPdmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgcHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVByZWxvYWRSZW1vdGUuZW1pdCh7XG4gICAgICAgICAgICBwcmVsb2FkT3BzOiBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlbG9hZE9wcyA9IGZvcm1hdFByZWxvYWRBcmdzKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBwcmVsb2FkT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZWxvYWRPcHMubWFwKGFzeW5jIChvcHMpPT57XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSB9ID0gb3BzO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8ocmVtb3RlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhd2FpdCBob3N0LnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5nZW5lcmF0ZVByZWxvYWRBc3NldHMuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgIHByZWxvYWRPcHRpb25zOiBvcHMsXG4gICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhc3NldHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIGhvc3QsIGFzc2V0cyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICByZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSZW1vdGUocmVtb3RlLCBob3N0Lm9wdGlvbnMucmVtb3Rlcywge1xuICAgICAgICAgICAgICAgIGZvcmNlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlbW90ZU1vZHVsZUFuZE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBsb2FkUmVtb3RlQXJncztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlUmVxdWVzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgZnJvbTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZTogJ2JlZm9yZVJlcXVlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbG9hZFJlbW90ZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkOiBpZFJlcyB9ID0gbG9hZFJlbW90ZUFyZ3M7XG4gICAgICAgIGNvbnN0IHJlbW90ZVNwbGl0SW5mbyA9IG1hdGNoUmVtb3RlV2l0aE5hbWVBbmRFeHBvc2UoaG9zdC5vcHRpb25zLnJlbW90ZXMsIGlkUmVzKTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZVNwbGl0SW5mbywgYFxuICAgICAgICBVbmFibGUgdG8gbG9jYXRlICR7aWRSZXN9IGluICR7aG9zdC5vcHRpb25zLm5hbWV9LiBQb3RlbnRpYWwgcmVhc29ucyBmb3IgZmFpbHVyZSBpbmNsdWRlOlxcblxuICAgICAgICAxLiAke2lkUmVzfSB3YXMgbm90IGluY2x1ZGVkIGluIHRoZSAncmVtb3RlcycgcGFyYW1ldGVyIG9mICR7aG9zdC5vcHRpb25zLm5hbWUgfHwgJ3RoZSBob3N0J30uXFxuXG4gICAgICAgIDIuICR7aWRSZXN9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiB0aGUgJ3JlbW90ZXMnIG9mICR7aG9zdC5vcHRpb25zLm5hbWV9IHdpdGggZWl0aGVyICduYW1lJyBvciAnYWxpYXMnIGF0dHJpYnV0ZXMuXG4gICAgICAgIDMuICR7aWRSZXN9IGlzIG5vdCBvbmxpbmUsIGluamVjdGVkLCBvciBsb2FkZWQuXG4gICAgICAgIDQuICR7aWRSZXN9ICBjYW5ub3QgYmUgYWNjZXNzZWQgb24gdGhlIGV4cGVjdGVkLlxuICAgICAgICA1LiBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIHByb3ZpZGVkIGJ1dCBkaWQgbm90IHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlSW5mbycgd2hlbiBhdHRlbXB0aW5nIHRvIGxvYWQgJHtpZFJlc30uXG4gICAgICBgKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGU6IHJhd1JlbW90ZSB9ID0gcmVtb3RlU3BsaXRJbmZvO1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyhyYXdSZW1vdGUpO1xuICAgICAgICBjb25zdCBtYXRjaEluZm8gPSBhd2FpdCBob3N0LnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmFmdGVyUmVzb2x2ZS5lbWl0KF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgaWQ6IGlkUmVzXG4gICAgICAgIH0sIHJlbW90ZVNwbGl0SW5mbywge1xuICAgICAgICAgICAgb3B0aW9uczogaG9zdC5vcHRpb25zLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlLCBleHBvc2UgfSA9IG1hdGNoSW5mbztcbiAgICAgICAgYXNzZXJ0KHJlbW90ZSAmJiBleHBvc2UsIGBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIGV4ZWN1dGVkLCBidXQgaXQgZmFpbGVkIHRvIHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlJyBhbmQgJ2V4cG9zZScgdmFsdWVzIHdoaWxlIGxvYWRpbmcgJHtpZFJlc30uYCk7XG4gICAgICAgIGxldCBtb2R1bGUgPSBob3N0Lm1vZHVsZUNhY2hlLmdldChyZW1vdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgICAgbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVPcHRpb25zKTtcbiAgICAgICAgICAgIGhvc3QubW9kdWxlQ2FjaGUuc2V0KHJlbW90ZS5uYW1lLCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICBtb2R1bGVPcHRpb25zLFxuICAgICAgICAgICAgcmVtb3RlTWF0Y2hJbmZvOiBtYXRjaEluZm9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGUocmVtb3RlLCB0YXJnZXRSZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZVJlbW90ZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAocmVtb3RlLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgaWYgYWxpYXMgZXF1YWxzIHRoZSBwcmVmaXggb2YgcmVtb3RlLm5hbWUgYW5kIHJlbW90ZS5hbGlhcywgaWYgc28sIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQXMgbXVsdGktbGV2ZWwgcGF0aCByZWZlcmVuY2VzIGNhbm5vdCBndWFyYW50ZWUgdW5pcXVlIG5hbWVzLCBhbGlhcyBiZWluZyBhIHByZWZpeCBvZiByZW1vdGUubmFtZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgY29uc3QgZmluZEVxdWFsID0gdGFyZ2V0UmVtb3Rlcy5maW5kKChpdGVtKT0+e1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZW1fYWxpYXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdGUuYWxpYXMgJiYgKGl0ZW0ubmFtZS5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcykgfHwgKChfaXRlbV9hbGlhcyA9IGl0ZW0uYWxpYXMpID09IG51bGwgPyB2b2lkIDAgOiBfaXRlbV9hbGlhcy5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcykpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoIWZpbmRFcXVhbCwgYFRoZSBhbGlhcyAke3JlbW90ZS5hbGlhc30gb2YgcmVtb3RlICR7cmVtb3RlLm5hbWV9IGlzIG5vdCBhbGxvd2VkIHRvIGJlIHRoZSBwcmVmaXggb2YgJHtmaW5kRXF1YWwgJiYgZmluZEVxdWFsLm5hbWV9IG5hbWUgb3IgYWxpYXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVtb3RlIGVudHJ5IHRvIGEgY29tcGxldGUgcGF0aFxuICAgICAgICAgICAgaWYgKCdlbnRyeScgaW4gcmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudiQxKCkgJiYgIXJlbW90ZS5lbnRyeS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLmVudHJ5ID0gbmV3IFVSTChyZW1vdGUuZW50cnksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLmhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZW1vdGUuc2hhcmVTY29wZSkge1xuICAgICAgICAgICAgICAgIHJlbW90ZS5zaGFyZVNjb3BlID0gREVGQVVMVF9TQ09QRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVtb3RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdGUudHlwZSA9IERFRkFVTFRfUkVNT1RFX1RZUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRSZW1vdGUgPSB0YXJnZXRSZW1vdGVzLmZpbmQoKGl0ZW0pPT5pdGVtLm5hbWUgPT09IHJlbW90ZS5uYW1lKTtcbiAgICAgICAgaWYgKCFyZWdpc3RlcmVkUmVtb3RlKSB7XG4gICAgICAgICAgICBub3JtYWxpemVSZW1vdGUoKTtcbiAgICAgICAgICAgIHRhcmdldFJlbW90ZXMucHVzaChyZW1vdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgYFRoZSByZW1vdGUgXCIke3JlbW90ZS5uYW1lfVwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5gLFxuICAgICAgICAgICAgICAgIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlKSA/ICdIb3BlIHlvdSBoYXZlIGtub3duIHRoYXQgT1ZFUlJJREUgaXQgbWF5IGhhdmUgc29tZSB1bmV4cGVjdGVkIGVycm9ycycgOiAnSWYgeW91IHdhbnQgdG8gbWVyZ2UgdGhlIHJlbW90ZSwgeW91IGNhbiBzZXQgXCJmb3JjZTogdHJ1ZVwiLidcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWdpc3RlcmVkIHJlbW90ZVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVtb3RlKHJlZ2lzdGVyZWRSZW1vdGUpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJlbW90ZSgpO1xuICAgICAgICAgICAgICAgIHRhcmdldFJlbW90ZXMucHVzaChyZW1vdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FybiQxKG1lc3NhZ2VzLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlUmVtb3RlKHJlbW90ZSkge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gcmVtb3RlO1xuICAgICAgICBjb25zdCByZW1vdGVJbmRleCA9IGhvc3Qub3B0aW9ucy5yZW1vdGVzLmZpbmRJbmRleCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChyZW1vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5yZW1vdGVzLnNwbGljZShyZW1vdGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGVkTW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlLm5hbWUpO1xuICAgICAgICBpZiAobG9hZGVkTW9kdWxlKSB7XG4gICAgICAgICAgICB2YXIgX09iamVjdF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gbG9hZGVkTW9kdWxlLnJlbW90ZUluZm87XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZW1vdGVJbmZvLmVudHJ5R2xvYmFsTmFtZTtcbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzW2tleV0gJiYgKChfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9PYmplY3RfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsVGhpc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtb3RlRW50cnlVbmlxdWVLZXkgPSBnZXRSZW1vdGVFbnRyeVVuaXF1ZUtleShsb2FkZWRNb2R1bGUucmVtb3RlSW5mbyk7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsTG9hZGluZ1tyZW1vdGVFbnRyeVVuaXF1ZUtleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsTG9hZGluZ1tyZW1vdGVFbnRyeVVuaXF1ZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxldGUgdW4gbG9hZGVkIHNoYXJlZCBhbmQgaW5zdGFuY2VcbiAgICAgICAgICAgIGxldCByZW1vdGVJbnNJZCA9IHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uID8gY29tcG9zZUtleVdpdGhTZXBhcmF0b3IocmVtb3RlSW5mby5uYW1lLCByZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbikgOiByZW1vdGVJbmZvLm5hbWU7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVJbnNJbmRleCA9IGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfXy5maW5kSW5kZXgoKGlucyk9PntcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlSW5mby5idWlsZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucy5vcHRpb25zLmlkID09PSByZW1vdGVJbnNJZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zLm5hbWUgPT09IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW90ZUluc0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUlucyA9IGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfX1tyZW1vdGVJbnNJbmRleF07XG4gICAgICAgICAgICAgICAgcmVtb3RlSW5zSWQgPSByZW1vdGVJbnMub3B0aW9ucy5pZCB8fCByZW1vdGVJbnNJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTaGFyZVNjb3BlTWFwID0gZ2V0R2xvYmFsU2hhcmVTY29wZSgpO1xuICAgICAgICAgICAgICAgIGxldCBpc0FsbFNoYXJlZE5vdFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lZWREZWxldGVLZXlzID0gW107XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZ2xvYmFsU2hhcmVTY29wZU1hcCkuZm9yRWFjaCgoaW5zdElkKT0+e1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbG9iYWxTaGFyZVNjb3BlTWFwW2luc3RJZF0pLmZvckVhY2goKHNoYXJlU2NvcGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbG9iYWxTaGFyZVNjb3BlTWFwW2luc3RJZF1bc2hhcmVTY29wZV0pLmZvckVhY2goKHNoYXJlTmFtZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbG9iYWxTaGFyZVNjb3BlTWFwW2luc3RJZF1bc2hhcmVTY29wZV1bc2hhcmVOYW1lXSkuZm9yRWFjaCgoc2hhcmVWZXJzaW9uKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWQgPSBnbG9iYWxTaGFyZVNjb3BlTWFwW2luc3RJZF1bc2hhcmVTY29wZV1bc2hhcmVOYW1lXVtzaGFyZVZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLmZyb20gPT09IHJlbW90ZUluZm8ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZC5sb2FkZWQgfHwgc2hhcmVkLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBzaGFyZWQudXNlSW4uZmlsdGVyKCh1c2VkSG9zdE5hbWUpPT51c2VkSG9zdE5hbWUgIT09IHJlbW90ZUluZm8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZC51c2VJbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxTaGFyZWROb3RVc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVWZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVTY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0FsbFNoYXJlZE5vdFVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5zLnNoYXJlU2NvcGVNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbFNoYXJlU2NvcGVNYXBbcmVtb3RlSW5zSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRlS2V5cy5mb3JFYWNoKChbaW5zSWQsIHNoYXJlU2NvcGUsIHNoYXJlTmFtZSwgc2hhcmVWZXJzaW9uXSk9PntcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVfc2hhcmVOYW1lLCBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlLCBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZDtcbiAgICAgICAgICAgICAgICAgICAgKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkID0gZ2xvYmFsU2hhcmVTY29wZU1hcFtpbnNJZF0pID09IG51bGwgPyB0cnVlIDogKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZFtzaGFyZVNjb3BlXSkgPT0gbnVsbCA/IHRydWUgOiAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlW3NoYXJlTmFtZV0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVfc2hhcmVOYW1lW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLnNwbGljZShyZW1vdGVJbnNJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0Lm1vZHVsZUNhY2hlLmRlbGV0ZShyZW1vdGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoaG9zdCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZVJlcXVlc3QnKSxcbiAgICAgICAgICAgIG9uTG9hZDogbmV3IEFzeW5jSG9vaygnb25Mb2FkJyksXG4gICAgICAgICAgICBoYW5kbGVQcmVsb2FkTW9kdWxlOiBuZXcgU3luY0hvb2soJ2hhbmRsZVByZWxvYWRNb2R1bGUnKSxcbiAgICAgICAgICAgIGVycm9yTG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygnZXJyb3JMb2FkUmVtb3RlJyksXG4gICAgICAgICAgICBiZWZvcmVQcmVsb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKCdiZWZvcmVQcmVsb2FkUmVtb3RlJyksXG4gICAgICAgICAgICBnZW5lcmF0ZVByZWxvYWRBc3NldHM6IG5ldyBBc3luY0hvb2soJ2dlbmVyYXRlUHJlbG9hZEFzc2V0cycpLFxuICAgICAgICAgICAgLy8gbm90IHVzZWQgeWV0XG4gICAgICAgICAgICBhZnRlclByZWxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jbGFzcyBGZWRlcmF0aW9uSG9zdCB7XG4gICAgaW5pdE9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnModXNlck9wdGlvbnMucGx1Z2lucyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmZvcm1hdE9wdGlvbnModGhpcy5vcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBsb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZFNoYXJlKHBrZ05hbWUsIGV4dHJhT3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRoZSBsaWIgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgc2hhcmVkIHNldCBieSBlYWdlciBvciBydW50aW1lIGluaXQgaXMgc2V0IG9yIHRoZSBzaGFyZWQgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAvLyAxLiBJZiB0aGUgbG9hZGVkIHNoYXJlZCBhbHJlYWR5IGV4aXN0cyBnbG9iYWxseSwgdGhlbiBpdCB3aWxsIGJlIHJldXNlZFxuICAgIC8vIDIuIElmIGxpYiBleGlzdHMgaW4gbG9jYWwgc2hhcmVkLCBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICAvLyAzLiBJZiB0aGUgbG9jYWwgZ2V0IHJldHVybnMgc29tZXRoaW5nIG90aGVyIHRoYW4gUHJvbWlzZSwgdGhlbiBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBsb2FkU2hhcmVTeW5jKHBrZ05hbWUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWRIYW5kbGVyLmxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUgPSBERUZBVUxUX1NDT1BFLCBzdHJhdGVneSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWRIYW5kbGVyLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGVOYW1lLCBzdHJhdGVneSk7XG4gICAgfVxuICAgIGluaXRSYXdDb250YWluZXIobmFtZSwgdXJsLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8oe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVudHJ5OiB1cmxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBNb2R1bGUoe1xuICAgICAgICAgICAgaG9zdDogdGhpcyxcbiAgICAgICAgICAgIHJlbW90ZUluZm9cbiAgICAgICAgfSk7XG4gICAgICAgIG1vZHVsZS5yZW1vdGVFbnRyeUV4cG9ydHMgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMubW9kdWxlQ2FjaGUuc2V0KG5hbWUsIG1vZHVsZSk7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICBhc3luYyBsb2FkUmVtb3RlKGlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUhhbmRsZXIubG9hZFJlbW90ZShpZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgcHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVIYW5kbGVyLnByZWxvYWRSZW1vdGUocHJlbG9hZE9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0U2hhcmVTY29wZU1hcChzY29wZU5hbWUsIHNoYXJlU2NvcGUpIHtcbiAgICAgICAgdGhpcy5zaGFyZWRIYW5kbGVyLmluaXRTaGFyZVNjb3BlTWFwKHNjb3BlTmFtZSwgc2hhcmVTY29wZSk7XG4gICAgfVxuICAgIGZvcm1hdE9wdGlvbnMoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzaGFyZWQgfSA9IGZvcm1hdFNoYXJlQ29uZmlncyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgdXNlck9wdGlvbnM6IHVzZXJPcHRpb25zUmVzLCBvcHRpb25zOiBnbG9iYWxPcHRpb25zUmVzIH0gPSB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVJbml0LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLFxuICAgICAgICAgICAgdXNlck9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiBnbG9iYWxPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvOiBzaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlbW90ZXMgPSB0aGlzLnJlbW90ZUhhbmRsZXIuZm9ybWF0QW5kUmVnaXN0ZXJSZW1vdGUoZ2xvYmFsT3B0aW9uc1JlcywgdXNlck9wdGlvbnNSZXMpO1xuICAgICAgICBjb25zdCB7IHNoYXJlZDogaGFuZGxlZFNoYXJlZCB9ID0gdGhpcy5zaGFyZWRIYW5kbGVyLnJlZ2lzdGVyU2hhcmVkKGdsb2JhbE9wdGlvbnNSZXMsIHVzZXJPcHRpb25zUmVzKTtcbiAgICAgICAgY29uc3QgcGx1Z2lucyA9IFtcbiAgICAgICAgICAgIC4uLmdsb2JhbE9wdGlvbnNSZXMucGx1Z2luc1xuICAgICAgICBdO1xuICAgICAgICBpZiAodXNlck9wdGlvbnNSZXMucGx1Z2lucykge1xuICAgICAgICAgICAgdXNlck9wdGlvbnNSZXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgICAgICAgICAgaWYgKCFwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9uc1JlcyA9IF9leHRlbmRzKHt9LCBnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucywge1xuICAgICAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgICAgIHJlbW90ZXMsXG4gICAgICAgICAgICBzaGFyZWQ6IGhhbmRsZWRTaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLmluaXQuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zUmVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9uc1JlcztcbiAgICB9XG4gICAgcmVnaXN0ZXJQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luUmVzID0gcmVnaXN0ZXJQbHVnaW5zJDEocGx1Z2lucywgW1xuICAgICAgICAgICAgdGhpcy5ob29rcyxcbiAgICAgICAgICAgIHRoaXMucmVtb3RlSGFuZGxlci5ob29rcyxcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkSGFuZGxlci5ob29rcyxcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3RIYW5kbGVyLmhvb2tzLFxuICAgICAgICAgICAgdGhpcy5sb2FkZXJIb29rXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBNZXJnZSBwbHVnaW5cbiAgICAgICAgdGhpcy5vcHRpb25zLnBsdWdpbnMgPSB0aGlzLm9wdGlvbnMucGx1Z2lucy5yZWR1Y2UoKHJlcywgcGx1Z2luKT0+e1xuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHJldHVybiByZXM7XG4gICAgICAgICAgICBpZiAocmVzICYmICFyZXMuZmluZCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gcGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHBsdWdpblJlcyB8fCBbXSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUhhbmRsZXIucmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih1c2VyT3B0aW9ucyl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZUluaXQ6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlSW5pdCcpLFxuICAgICAgICAgICAgaW5pdDogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBiZWZvcmVJbml0Q29udGFpbmVyOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVJbml0Q29udGFpbmVyJyksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBpbml0Q29udGFpbmVyOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdpbml0Q29udGFpbmVyJylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMC4xLjE4XCI7XG4gICAgICAgIHRoaXMubW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVySG9vayA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgLy8gRklYTUU6IG1heSBub3QgYmUgc3VpdGFibGUgLCBub3Qgb3BlbiB0byB0aGUgcHVibGljIHlldFxuICAgICAgICAgICAgZ2V0TW9kdWxlSW5mbzogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgICAgICAgY3JlYXRlTGluazogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICAvLyBvbmx5IHdvcmsgZm9yIG1hbmlmZXN0ICwgc28gbm90IG9wZW4gdG8gdGhlIHB1YmxpYyB5ZXRcbiAgICAgICAgICAgIGZldGNoOiBuZXcgQXN5bmNIb29rKCdmZXRjaCcpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGUgZGV0YWlscyBvZiB0aGUgb3B0aW9uc1xuICAgICAgICAvLyBJbml0aWFsaXplIG9wdGlvbnMgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRCdWlsZGVySWQoKSxcbiAgICAgICAgICAgIG5hbWU6IHVzZXJPcHRpb25zLm5hbWUsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgc25hcHNob3RQbHVnaW4oKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVByZWxvYWRBc3NldHNQbHVnaW4oKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW90ZXM6IFtdLFxuICAgICAgICAgICAgc2hhcmVkOiB7fSxcbiAgICAgICAgICAgIGluQnJvd3NlcjogaXNCcm93c2VyRW52KClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdXNlck9wdGlvbnMubmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIHRoaXMuc25hcHNob3RIYW5kbGVyID0gbmV3IFNuYXBzaG90SGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zaGFyZWRIYW5kbGVyID0gbmV3IFNoYXJlZEhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3RlSGFuZGxlciA9IG5ldyBSZW1vdGVIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXAgPSB0aGlzLnNoYXJlZEhhbmRsZXIuc2hhcmVTY29wZU1hcDtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnMoW1xuICAgICAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMucGx1Z2lucyxcbiAgICAgICAgICAgIC4uLnVzZXJPcHRpb25zLnBsdWdpbnMgfHwgW11cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgIH1cbn1cblxubGV0IEZlZGVyYXRpb25JbnN0YW5jZSA9IG51bGw7XG5mdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgc2FtZSBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShvcHRpb25zLm5hbWUsIG9wdGlvbnMudmVyc2lvbik7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAvLyBSZXRyaWV2ZSBkZWJ1ZyBjb25zdHJ1Y3RvclxuICAgICAgICBjb25zdCBGZWRlcmF0aW9uQ29uc3RydWN0b3IgPSBnZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoKSB8fCBGZWRlcmF0aW9uSG9zdDtcbiAgICAgICAgRmVkZXJhdGlvbkluc3RhbmNlID0gbmV3IEZlZGVyYXRpb25Db25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgc2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlKEZlZGVyYXRpb25JbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2Ugb3B0aW9uc1xuICAgICAgICBpbnN0YW5jZS5pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKCFGZWRlcmF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIEZlZGVyYXRpb25JbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb2FkUmVtb3RlKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIGNvbnN0IGxvYWRSZW1vdGUxID0gRmVkZXJhdGlvbkluc3RhbmNlLmxvYWRSZW1vdGU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gbG9hZFJlbW90ZTEuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIGxvYWRTaGFyZSguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIGNvbnN0IGxvYWRTaGFyZTEgPSBGZWRlcmF0aW9uSW5zdGFuY2UubG9hZFNoYXJlO1xuICAgIHJldHVybiBsb2FkU2hhcmUxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBsb2FkU2hhcmVTeW5jKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIGNvbnN0IGxvYWRTaGFyZVN5bmMxID0gRmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZVN5bmM7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gbG9hZFNoYXJlU3luYzEuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIHByZWxvYWRSZW1vdGUoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlLnByZWxvYWRSZW1vdGUuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVtb3RlcyguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2UucmVnaXN0ZXJSZW1vdGVzLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbnMoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlLnJlZ2lzdGVyUGx1Z2lucy5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuLy8gSW5qZWN0IGZvciBkZWJ1Z1xuc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKEZlZGVyYXRpb25Ib3N0KTtcblxuZXhwb3J0IHsgRmVkZXJhdGlvbkhvc3QsIGdldFJlbW90ZUVudHJ5LCBnZXRSZW1vdGVJbmZvLCBpbml0LCBsb2FkUmVtb3RlLCBsb2FkU2hhcmUsIGxvYWRTaGFyZVN5bmMsIHByZWxvYWRSZW1vdGUsIHJlZ2lzdGVyUGx1Z2lucywgcmVnaXN0ZXJSZW1vdGVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/share.esm.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/share.esm.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ addUniqueItem),\n/* harmony export */   B: () => (/* binding */ getBuilderId),\n/* harmony export */   C: () => (/* binding */ setGlobalFederationConstructor),\n/* harmony export */   D: () => (/* binding */ DEFAULT_REMOTE_TYPE),\n/* harmony export */   E: () => (/* binding */ getGlobalFederationInstance),\n/* harmony export */   F: () => (/* binding */ getGlobalFederationConstructor),\n/* harmony export */   G: () => (/* binding */ Global),\n/* harmony export */   H: () => (/* binding */ setGlobalFederationInstance),\n/* harmony export */   I: () => (/* binding */ registerGlobalPlugins),\n/* harmony export */   J: () => (/* binding */ nativeGlobal),\n/* harmony export */   K: () => (/* binding */ resetFederationGlobalInfo),\n/* harmony export */   L: () => (/* binding */ getTargetSnapshotInfoByModuleInfo),\n/* harmony export */   a: () => (/* binding */ globalLoading),\n/* harmony export */   b: () => (/* binding */ DEFAULT_SCOPE),\n/* harmony export */   c: () => (/* binding */ getRemoteEntryExports),\n/* harmony export */   d: () => (/* binding */ assert),\n/* harmony export */   e: () => (/* binding */ getFMId),\n/* harmony export */   f: () => (/* binding */ error),\n/* harmony export */   g: () => (/* binding */ getGlobalHostPlugins),\n/* harmony export */   h: () => (/* binding */ isPlainObject),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ isRemoteInfoWithEntry),\n/* harmony export */   k: () => (/* binding */ isPureRemoteEntry),\n/* harmony export */   l: () => (/* binding */ isBrowserEnv),\n/* harmony export */   m: () => (/* binding */ getInfoWithoutType),\n/* harmony export */   n: () => (/* binding */ getPreloaded),\n/* harmony export */   o: () => (/* binding */ setPreloaded),\n/* harmony export */   p: () => (/* binding */ getRegisteredShare),\n/* harmony export */   q: () => (/* binding */ arrayOptions),\n/* harmony export */   r: () => (/* binding */ getGlobalSnapshotInfoByModuleInfo),\n/* harmony export */   s: () => (/* binding */ safeToString),\n/* harmony export */   t: () => (/* binding */ addGlobalSnapshot),\n/* harmony export */   u: () => (/* binding */ setGlobalSnapshotInfoByModuleInfo),\n/* harmony export */   v: () => (/* binding */ getGlobalSnapshot),\n/* harmony export */   w: () => (/* binding */ warn),\n/* harmony export */   x: () => (/* binding */ formatShareConfigs),\n/* harmony export */   y: () => (/* binding */ getTargetSharedOptions),\n/* harmony export */   z: () => (/* binding */ getGlobalShareScope)\n/* harmony export */ });\nfunction getBuilderId() {\n    //@ts-ignore\n    return  true ? \"client1:0.1.0\" : 0;\n}\nfunction isDebugMode() {\n    return Boolean(\"\");\n}\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction assert(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n}\nfunction error(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        throw msg;\n    }\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n}\nfunction warn(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        console.warn(msg);\n    } else {\n        console.warn(`${LOG_CATEGORY}: ${msg}`);\n    }\n}\n\nfunction addUniqueItem(arr, item) {\n    if (arr.findIndex((name)=>name === item) === -1) {\n        arr.push(item);\n    }\n    return arr;\n}\nfunction getFMId(remoteInfo) {\n    if ('version' in remoteInfo && remoteInfo.version) {\n        return `${remoteInfo.name}:${remoteInfo.version}`;\n    } else if ('entry' in remoteInfo && remoteInfo.entry) {\n        return `${remoteInfo.name}:${remoteInfo.entry}`;\n    } else {\n        return `${remoteInfo.name}`;\n    }\n}\nfunction isRemoteInfoWithEntry(remote) {\n    return typeof remote.entry !== 'undefined';\n}\nfunction isPureRemoteEntry(remote) {\n    return !remote.entry.includes('.json') && remote.entry.includes('.js');\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nfunction isObject(val) {\n    return val && typeof val === 'object';\n}\nconst objectToString = Object.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isPlainObject(val) {\n    return objectToString.call(val) === '[object Object]';\n}\nfunction arrayOptions(options) {\n    return Array.isArray(options) ? options : [\n        options\n    ];\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst nativeGlobal = (()=>{\n    try {\n        return new Function('return this')();\n    } catch (e) {\n        return globalThis;\n    }\n})();\nconst Global = nativeGlobal;\nfunction definePropertyGlobalVal(target, key, val) {\n    Object.defineProperty(target, key, {\n        value: val,\n        configurable: false,\n        writable: true\n    });\n}\nfunction includeOwnProperty(target, key) {\n    return Object.hasOwnProperty.call(target, key);\n}\n// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.\n// The sandbox in the microfrontend does not replicate the value of 'configurable'.\n// If there is no loading content on the global object, this section defines the loading object.\nif (!includeOwnProperty(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {\n    definePropertyGlobalVal(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});\n}\nconst globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;\nfunction setGlobalDefaultVal(target) {\n    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;\n    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);\n    }\n    if (!includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', {\n            __GLOBAL_PLUGIN__: [],\n            __INSTANCES__: [],\n            moduleInfo: {},\n            __SHARE__: {},\n            __MANIFEST_LOADING__: {},\n            __PRELOADED_MAP__: new Map()\n        });\n        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);\n    }\n    var ___GLOBAL_PLUGIN__;\n    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    var ___INSTANCES__;\n    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];\n    var _moduleInfo;\n    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};\n    var ___SHARE__;\n    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};\n    var ___MANIFEST_LOADING__;\n    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};\n    var ___PRELOADED_MAP__;\n    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();\n}\nsetGlobalDefaultVal(globalThis);\nsetGlobalDefaultVal(nativeGlobal);\nfunction resetFederationGlobalInfo() {\n    globalThis.__FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    globalThis.__FEDERATION__.__INSTANCES__ = [];\n    globalThis.__FEDERATION__.moduleInfo = {};\n    globalThis.__FEDERATION__.__SHARE__ = {};\n    globalThis.__FEDERATION__.__MANIFEST_LOADING__ = {};\n}\nfunction getGlobalFederationInstance(name, version) {\n    const buildId = getBuilderId();\n    return globalThis.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{\n        if (buildId && GMInstance.options.id === getBuilderId()) {\n            return true;\n        }\n        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {\n            return true;\n        }\n        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {\n            return true;\n        }\n        return false;\n    });\n}\nfunction setGlobalFederationInstance(FederationInstance) {\n    globalThis.__FEDERATION__.__INSTANCES__.push(FederationInstance);\n}\nfunction getGlobalFederationConstructor() {\n    return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;\n}\nfunction setGlobalFederationConstructor(FederationConstructor, isDebug = isDebugMode()) {\n    if (isDebug) {\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = \"0.1.18\";\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getInfoWithoutType(target, key) {\n    if (typeof key === 'string') {\n        const keyRes = target[key];\n        if (keyRes) {\n            return {\n                value: target[key],\n                key: key\n            };\n        } else {\n            const targetKeys = Object.keys(target);\n            for (const targetKey of targetKeys){\n                const [targetTypeOrName, _] = targetKey.split(':');\n                const nKey = `${targetTypeOrName}:${key}`;\n                const typeWithKeyRes = target[nKey];\n                if (typeWithKeyRes) {\n                    return {\n                        value: typeWithKeyRes,\n                        key: nKey\n                    };\n                }\n            }\n            return {\n                value: undefined,\n                key: key\n            };\n        }\n    } else {\n        throw new Error('key must be string');\n    }\n}\nconst getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;\nconst getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{\n    // Check if the remote is included in the hostSnapshot\n    const moduleKey = getFMId(moduleInfo);\n    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;\n    // The remoteSnapshot might not include a version\n    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {\n        getModuleInfo.version = moduleInfo['version'];\n    }\n    if (getModuleInfo) {\n        return getModuleInfo;\n    }\n    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot\n    if ('version' in moduleInfo && moduleInfo['version']) {\n        const { version } = moduleInfo, resModuleInfo = _object_without_properties_loose(moduleInfo, [\n            \"version\"\n        ]);\n        const moduleKeyWithoutVersion = getFMId(resModuleInfo);\n        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;\n        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {\n            return getModuleInfoWithoutVersion;\n        }\n    }\n    return;\n};\nconst getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);\nconst setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{\n    const moduleKey = getFMId(remoteInfo);\n    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;\n    return nativeGlobal.__FEDERATION__.moduleInfo;\n};\nconst addGlobalSnapshot = (moduleInfos)=>{\n    nativeGlobal.__FEDERATION__.moduleInfo = _extends$1({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);\n    return ()=>{\n        const keys = Object.keys(moduleInfos);\n        for (const key of keys){\n            delete nativeGlobal.__FEDERATION__.moduleInfo[key];\n        }\n    };\n};\nconst getRemoteEntryExports = (name, globalName)=>{\n    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;\n    const entryExports = globalThis[remoteEntryKey];\n    return {\n        remoteEntryKey,\n        entryExports\n    };\n};\n// This function is used to register global plugins.\n// It iterates over the provided plugins and checks if they are already registered.\n// If a plugin is not registered, it is added to the global plugins.\n// If a plugin is already registered, a warning message is logged.\nconst registerGlobalPlugins = (plugins)=>{\n    const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;\n    plugins.forEach((plugin)=>{\n        if (__GLOBAL_PLUGIN__.findIndex((p)=>p.name === plugin.name) === -1) {\n            __GLOBAL_PLUGIN__.push(plugin);\n        } else {\n            warn(`The plugin ${plugin.name} has been registered.`);\n        }\n    });\n};\nconst getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;\nconst getPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.get(id);\nconst setPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.set(id, true);\n\nconst DEFAULT_SCOPE = 'default';\nconst DEFAULT_REMOTE_TYPE = 'global';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nconst buildIdentifier = '[0-9A-Za-z-]+';\nconst build = `(?:\\\\+(${buildIdentifier}(?:\\\\.${buildIdentifier})*))`;\nconst numericIdentifier = '0|[1-9]\\\\d*';\nconst numericIdentifierLoose = '[0-9]+';\nconst nonNumericIdentifier = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\nconst preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;\nconst preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\\\.${preReleaseIdentifierLoose})*))`;\nconst preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;\nconst preRelease = `(?:-(${preReleaseIdentifier}(?:\\\\.${preReleaseIdentifier})*))`;\nconst xRangeIdentifier = `${numericIdentifier}|x|X|\\\\*`;\nconst xRangePlain = `[v=\\\\s]*(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;\nconst hyphenRange = `^\\\\s*(${xRangePlain})\\\\s+-\\\\s+(${xRangePlain})\\\\s*$`;\nconst mainVersionLoose = `(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})`;\nconst loosePlain = `[v=\\\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;\nconst gtlt = '((?:<|>)?=?)';\nconst comparatorTrim = `(\\\\s*)${gtlt}\\\\s*(${loosePlain}|${xRangePlain})`;\nconst loneTilde = '(?:~>?)';\nconst tildeTrim = `(\\\\s*)${loneTilde}\\\\s+`;\nconst loneCaret = '(?:\\\\^)';\nconst caretTrim = `(\\\\s*)${loneCaret}\\\\s+`;\nconst star = '(<|>)?=?\\\\s*\\\\*';\nconst caret = `^${loneCaret}${xRangePlain}$`;\nconst mainVersion = `(${numericIdentifier})\\\\.(${numericIdentifier})\\\\.(${numericIdentifier})`;\nconst fullPlain = `v?${mainVersion}${preRelease}?${build}?`;\nconst tilde = `^${loneTilde}${xRangePlain}$`;\nconst xRange = `^${gtlt}\\\\s*${xRangePlain}$`;\nconst comparator = `^${gtlt}\\\\s*(${fullPlain})$|^$`;\n// copy from semver package\nconst gte0 = '^\\\\s*>=\\\\s*0.0.0\\\\s*$';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseRegex(source) {\n    return new RegExp(source);\n}\nfunction isXVersion(version) {\n    return !version || version.toLowerCase() === 'x' || version === '*';\n}\nfunction pipe(...fns) {\n    return (x)=>fns.reduce((v, f)=>f(v), x);\n}\nfunction extractComparator(comparatorString) {\n    return comparatorString.match(parseRegex(comparator));\n}\nfunction combineVersion(major, minor, patch, preRelease) {\n    const mainVersion = `${major}.${minor}.${patch}`;\n    if (preRelease) {\n        return `${mainVersion}-${preRelease}`;\n    }\n    return mainVersion;\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseHyphen(range) {\n    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{\n        if (isXVersion(fromMajor)) {\n            from = '';\n        } else if (isXVersion(fromMinor)) {\n            from = `>=${fromMajor}.0.0`;\n        } else if (isXVersion(fromPatch)) {\n            from = `>=${fromMajor}.${fromMinor}.0`;\n        } else {\n            from = `>=${from}`;\n        }\n        if (isXVersion(toMajor)) {\n            to = '';\n        } else if (isXVersion(toMinor)) {\n            to = `<${Number(toMajor) + 1}.0.0-0`;\n        } else if (isXVersion(toPatch)) {\n            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;\n        } else if (toPreRelease) {\n            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;\n        } else {\n            to = `<=${to}`;\n        }\n        return `${from} ${to}`.trim();\n    });\n}\nfunction parseComparatorTrim(range) {\n    return range.replace(parseRegex(comparatorTrim), '$1$2$3');\n}\nfunction parseTildeTrim(range) {\n    return range.replace(parseRegex(tildeTrim), '$1~');\n}\nfunction parseCaretTrim(range) {\n    return range.replace(parseRegex(caretTrim), '$1^');\n}\nfunction parseCarets(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                if (major === '0') {\n                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n                } else {\n                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;\n                }\n            } else if (preRelease) {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                } else {\n                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;\n                }\n            } else {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                }\n                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;\n            }\n        })).join(' ');\n}\nfunction parseTildes(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n            } else if (preRelease) {\n                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n        })).join(' ');\n}\nfunction parseXRanges(range) {\n    return range.split(/\\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{\n            const isXMajor = isXVersion(major);\n            const isXMinor = isXMajor || isXVersion(minor);\n            const isXPatch = isXMinor || isXVersion(patch);\n            if (gtlt === '=' && isXPatch) {\n                gtlt = '';\n            }\n            preRelease = '';\n            if (isXMajor) {\n                if (gtlt === '>' || gtlt === '<') {\n                    // nothing is allowed\n                    return '<0.0.0-0';\n                } else {\n                    // nothing is forbidden\n                    return '*';\n                }\n            } else if (gtlt && isXPatch) {\n                // replace X with 0\n                if (isXMinor) {\n                    minor = 0;\n                }\n                patch = 0;\n                if (gtlt === '>') {\n                    // >1 => >=2.0.0\n                    // >1.2 => >=1.3.0\n                    gtlt = '>=';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                        minor = 0;\n                        patch = 0;\n                    } else {\n                        minor = Number(minor) + 1;\n                        patch = 0;\n                    }\n                } else if (gtlt === '<=') {\n                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass\n                    // Similarly, <=7.x is actually <8.0.0, etc.\n                    gtlt = '<';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                    } else {\n                        minor = Number(minor) + 1;\n                    }\n                }\n                if (gtlt === '<') {\n                    preRelease = '-0';\n                }\n                return `${gtlt + major}.${minor}.${patch}${preRelease}`;\n            } else if (isXMinor) {\n                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;\n            } else if (isXPatch) {\n                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return ret;\n        })).join(' ');\n}\nfunction parseStar(range) {\n    return range.trim().replace(parseRegex(star), '');\n}\nfunction parseGTE0(comparatorString) {\n    return comparatorString.trim().replace(parseRegex(gte0), '');\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction compareAtom(rangeAtom, versionAtom) {\n    rangeAtom = Number(rangeAtom) || rangeAtom;\n    versionAtom = Number(versionAtom) || versionAtom;\n    if (rangeAtom > versionAtom) {\n        return 1;\n    }\n    if (rangeAtom === versionAtom) {\n        return 0;\n    }\n    return -1;\n}\nfunction comparePreRelease(rangeAtom, versionAtom) {\n    const { preRelease: rangePreRelease } = rangeAtom;\n    const { preRelease: versionPreRelease } = versionAtom;\n    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {\n        return 1;\n    }\n    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {\n        return -1;\n    }\n    if (rangePreRelease === undefined && versionPreRelease === undefined) {\n        return 0;\n    }\n    for(let i = 0, n = rangePreRelease.length; i <= n; i++){\n        const rangeElement = rangePreRelease[i];\n        const versionElement = versionPreRelease[i];\n        if (rangeElement === versionElement) {\n            continue;\n        }\n        if (rangeElement === undefined && versionElement === undefined) {\n            return 0;\n        }\n        if (!rangeElement) {\n            return 1;\n        }\n        if (!versionElement) {\n            return -1;\n        }\n        return compareAtom(rangeElement, versionElement);\n    }\n    return 0;\n}\nfunction compareVersion(rangeAtom, versionAtom) {\n    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);\n}\nfunction eq(rangeAtom, versionAtom) {\n    return rangeAtom.version === versionAtom.version;\n}\nfunction compare(rangeAtom, versionAtom) {\n    switch(rangeAtom.operator){\n        case '':\n        case '=':\n            return eq(rangeAtom, versionAtom);\n        case '>':\n            return compareVersion(rangeAtom, versionAtom) < 0;\n        case '>=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;\n        case '<':\n            return compareVersion(rangeAtom, versionAtom) > 0;\n        case '<=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;\n        case undefined:\n            {\n                // mean * or x -> all versions\n                return true;\n            }\n        default:\n            return false;\n    }\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseComparatorString(range) {\n    return pipe(// handle caret\n    // ^ --> * (any, kinda silly)\n    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n    // ^1.2.3 --> >=1.2.3 <2.0.0-0\n    // ^1.2.0 --> >=1.2.0 <2.0.0-0\n    parseCarets, // handle tilde\n    // ~, ~> --> * (any, kinda silly)\n    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n    parseTildes, parseXRanges, parseStar)(range);\n}\nfunction parseRange(range) {\n    return pipe(// handle hyphenRange\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    parseHyphen, // handle trim comparator\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    parseComparatorTrim, // handle trim tilde\n    // `~ 1.2.3` => `~1.2.3`\n    parseTildeTrim, // handle trim caret\n    // `^ 1.2.3` => `^1.2.3`\n    parseCaretTrim)(range.trim()).split(/\\s+/).join(' ');\n}\nfunction satisfy(version, range) {\n    if (!version) {\n        return false;\n    }\n    const parsedRange = parseRange(range);\n    const parsedComparator = parsedRange.split(' ').map((rangeVersion)=>parseComparatorString(rangeVersion)).join(' ');\n    const comparators = parsedComparator.split(/\\s+/).map((comparator)=>parseGTE0(comparator));\n    const extractedVersion = extractComparator(version);\n    if (!extractedVersion) {\n        return false;\n    }\n    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;\n    const versionAtom = {\n        operator: versionOperator,\n        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),\n        major: versionMajor,\n        minor: versionMinor,\n        patch: versionPatch,\n        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')\n    };\n    for (const comparator of comparators){\n        const extractedComparator = extractComparator(comparator);\n        if (!extractedComparator) {\n            return false;\n        }\n        const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;\n        const rangeAtom = {\n            operator: rangeOperator,\n            version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),\n            major: rangeMajor,\n            minor: rangeMinor,\n            patch: rangePatch,\n            preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')\n        };\n        if (!compare(rangeAtom, versionAtom)) {\n            return false; // early return\n        }\n    }\n    return true;\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction formatShare(shareArgs, from, name) {\n    let get;\n    if ('get' in shareArgs) {\n        // eslint-disable-next-line prefer-destructuring\n        get = shareArgs.get;\n    } else if ('lib' in shareArgs) {\n        get = ()=>Promise.resolve(shareArgs.lib);\n    } else {\n        get = ()=>Promise.resolve(()=>{\n                throw new Error(`Can not get shared '${name}'!`);\n            });\n    }\n    var _shareArgs_version, _shareArgs_scope;\n    return _extends({\n        deps: [],\n        useIn: [],\n        from,\n        loading: null\n    }, shareArgs, {\n        shareConfig: _extends({\n            requiredVersion: `^${shareArgs.version}`,\n            singleton: false,\n            eager: false,\n            strictVersion: false\n        }, shareArgs.shareConfig),\n        get,\n        loaded: 'lib' in shareArgs ? true : undefined,\n        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',\n        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [\n            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'\n        ],\n        strategy: shareArgs.strategy || 'version-first'\n    });\n}\nfunction formatShareConfigs(globalOptions, userOptions) {\n    const shareArgs = userOptions.shared || {};\n    const from = userOptions.name;\n    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{\n        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);\n        res[pkgName] = res[pkgName] || [];\n        arrayShareArgs.forEach((shareConfig)=>{\n            res[pkgName].push(formatShare(shareConfig, from, pkgName));\n        });\n        return res;\n    }, {});\n    const shared = _extends({}, globalOptions.shared);\n    Object.keys(shareInfos).forEach((shareKey)=>{\n        if (!shared[shareKey]) {\n            shared[shareKey] = shareInfos[shareKey];\n        } else {\n            shareInfos[shareKey].forEach((newUserSharedOptions)=>{\n                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);\n                if (!isSameVersion) {\n                    shared[shareKey].push(newUserSharedOptions);\n                }\n            });\n        }\n    });\n    return {\n        shared,\n        shareInfos\n    };\n}\nfunction versionLt(a, b) {\n    const transformInvalidVersion = (version)=>{\n        const isNumberVersion = !Number.isNaN(Number(version));\n        if (isNumberVersion) {\n            const splitArr = version.split('.');\n            let validVersion = version;\n            for(let i = 0; i < 3 - splitArr.length; i++){\n                validVersion += '.0';\n            }\n            return validVersion;\n        }\n        return version;\n    };\n    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {\n        return true;\n    } else {\n        return false;\n    }\n}\nconst findVersion = (shareVersionMap, cb)=>{\n    const callback = cb || function(prev, cur) {\n        return versionLt(prev, cur);\n    };\n    return Object.keys(shareVersionMap).reduce((prev, cur)=>{\n        if (!prev) {\n            return cur;\n        }\n        if (callback(prev, cur)) {\n            return cur;\n        }\n        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136\n        if (prev === '0') {\n            return cur;\n        }\n        return prev;\n    }, 0);\n};\nconst isLoaded = (shared)=>{\n    return Boolean(shared.loaded) || typeof shared.lib === 'function';\n};\nfunction findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        return !isLoaded(versions[prev]) && versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        if (isLoaded(versions[cur])) {\n            if (isLoaded(versions[prev])) {\n                return Boolean(versionLt(prev, cur));\n            } else {\n                return true;\n            }\n        }\n        if (isLoaded(versions[prev])) {\n            return false;\n        }\n        return versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction getFindShareFunction(strategy) {\n    if (strategy === 'loaded-first') {\n        return findSingletonVersionOrderByLoaded;\n    }\n    return findSingletonVersionOrderByVersion;\n}\nfunction getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {\n    if (!localShareScopeMap) {\n        return;\n    }\n    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;\n    const scopes = Array.isArray(scope) ? scope : [\n        scope\n    ];\n    for (const sc of scopes){\n        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {\n            const { requiredVersion } = shareConfig;\n            const findShareFunction = getFindShareFunction(strategy);\n            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);\n            //@ts-ignore\n            const defaultResolver = ()=>{\n                if (shareConfig.singleton) {\n                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;\n                        if (shareConfig.strictVersion) {\n                            error(msg);\n                        } else {\n                            warn(msg);\n                        }\n                    }\n                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                } else {\n                    if (requiredVersion === false || requiredVersion === '*') {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){\n                        if (satisfy(versionKey, requiredVersion)) {\n                            return versionValue;\n                        }\n                    }\n                }\n            };\n            const params = {\n                shareScopeMap: localShareScopeMap,\n                scope: sc,\n                pkgName,\n                version: maxOrSingletonVersion,\n                GlobalFederation: Global.__FEDERATION__,\n                resolver: defaultResolver\n            };\n            const resolveShared = resolveShare.emit(params) || params;\n            return resolveShared.resolver();\n        }\n    }\n}\nfunction getGlobalShareScope() {\n    return Global.__FEDERATION__.__SHARE__;\n}\nfunction getTargetSharedOptions(options) {\n    const { pkgName, extraOptions, shareInfos } = options;\n    const defaultResolver = (sharedOptions)=>{\n        if (!sharedOptions) {\n            return undefined;\n        }\n        const shareVersionMap = {};\n        sharedOptions.forEach((shared)=>{\n            shareVersionMap[shared.version] = shared;\n        });\n        const callback = function(prev, cur) {\n            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);\n        };\n        const maxVersion = findVersion(shareVersionMap, callback);\n        return shareVersionMap[maxVersion];\n    };\n    var _extraOptions_resolver;\n    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;\n    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3J1bnRpbWVAMC4xLjE4L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS9kaXN0L3NoYXJlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxXQUFXLEtBQWtELEdBQUcsZUFBMkIsR0FBRyxDQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLElBQUksWUFBWTtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsSUFBSSxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLElBQUksWUFBWTtBQUN0RDtBQUNBLE1BQU07QUFDTix3QkFBd0IsYUFBYSxJQUFJLElBQUk7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLG1CQUFtQjtBQUN4RCxNQUFNO0FBQ04sa0JBQWtCLGdCQUFnQixHQUFHLGlCQUFpQjtBQUN0RCxNQUFNO0FBQ04sa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQixHQUFHLElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0JBQStCLGFBQWE7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsUUFBUSxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QixHQUFHLHFCQUFxQjtBQUN2RixpQ0FBaUMsMEJBQTBCLFFBQVEsMEJBQTBCO0FBQzdGLG1DQUFtQyxrQkFBa0IsR0FBRyxxQkFBcUI7QUFDN0UsMkJBQTJCLHFCQUFxQixRQUFRLHFCQUFxQjtBQUM3RSw0QkFBNEIsa0JBQWtCO0FBQzlDLGdDQUFnQyxpQkFBaUIsVUFBVSxpQkFBaUIsVUFBVSxpQkFBaUIsTUFBTSxXQUFXLElBQUksTUFBTTtBQUNsSSw2QkFBNkIsWUFBWSxhQUFhLFlBQVk7QUFDbEUsNkJBQTZCLHVCQUF1QixPQUFPLHVCQUF1QixPQUFPLHVCQUF1QjtBQUNoSCw4QkFBOEIsaUJBQWlCLEVBQUUsZ0JBQWdCLEdBQUcsTUFBTTtBQUMxRTtBQUNBLGdDQUFnQyxLQUFLLE9BQU8sV0FBVyxHQUFHLFlBQVk7QUFDdEU7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0Esa0JBQWtCLFVBQVUsRUFBRSxZQUFZO0FBQzFDLHdCQUF3QixrQkFBa0IsT0FBTyxrQkFBa0IsT0FBTyxrQkFBa0I7QUFDNUYsdUJBQXVCLFlBQVksRUFBRSxXQUFXLEdBQUcsTUFBTTtBQUN6RCxrQkFBa0IsVUFBVSxFQUFFLFlBQVk7QUFDMUMsbUJBQW1CLEtBQUssTUFBTSxZQUFZO0FBQzFDLHVCQUF1QixLQUFLLE9BQU8sVUFBVTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQ25EO0FBQ0Esa0JBQWtCLFlBQVksR0FBRyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdCQUF3QixVQUFVO0FBQ2xDLFVBQVU7QUFDVix3QkFBd0IsVUFBVSxHQUFHLFVBQVU7QUFDL0MsVUFBVTtBQUNWLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQkFBcUIsb0JBQW9CO0FBQ3pDLFVBQVU7QUFDVixxQkFBcUIsUUFBUSxHQUFHLG9CQUFvQjtBQUNwRCxVQUFVO0FBQ1Ysc0JBQXNCLFFBQVEsR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLGFBQWE7QUFDcEUsVUFBVTtBQUNWLHNCQUFzQixHQUFHO0FBQ3pCO0FBQ0Esa0JBQWtCLE1BQU0sRUFBRSxHQUFHO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDRCQUE0QixNQUFNLFFBQVEsa0JBQWtCO0FBQzVELGNBQWM7QUFDZDtBQUNBLGdDQUFnQyxNQUFNLEdBQUcsTUFBTSxNQUFNLE1BQU0sR0FBRyxrQkFBa0I7QUFDaEYsa0JBQWtCO0FBQ2xCLGdDQUFnQyxNQUFNLEdBQUcsTUFBTSxNQUFNLGtCQUFrQjtBQUN2RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLFlBQVksR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLGtCQUFrQjtBQUNsSCxzQkFBc0I7QUFDdEIsb0NBQW9DLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLFlBQVksR0FBRyxNQUFNLEdBQUcsa0JBQWtCO0FBQ3pHO0FBQ0Esa0JBQWtCO0FBQ2xCLGdDQUFnQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxZQUFZLEdBQUcsa0JBQWtCO0FBQzVGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxHQUFHLE1BQU0sR0FBRyxPQUFPLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxrQkFBa0I7QUFDcEcsc0JBQXNCO0FBQ3RCLG9DQUFvQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sR0FBRyxNQUFNLEdBQUcsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxHQUFHLE1BQU0sR0FBRyxPQUFPLEdBQUcsa0JBQWtCO0FBQzFFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsNEJBQTRCLE1BQU0sUUFBUSxrQkFBa0I7QUFDNUQsY0FBYztBQUNkLDRCQUE0QixNQUFNLEdBQUcsTUFBTSxNQUFNLE1BQU0sR0FBRyxrQkFBa0I7QUFDNUUsY0FBYztBQUNkLDRCQUE0QixNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxZQUFZLEdBQUcsTUFBTSxHQUFHLGtCQUFrQjtBQUNqRztBQUNBLHdCQUF3QixNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sR0FBRyxNQUFNLEdBQUcsa0JBQWtCO0FBQy9FLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSxHQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUUsV0FBVztBQUN0RSxjQUFjO0FBQ2QsNEJBQTRCLE1BQU0sTUFBTSxZQUFZLEdBQUcsa0JBQWtCO0FBQ3pFLGNBQWM7QUFDZCw0QkFBNEIsTUFBTSxHQUFHLE1BQU0sSUFBSSxZQUFZLEdBQUcsTUFBTSxHQUFHLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQyxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLHVEQUF1RCxLQUFLO0FBQzVELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssSUFBSTtBQUNULDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUIsT0FBTyxzRkFBc0YsNkJBQTZCLFNBQVMsc0NBQXNDLGdCQUFnQixjQUFjLGdCQUFnQjtBQUM3UjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRXM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3J1bnRpbWVAMC4xLjE4L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS9kaXN0L3NoYXJlLmVzbS5qcz8xYjcyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEJ1aWxkZXJJZCgpIHtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXR1cm4gdHlwZW9mIEZFREVSQVRJT05fQlVJTERfSURFTlRJRklFUiAhPT0gJ3VuZGVmaW5lZCcgPyBGRURFUkFUSU9OX0JVSUxEX0lERU5USUZJRVIgOiAnJztcbn1cbmZ1bmN0aW9uIGlzRGVidWdNb2RlKCkge1xuICAgIHJldHVybiBCb29sZWFuKFwiXCIpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuY29uc3QgTE9HX0NBVEVHT1JZID0gJ1sgRmVkZXJhdGlvbiBSdW50aW1lIF0nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1zZy5tZXNzYWdlID0gYCR7TE9HX0NBVEVHT1JZfTogJHttc2cubWVzc2FnZX1gO1xuICAgICAgICB0aHJvdyBtc2c7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1zZy5tZXNzYWdlID0gYCR7TE9HX0NBVEVHT1JZfTogJHttc2cubWVzc2FnZX1gO1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7TE9HX0NBVEVHT1JZfTogJHttc2d9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIuZmluZEluZGV4KChuYW1lKT0+bmFtZSA9PT0gaXRlbSkgPT09IC0xKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gZ2V0Rk1JZChyZW1vdGVJbmZvKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiByZW1vdGVJbmZvICYmIHJlbW90ZUluZm8udmVyc2lvbikge1xuICAgICAgICByZXR1cm4gYCR7cmVtb3RlSW5mby5uYW1lfToke3JlbW90ZUluZm8udmVyc2lvbn1gO1xuICAgIH0gZWxzZSBpZiAoJ2VudHJ5JyBpbiByZW1vdGVJbmZvICYmIHJlbW90ZUluZm8uZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW90ZUluZm8ubmFtZX06JHtyZW1vdGVJbmZvLmVudHJ5fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW90ZUluZm8ubmFtZX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVtb3RlSW5mb1dpdGhFbnRyeShyZW1vdGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHJlbW90ZS5lbnRyeSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1B1cmVSZW1vdGVFbnRyeShyZW1vdGUpIHtcbiAgICByZXR1cm4gIXJlbW90ZS5lbnRyeS5pbmNsdWRlcygnLmpzb24nKSAmJiByZW1vdGUuZW50cnkuaW5jbHVkZXMoJy5qcycpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIGFycmF5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zIDogW1xuICAgICAgICBvcHRpb25zXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkMSgpIHtcbiAgICBfZXh0ZW5kcyQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBuYXRpdmVHbG9iYWwgPSAoKCk9PntcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICB9XG59KSgpO1xuY29uc3QgR2xvYmFsID0gbmF0aXZlR2xvYmFsO1xuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KTtcbn1cbi8vIFRoaXMgc2VjdGlvbiBpcyB0byBwcmV2ZW50IGVuY2Fwc3VsYXRpb24gYnkgY2VydGFpbiBtaWNyb2Zyb250ZW5kIGZyYW1ld29ya3MuIER1ZSB0byByZXVzZSBwb2xpY2llcywgc2FuZGJveCBlc2NhcGVzLlxuLy8gVGhlIHNhbmRib3ggaW4gdGhlIG1pY3JvZnJvbnRlbmQgZG9lcyBub3QgcmVwbGljYXRlIHRoZSB2YWx1ZSBvZiAnY29uZmlndXJhYmxlJy5cbi8vIElmIHRoZXJlIGlzIG5vIGxvYWRpbmcgY29udGVudCBvbiB0aGUgZ2xvYmFsIG9iamVjdCwgdGhpcyBzZWN0aW9uIGRlZmluZXMgdGhlIGxvYWRpbmcgb2JqZWN0LlxuaWYgKCFpbmNsdWRlT3duUHJvcGVydHkoZ2xvYmFsVGhpcywgJ19fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX18nKSkge1xuICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKGdsb2JhbFRoaXMsICdfX0dMT0JBTF9MT0FESU5HX1JFTU9URV9FTlRSWV9fJywge30pO1xufVxuY29uc3QgZ2xvYmFsTG9hZGluZyA9IGdsb2JhbFRoaXMuX19HTE9CQUxfTE9BRElOR19SRU1PVEVfRU5UUllfXztcbmZ1bmN0aW9uIHNldEdsb2JhbERlZmF1bHRWYWwodGFyZ2V0KSB7XG4gICAgdmFyIF90YXJnZXRfX19GRURFUkFUSU9OX18sIF90YXJnZXRfX19GRURFUkFUSU9OX18xLCBfdGFyZ2V0X19fRkVERVJBVElPTl9fMiwgX3RhcmdldF9fX0ZFREVSQVRJT05fXzMsIF90YXJnZXRfX19GRURFUkFUSU9OX180LCBfdGFyZ2V0X19fRkVERVJBVElPTl9fNTtcbiAgICBpZiAoaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwgJ19fVk1PS19fJykgJiYgIWluY2x1ZGVPd25Qcm9wZXJ0eSh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHRhcmdldCwgJ19fRkVERVJBVElPTl9fJywgdGFyZ2V0Ll9fVk1PS19fKTtcbiAgICB9XG4gICAgaWYgKCFpbmNsdWRlT3duUHJvcGVydHkodGFyZ2V0LCAnX19GRURFUkFUSU9OX18nKSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycsIHtcbiAgICAgICAgICAgIF9fR0xPQkFMX1BMVUdJTl9fOiBbXSxcbiAgICAgICAgICAgIF9fSU5TVEFOQ0VTX186IFtdLFxuICAgICAgICAgICAgbW9kdWxlSW5mbzoge30sXG4gICAgICAgICAgICBfX1NIQVJFX186IHt9LFxuICAgICAgICAgICAgX19NQU5JRkVTVF9MT0FESU5HX186IHt9LFxuICAgICAgICAgICAgX19QUkVMT0FERURfTUFQX186IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCAnX19WTU9LX18nLCB0YXJnZXQuX19GRURFUkFUSU9OX18pO1xuICAgIH1cbiAgICB2YXIgX19fR0xPQkFMX1BMVUdJTl9fO1xuICAgIChfX19HTE9CQUxfUExVR0lOX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXyA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19HTE9CQUxfUExVR0lOX18pICE9IG51bGwgPyBfX19HTE9CQUxfUExVR0lOX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fID0gW107XG4gICAgdmFyIF9fX0lOU1RBTkNFU19fO1xuICAgIChfX19JTlNUQU5DRVNfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fMSA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19JTlNUQU5DRVNfXykgIT0gbnVsbCA/IF9fX0lOU1RBTkNFU19fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzEuX19JTlNUQU5DRVNfXyA9IFtdO1xuICAgIHZhciBfbW9kdWxlSW5mbztcbiAgICAoX21vZHVsZUluZm8gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzIgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLm1vZHVsZUluZm8pICE9IG51bGwgPyBfbW9kdWxlSW5mbyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18yLm1vZHVsZUluZm8gPSB7fTtcbiAgICB2YXIgX19fU0hBUkVfXztcbiAgICAoX19fU0hBUkVfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fMyA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19TSEFSRV9fKSAhPSBudWxsID8gX19fU0hBUkVfXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18zLl9fU0hBUkVfXyA9IHt9O1xuICAgIHZhciBfX19NQU5JRkVTVF9MT0FESU5HX187XG4gICAgKF9fX01BTklGRVNUX0xPQURJTkdfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fNCA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19NQU5JRkVTVF9MT0FESU5HX18pICE9IG51bGwgPyBfX19NQU5JRkVTVF9MT0FESU5HX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fNC5fX01BTklGRVNUX0xPQURJTkdfXyA9IHt9O1xuICAgIHZhciBfX19QUkVMT0FERURfTUFQX187XG4gICAgKF9fX1BSRUxPQURFRF9NQVBfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fNSA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19QUkVMT0FERURfTUFQX18pICE9IG51bGwgPyBfX19QUkVMT0FERURfTUFQX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fNS5fX1BSRUxPQURFRF9NQVBfXyA9IG5ldyBNYXAoKTtcbn1cbnNldEdsb2JhbERlZmF1bHRWYWwoZ2xvYmFsVGhpcyk7XG5zZXRHbG9iYWxEZWZhdWx0VmFsKG5hdGl2ZUdsb2JhbCk7XG5mdW5jdGlvbiByZXNldEZlZGVyYXRpb25HbG9iYWxJbmZvKCkge1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19HTE9CQUxfUExVR0lOX18gPSBbXTtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18gPSBbXTtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8gPSB7fTtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fU0hBUkVfXyA9IHt9O1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX18gPSB7fTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShuYW1lLCB2ZXJzaW9uKSB7XG4gICAgY29uc3QgYnVpbGRJZCA9IGdldEJ1aWxkZXJJZCgpO1xuICAgIHJldHVybiBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uZmluZCgoR01JbnN0YW5jZSk9PntcbiAgICAgICAgaWYgKGJ1aWxkSWQgJiYgR01JbnN0YW5jZS5vcHRpb25zLmlkID09PSBnZXRCdWlsZGVySWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdNSW5zdGFuY2Uub3B0aW9ucy5uYW1lID09PSBuYW1lICYmICFHTUluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiAmJiAhdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdNSW5zdGFuY2Uub3B0aW9ucy5uYW1lID09PSBuYW1lICYmIHZlcnNpb24gJiYgR01JbnN0YW5jZS5vcHRpb25zLnZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShGZWRlcmF0aW9uSW5zdGFuY2UpIHtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18ucHVzaChGZWRlcmF0aW9uSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fREVCVUdfQ09OU1RSVUNUT1JfXztcbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcihGZWRlcmF0aW9uQ29uc3RydWN0b3IsIGlzRGVidWcgPSBpc0RlYnVnTW9kZSgpKSB7XG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0RFQlVHX0NPTlNUUlVDVE9SX18gPSBGZWRlcmF0aW9uQ29uc3RydWN0b3I7XG4gICAgICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19ERUJVR19DT05TVFJVQ1RPUl9WRVJTSU9OX18gPSBcIjAuMS4xOFwiO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBnZXRJbmZvV2l0aG91dFR5cGUodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qga2V5UmVzID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChrZXlSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFtrZXldLFxuICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldEtleSBvZiB0YXJnZXRLZXlzKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbdGFyZ2V0VHlwZU9yTmFtZSwgX10gPSB0YXJnZXRLZXkuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuS2V5ID0gYCR7dGFyZ2V0VHlwZU9yTmFtZX06JHtrZXl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlV2l0aEtleVJlcyA9IHRhcmdldFtuS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVdpdGhLZXlSZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlV2l0aEtleVJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbktleVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgfVxufVxuY29uc3QgZ2V0R2xvYmFsU25hcHNob3QgPSAoKT0+bmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm87XG5jb25zdCBnZXRUYXJnZXRTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAobW9kdWxlSW5mbywgc25hcHNob3QpPT57XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBpbmNsdWRlZCBpbiB0aGUgaG9zdFNuYXBzaG90XG4gICAgY29uc3QgbW9kdWxlS2V5ID0gZ2V0Rk1JZChtb2R1bGVJbmZvKTtcbiAgICBjb25zdCBnZXRNb2R1bGVJbmZvID0gZ2V0SW5mb1dpdGhvdXRUeXBlKHNuYXBzaG90LCBtb2R1bGVLZXkpLnZhbHVlO1xuICAgIC8vIFRoZSByZW1vdGVTbmFwc2hvdCBtaWdodCBub3QgaW5jbHVkZSBhIHZlcnNpb25cbiAgICBpZiAoZ2V0TW9kdWxlSW5mbyAmJiAhZ2V0TW9kdWxlSW5mby52ZXJzaW9uICYmICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvICYmIG1vZHVsZUluZm9bJ3ZlcnNpb24nXSkge1xuICAgICAgICBnZXRNb2R1bGVJbmZvLnZlcnNpb24gPSBtb2R1bGVJbmZvWyd2ZXJzaW9uJ107XG4gICAgfVxuICAgIGlmIChnZXRNb2R1bGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBnZXRNb2R1bGVJbmZvO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcmVtb3RlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgaG9zdFNuYXBzaG90LCBkZXBsb3kgYSBtaWNybyBhcHAgc25hcHNob3RcbiAgICBpZiAoJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mb1sndmVyc2lvbiddKSB7XG4gICAgICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gbW9kdWxlSW5mbywgcmVzTW9kdWxlSW5mbyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKG1vZHVsZUluZm8sIFtcbiAgICAgICAgICAgIFwidmVyc2lvblwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBtb2R1bGVLZXlXaXRob3V0VmVyc2lvbiA9IGdldEZNSWQocmVzTW9kdWxlSW5mbyk7XG4gICAgICAgIGNvbnN0IGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbiA9IGdldEluZm9XaXRob3V0VHlwZShuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbywgbW9kdWxlS2V5V2l0aG91dFZlcnNpb24pLnZhbHVlO1xuICAgICAgICBpZiAoKGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbiA9PSBudWxsID8gdm9pZCAwIDogZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uLnZlcnNpb24pID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5jb25zdCBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAobW9kdWxlSW5mbyk9PmdldFRhcmdldFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhtb2R1bGVJbmZvLCBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyk7XG5jb25zdCBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAocmVtb3RlSW5mbywgbW9kdWxlRGV0YWlsSW5mbyk9PntcbiAgICBjb25zdCBtb2R1bGVLZXkgPSBnZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvW21vZHVsZUtleV0gPSBtb2R1bGVEZXRhaWxJbmZvO1xuICAgIHJldHVybiBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbztcbn07XG5jb25zdCBhZGRHbG9iYWxTbmFwc2hvdCA9IChtb2R1bGVJbmZvcyk9PntcbiAgICBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyA9IF9leHRlbmRzJDEoe30sIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvLCBtb2R1bGVJbmZvcyk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb2R1bGVJbmZvcyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpe1xuICAgICAgICAgICAgZGVsZXRlIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IGdldFJlbW90ZUVudHJ5RXhwb3J0cyA9IChuYW1lLCBnbG9iYWxOYW1lKT0+e1xuICAgIGNvbnN0IHJlbW90ZUVudHJ5S2V5ID0gZ2xvYmFsTmFtZSB8fCBgX19GRURFUkFUSU9OXyR7bmFtZX06Y3VzdG9tX19gO1xuICAgIGNvbnN0IGVudHJ5RXhwb3J0cyA9IGdsb2JhbFRoaXNbcmVtb3RlRW50cnlLZXldO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbW90ZUVudHJ5S2V5LFxuICAgICAgICBlbnRyeUV4cG9ydHNcbiAgICB9O1xufTtcbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZWdpc3RlciBnbG9iYWwgcGx1Z2lucy5cbi8vIEl0IGl0ZXJhdGVzIG92ZXIgdGhlIHByb3ZpZGVkIHBsdWdpbnMgYW5kIGNoZWNrcyBpZiB0aGV5IGFyZSBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4vLyBJZiBhIHBsdWdpbiBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaXMgYWRkZWQgdG8gdGhlIGdsb2JhbCBwbHVnaW5zLlxuLy8gSWYgYSBwbHVnaW4gaXMgYWxyZWFkeSByZWdpc3RlcmVkLCBhIHdhcm5pbmcgbWVzc2FnZSBpcyBsb2dnZWQuXG5jb25zdCByZWdpc3Rlckdsb2JhbFBsdWdpbnMgPSAocGx1Z2lucyk9PntcbiAgICBjb25zdCB7IF9fR0xPQkFMX1BMVUdJTl9fIH0gPSBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX187XG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgIGlmIChfX0dMT0JBTF9QTFVHSU5fXy5maW5kSW5kZXgoKHApPT5wLm5hbWUgPT09IHBsdWdpbi5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIF9fR0xPQkFMX1BMVUdJTl9fLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYFRoZSBwbHVnaW4gJHtwbHVnaW4ubmFtZX0gaGFzIGJlZW4gcmVnaXN0ZXJlZC5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGdldEdsb2JhbEhvc3RQbHVnaW5zID0gKCk9Pm5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX0dMT0JBTF9QTFVHSU5fXztcbmNvbnN0IGdldFByZWxvYWRlZCA9IChpZCk9Pmdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19QUkVMT0FERURfTUFQX18uZ2V0KGlkKTtcbmNvbnN0IHNldFByZWxvYWRlZCA9IChpZCk9Pmdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19QUkVMT0FERURfTUFQX18uc2V0KGlkLCB0cnVlKTtcblxuY29uc3QgREVGQVVMVF9TQ09QRSA9ICdkZWZhdWx0JztcbmNvbnN0IERFRkFVTFRfUkVNT1RFX1RZUEUgPSAnZ2xvYmFsJztcblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuLy8gdGhvc2UgY29uc3RhbnRzIGFyZSBiYXNlZCBvbiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9zZW1hbnRpY19yYW5nZS8zLjAuMC9TZW1hbnRpY1JhbmdlI0JVSUxESURFTlRJRklFUi1jb25zdGFudFxuLy8gQ29weXJpZ2h0IChjKVxuLy8gdml0ZS1wbHVnaW4tZmVkZXJhdGlvbiBpcyBsaWNlbnNlZCB1bmRlciBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgY2FuIHVzZSB0aGlzIHNvZnR3YXJlIGFjY29yZGluZyB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhlIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiBNdWxhbiBQU0wgdjIgYXQ6XG4vLyAgICAgIGh0dHA6Ly9saWNlbnNlLmNvc2NsLm9yZy5jbi9NdWxhblBTTDJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgT04gQU4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT0YgQU5ZIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVCBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4vLyBTZWUgdGhlIE11bGFuIFBTTCB2MiBmb3IgbW9yZSBkZXRhaWxzLlxuY29uc3QgYnVpbGRJZGVudGlmaWVyID0gJ1swLTlBLVphLXotXSsnO1xuY29uc3QgYnVpbGQgPSBgKD86XFxcXCsoJHtidWlsZElkZW50aWZpZXJ9KD86XFxcXC4ke2J1aWxkSWRlbnRpZmllcn0pKikpYDtcbmNvbnN0IG51bWVyaWNJZGVudGlmaWVyID0gJzB8WzEtOV1cXFxcZConO1xuY29uc3QgbnVtZXJpY0lkZW50aWZpZXJMb29zZSA9ICdbMC05XSsnO1xuY29uc3Qgbm9uTnVtZXJpY0lkZW50aWZpZXIgPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5jb25zdCBwcmVSZWxlYXNlSWRlbnRpZmllckxvb3NlID0gYCg/OiR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX18JHtub25OdW1lcmljSWRlbnRpZmllcn0pYDtcbmNvbnN0IHByZVJlbGVhc2VMb29zZSA9IGAoPzotPygke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KD86XFxcXC4ke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KSopKWA7XG5jb25zdCBwcmVSZWxlYXNlSWRlbnRpZmllciA9IGAoPzoke251bWVyaWNJZGVudGlmaWVyfXwke25vbk51bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgcHJlUmVsZWFzZSA9IGAoPzotKCR7cHJlUmVsZWFzZUlkZW50aWZpZXJ9KD86XFxcXC4ke3ByZVJlbGVhc2VJZGVudGlmaWVyfSkqKSlgO1xuY29uc3QgeFJhbmdlSWRlbnRpZmllciA9IGAke251bWVyaWNJZGVudGlmaWVyfXx4fFh8XFxcXCpgO1xuY29uc3QgeFJhbmdlUGxhaW4gPSBgW3Y9XFxcXHNdKigke3hSYW5nZUlkZW50aWZpZXJ9KSg/OlxcXFwuKCR7eFJhbmdlSWRlbnRpZmllcn0pKD86XFxcXC4oJHt4UmFuZ2VJZGVudGlmaWVyfSkoPzoke3ByZVJlbGVhc2V9KT8ke2J1aWxkfT8pPyk/YDtcbmNvbnN0IGh5cGhlblJhbmdlID0gYF5cXFxccyooJHt4UmFuZ2VQbGFpbn0pXFxcXHMrLVxcXFxzKygke3hSYW5nZVBsYWlufSlcXFxccyokYDtcbmNvbnN0IG1haW5WZXJzaW9uTG9vc2UgPSBgKCR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX0pXFxcXC4oJHtudW1lcmljSWRlbnRpZmllckxvb3NlfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyTG9vc2V9KWA7XG5jb25zdCBsb29zZVBsYWluID0gYFt2PVxcXFxzXSoke21haW5WZXJzaW9uTG9vc2V9JHtwcmVSZWxlYXNlTG9vc2V9PyR7YnVpbGR9P2A7XG5jb25zdCBndGx0ID0gJygoPzo8fD4pPz0/KSc7XG5jb25zdCBjb21wYXJhdG9yVHJpbSA9IGAoXFxcXHMqKSR7Z3RsdH1cXFxccyooJHtsb29zZVBsYWlufXwke3hSYW5nZVBsYWlufSlgO1xuY29uc3QgbG9uZVRpbGRlID0gJyg/On4+PyknO1xuY29uc3QgdGlsZGVUcmltID0gYChcXFxccyopJHtsb25lVGlsZGV9XFxcXHMrYDtcbmNvbnN0IGxvbmVDYXJldCA9ICcoPzpcXFxcXiknO1xuY29uc3QgY2FyZXRUcmltID0gYChcXFxccyopJHtsb25lQ2FyZXR9XFxcXHMrYDtcbmNvbnN0IHN0YXIgPSAnKDx8Pik/PT9cXFxccypcXFxcKic7XG5jb25zdCBjYXJldCA9IGBeJHtsb25lQ2FyZXR9JHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IG1haW5WZXJzaW9uID0gYCgke251bWVyaWNJZGVudGlmaWVyfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgZnVsbFBsYWluID0gYHY/JHttYWluVmVyc2lvbn0ke3ByZVJlbGVhc2V9PyR7YnVpbGR9P2A7XG5jb25zdCB0aWxkZSA9IGBeJHtsb25lVGlsZGV9JHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IHhSYW5nZSA9IGBeJHtndGx0fVxcXFxzKiR7eFJhbmdlUGxhaW59JGA7XG5jb25zdCBjb21wYXJhdG9yID0gYF4ke2d0bHR9XFxcXHMqKCR7ZnVsbFBsYWlufSkkfF4kYDtcbi8vIGNvcHkgZnJvbSBzZW12ZXIgcGFja2FnZVxuY29uc3QgZ3RlMCA9ICdeXFxcXHMqPj1cXFxccyowLjAuMFxcXFxzKiQnO1xuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSk7XG59XG5mdW5jdGlvbiBpc1hWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gIXZlcnNpb24gfHwgdmVyc2lvbi50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgdmVyc2lvbiA9PT0gJyonO1xufVxuZnVuY3Rpb24gcGlwZSguLi5mbnMpIHtcbiAgICByZXR1cm4gKHgpPT5mbnMucmVkdWNlKCh2LCBmKT0+Zih2KSwgeCk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29tcGFyYXRvcihjb21wYXJhdG9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3JTdHJpbmcubWF0Y2gocGFyc2VSZWdleChjb21wYXJhdG9yKSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVmVyc2lvbihtYWpvciwgbWlub3IsIHBhdGNoLCBwcmVSZWxlYXNlKSB7XG4gICAgY29uc3QgbWFpblZlcnNpb24gPSBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gO1xuICAgIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgIHJldHVybiBgJHttYWluVmVyc2lvbn0tJHtwcmVSZWxlYXNlfWA7XG4gICAgfVxuICAgIHJldHVybiBtYWluVmVyc2lvbjtcbn1cblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuZnVuY3Rpb24gcGFyc2VIeXBoZW4ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KGh5cGhlblJhbmdlKSwgKF9yYW5nZSwgZnJvbSwgZnJvbU1ham9yLCBmcm9tTWlub3IsIGZyb21QYXRjaCwgX2Zyb21QcmVSZWxlYXNlLCBfZnJvbUJ1aWxkLCB0bywgdG9NYWpvciwgdG9NaW5vciwgdG9QYXRjaCwgdG9QcmVSZWxlYXNlKT0+e1xuICAgICAgICBpZiAoaXNYVmVyc2lvbihmcm9tTWFqb3IpKSB7XG4gICAgICAgICAgICBmcm9tID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihmcm9tTWlub3IpKSB7XG4gICAgICAgICAgICBmcm9tID0gYD49JHtmcm9tTWFqb3J9LjAuMGA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihmcm9tUGF0Y2gpKSB7XG4gICAgICAgICAgICBmcm9tID0gYD49JHtmcm9tTWFqb3J9LiR7ZnJvbU1pbm9yfS4wYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb219YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNYVmVyc2lvbih0b01ham9yKSkge1xuICAgICAgICAgICAgdG8gPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHRvTWlub3IpKSB7XG4gICAgICAgICAgICB0byA9IGA8JHtOdW1iZXIodG9NYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbih0b1BhdGNoKSkge1xuICAgICAgICAgICAgdG8gPSBgPCR7dG9NYWpvcn0uJHtOdW1iZXIodG9NaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKHRvUHJlUmVsZWFzZSkge1xuICAgICAgICAgICAgdG8gPSBgPD0ke3RvTWFqb3J9LiR7dG9NaW5vcn0uJHt0b1BhdGNofS0ke3RvUHJlUmVsZWFzZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG8gPSBgPD0ke3RvfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3JUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleChjb21wYXJhdG9yVHJpbSksICckMSQyJDMnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGlsZGVUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleCh0aWxkZVRyaW0pLCAnJDF+Jyk7XG59XG5mdW5jdGlvbiBwYXJzZUNhcmV0VHJpbShyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5yZXBsYWNlKHBhcnNlUmVnZXgoY2FyZXRUcmltKSwgJyQxXicpO1xufVxuZnVuY3Rpb24gcGFyc2VDYXJldHMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChyYW5nZVZlcnNpb24pPT5yYW5nZVZlcnNpb24ucmVwbGFjZShwYXJzZVJlZ2V4KGNhcmV0KSwgKF8sIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBpZiAoaXNYVmVyc2lvbihtYWpvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24obWlub3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHBhdGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChtYWpvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofS0ke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke21pbm9yfS4ke051bWJlcihwYXRjaCkgKyAxfS0wYDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofS0ke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYWpvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5vciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7bWlub3J9LiR7TnVtYmVyKHBhdGNoKSArIDF9LTBgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gcGFyc2VUaWxkZXMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChyYW5nZVZlcnNpb24pPT5yYW5nZVZlcnNpb24ucmVwbGFjZShwYXJzZVJlZ2V4KHRpbGRlKSwgKF8sIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBpZiAoaXNYVmVyc2lvbihtYWpvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24obWlub3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHBhdGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgIH0pKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBwYXJzZVhSYW5nZXMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2Uuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi50cmltKCkucmVwbGFjZShwYXJzZVJlZ2V4KHhSYW5nZSksIChyZXQsIGd0bHQsIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBjb25zdCBpc1hNYWpvciA9IGlzWFZlcnNpb24obWFqb3IpO1xuICAgICAgICAgICAgY29uc3QgaXNYTWlub3IgPSBpc1hNYWpvciB8fCBpc1hWZXJzaW9uKG1pbm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGlzWFBhdGNoID0gaXNYTWlub3IgfHwgaXNYVmVyc2lvbihwYXRjaCk7XG4gICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgZ3RsdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlUmVsZWFzZSA9ICcnO1xuICAgICAgICAgICAgaWYgKGlzWE1ham9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPDAuMC4wLTAnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChndGx0ICYmIGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgICAgICAgICAgIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgICAgICBtaW5vciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGNoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgICAgICAgICAgICAgIGd0bHQgPSAnPj0nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYTWlub3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ham9yID0gTnVtYmVyKG1ham9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IE51bWJlcihtaW5vcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkIHBhc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWpvciA9IE51bWJlcihtYWpvcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3IgPSBOdW1iZXIobWlub3IpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVJlbGVhc2UgPSAnLTAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Z3RsdCArIG1ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlUmVsZWFzZX1gO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4wLjAke3ByZVJlbGVhc2V9IDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSkpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RhcihyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkucmVwbGFjZShwYXJzZVJlZ2V4KHN0YXIpLCAnJyk7XG59XG5mdW5jdGlvbiBwYXJzZUdURTAoY29tcGFyYXRvclN0cmluZykge1xuICAgIHJldHVybiBjb21wYXJhdG9yU3RyaW5nLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoZ3RlMCksICcnKTtcbn1cblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuLy8gQ29weXJpZ2h0IChjKVxuLy8gdml0ZS1wbHVnaW4tZmVkZXJhdGlvbiBpcyBsaWNlbnNlZCB1bmRlciBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgY2FuIHVzZSB0aGlzIHNvZnR3YXJlIGFjY29yZGluZyB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhlIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiBNdWxhbiBQU0wgdjIgYXQ6XG4vLyAgICAgIGh0dHA6Ly9saWNlbnNlLmNvc2NsLm9yZy5jbi9NdWxhblBTTDJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgT04gQU4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT0YgQU5ZIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVCBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4vLyBTZWUgdGhlIE11bGFuIFBTTCB2MiBmb3IgbW9yZSBkZXRhaWxzLlxuZnVuY3Rpb24gY29tcGFyZUF0b20ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIHJhbmdlQXRvbSA9IE51bWJlcihyYW5nZUF0b20pIHx8IHJhbmdlQXRvbTtcbiAgICB2ZXJzaW9uQXRvbSA9IE51bWJlcih2ZXJzaW9uQXRvbSkgfHwgdmVyc2lvbkF0b207XG4gICAgaWYgKHJhbmdlQXRvbSA+IHZlcnNpb25BdG9tKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAocmFuZ2VBdG9tID09PSB2ZXJzaW9uQXRvbSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gY29tcGFyZVByZVJlbGVhc2UocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIGNvbnN0IHsgcHJlUmVsZWFzZTogcmFuZ2VQcmVSZWxlYXNlIH0gPSByYW5nZUF0b207XG4gICAgY29uc3QgeyBwcmVSZWxlYXNlOiB2ZXJzaW9uUHJlUmVsZWFzZSB9ID0gdmVyc2lvbkF0b207XG4gICAgaWYgKHJhbmdlUHJlUmVsZWFzZSA9PT0gdW5kZWZpbmVkICYmIEJvb2xlYW4odmVyc2lvblByZVJlbGVhc2UpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoQm9vbGVhbihyYW5nZVByZVJlbGVhc2UpICYmIHZlcnNpb25QcmVSZWxlYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAocmFuZ2VQcmVSZWxlYXNlID09PSB1bmRlZmluZWQgJiYgdmVyc2lvblByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMCwgbiA9IHJhbmdlUHJlUmVsZWFzZS5sZW5ndGg7IGkgPD0gbjsgaSsrKXtcbiAgICAgICAgY29uc3QgcmFuZ2VFbGVtZW50ID0gcmFuZ2VQcmVSZWxlYXNlW2ldO1xuICAgICAgICBjb25zdCB2ZXJzaW9uRWxlbWVudCA9IHZlcnNpb25QcmVSZWxlYXNlW2ldO1xuICAgICAgICBpZiAocmFuZ2VFbGVtZW50ID09PSB2ZXJzaW9uRWxlbWVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIHZlcnNpb25FbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZlcnNpb25FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBdG9tKHJhbmdlRWxlbWVudCwgdmVyc2lvbkVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICByZXR1cm4gY29tcGFyZUF0b20ocmFuZ2VBdG9tLm1ham9yLCB2ZXJzaW9uQXRvbS5tYWpvcikgfHwgY29tcGFyZUF0b20ocmFuZ2VBdG9tLm1pbm9yLCB2ZXJzaW9uQXRvbS5taW5vcikgfHwgY29tcGFyZUF0b20ocmFuZ2VBdG9tLnBhdGNoLCB2ZXJzaW9uQXRvbS5wYXRjaCkgfHwgY29tcGFyZVByZVJlbGVhc2UocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSk7XG59XG5mdW5jdGlvbiBlcShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgcmV0dXJuIHJhbmdlQXRvbS52ZXJzaW9uID09PSB2ZXJzaW9uQXRvbS52ZXJzaW9uO1xufVxuZnVuY3Rpb24gY29tcGFyZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgc3dpdGNoKHJhbmdlQXRvbS5vcGVyYXRvcil7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmVyc2lvbihyYW5nZUF0b20sIHZlcnNpb25BdG9tKSA8IDA7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHJldHVybiBlcShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB8fCBjb21wYXJlVmVyc2lvbihyYW5nZUF0b20sIHZlcnNpb25BdG9tKSA8IDA7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pID4gMDtcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHx8IGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pID4gMDtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbWVhbiAqIG9yIHggLT4gYWxsIHZlcnNpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3JTdHJpbmcocmFuZ2UpIHtcbiAgICByZXR1cm4gcGlwZSgvLyBoYW5kbGUgY2FyZXRcbiAgICAvLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuICAgIC8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbiAgICAvLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbiAgICAvLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbiAgICBwYXJzZUNhcmV0cywgLy8gaGFuZGxlIHRpbGRlXG4gICAgLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4gICAgLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4gICAgLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuICAgIC8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbiAgICAvLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbiAgICAvLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbiAgICBwYXJzZVRpbGRlcywgcGFyc2VYUmFuZ2VzLCBwYXJzZVN0YXIpKHJhbmdlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4gcGlwZSgvLyBoYW5kbGUgaHlwaGVuUmFuZ2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBwYXJzZUh5cGhlbiwgLy8gaGFuZGxlIHRyaW0gY29tcGFyYXRvclxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHBhcnNlQ29tcGFyYXRvclRyaW0sIC8vIGhhbmRsZSB0cmltIHRpbGRlXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcGFyc2VUaWxkZVRyaW0sIC8vIGhhbmRsZSB0cmltIGNhcmV0XG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcGFyc2VDYXJldFRyaW0pKHJhbmdlLnRyaW0oKSkuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBzYXRpc2Z5KHZlcnNpb24sIHJhbmdlKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUmFuZ2UgPSBwYXJzZVJhbmdlKHJhbmdlKTtcbiAgICBjb25zdCBwYXJzZWRDb21wYXJhdG9yID0gcGFyc2VkUmFuZ2Uuc3BsaXQoJyAnKS5tYXAoKHJhbmdlVmVyc2lvbik9PnBhcnNlQ29tcGFyYXRvclN0cmluZyhyYW5nZVZlcnNpb24pKS5qb2luKCcgJyk7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSBwYXJzZWRDb21wYXJhdG9yLnNwbGl0KC9cXHMrLykubWFwKChjb21wYXJhdG9yKT0+cGFyc2VHVEUwKGNvbXBhcmF0b3IpKTtcbiAgICBjb25zdCBleHRyYWN0ZWRWZXJzaW9uID0gZXh0cmFjdENvbXBhcmF0b3IodmVyc2lvbik7XG4gICAgaWYgKCFleHRyYWN0ZWRWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgWywgdmVyc2lvbk9wZXJhdG9yLCAsIHZlcnNpb25NYWpvciwgdmVyc2lvbk1pbm9yLCB2ZXJzaW9uUGF0Y2gsIHZlcnNpb25QcmVSZWxlYXNlXSA9IGV4dHJhY3RlZFZlcnNpb247XG4gICAgY29uc3QgdmVyc2lvbkF0b20gPSB7XG4gICAgICAgIG9wZXJhdG9yOiB2ZXJzaW9uT3BlcmF0b3IsXG4gICAgICAgIHZlcnNpb246IGNvbWJpbmVWZXJzaW9uKHZlcnNpb25NYWpvciwgdmVyc2lvbk1pbm9yLCB2ZXJzaW9uUGF0Y2gsIHZlcnNpb25QcmVSZWxlYXNlKSxcbiAgICAgICAgbWFqb3I6IHZlcnNpb25NYWpvcixcbiAgICAgICAgbWlub3I6IHZlcnNpb25NaW5vcixcbiAgICAgICAgcGF0Y2g6IHZlcnNpb25QYXRjaCxcbiAgICAgICAgcHJlUmVsZWFzZTogdmVyc2lvblByZVJlbGVhc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHZlcnNpb25QcmVSZWxlYXNlLnNwbGl0KCcuJylcbiAgICB9O1xuICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycyl7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZENvbXBhcmF0b3IgPSBleHRyYWN0Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICAgICAgaWYgKCFleHRyYWN0ZWRDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgcmFuZ2VPcGVyYXRvciwgLCByYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2VdID0gZXh0cmFjdGVkQ29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgcmFuZ2VBdG9tID0ge1xuICAgICAgICAgICAgb3BlcmF0b3I6IHJhbmdlT3BlcmF0b3IsXG4gICAgICAgICAgICB2ZXJzaW9uOiBjb21iaW5lVmVyc2lvbihyYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2UpLFxuICAgICAgICAgICAgbWFqb3I6IHJhbmdlTWFqb3IsXG4gICAgICAgICAgICBtaW5vcjogcmFuZ2VNaW5vcixcbiAgICAgICAgICAgIHBhdGNoOiByYW5nZVBhdGNoLFxuICAgICAgICAgICAgcHJlUmVsZWFzZTogcmFuZ2VQcmVSZWxlYXNlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZVByZVJlbGVhc2Uuc3BsaXQoJy4nKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNvbXBhcmUocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZWFybHkgcmV0dXJuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaGFyZShzaGFyZUFyZ3MsIGZyb20sIG5hbWUpIHtcbiAgICBsZXQgZ2V0O1xuICAgIGlmICgnZ2V0JyBpbiBzaGFyZUFyZ3MpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGdldCA9IHNoYXJlQXJncy5nZXQ7XG4gICAgfSBlbHNlIGlmICgnbGliJyBpbiBzaGFyZUFyZ3MpIHtcbiAgICAgICAgZ2V0ID0gKCk9PlByb21pc2UucmVzb2x2ZShzaGFyZUFyZ3MubGliKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXQgPSAoKT0+UHJvbWlzZS5yZXNvbHZlKCgpPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGdldCBzaGFyZWQgJyR7bmFtZX0nIWApO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfc2hhcmVBcmdzX3ZlcnNpb24sIF9zaGFyZUFyZ3Nfc2NvcGU7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZGVwczogW10sXG4gICAgICAgIHVzZUluOiBbXSxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgbG9hZGluZzogbnVsbFxuICAgIH0sIHNoYXJlQXJncywge1xuICAgICAgICBzaGFyZUNvbmZpZzogX2V4dGVuZHMoe1xuICAgICAgICAgICAgcmVxdWlyZWRWZXJzaW9uOiBgXiR7c2hhcmVBcmdzLnZlcnNpb259YCxcbiAgICAgICAgICAgIHNpbmdsZXRvbjogZmFsc2UsXG4gICAgICAgICAgICBlYWdlcjogZmFsc2UsXG4gICAgICAgICAgICBzdHJpY3RWZXJzaW9uOiBmYWxzZVxuICAgICAgICB9LCBzaGFyZUFyZ3Muc2hhcmVDb25maWcpLFxuICAgICAgICBnZXQsXG4gICAgICAgIGxvYWRlZDogJ2xpYicgaW4gc2hhcmVBcmdzID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyc2lvbjogKF9zaGFyZUFyZ3NfdmVyc2lvbiA9IHNoYXJlQXJncy52ZXJzaW9uKSAhPSBudWxsID8gX3NoYXJlQXJnc192ZXJzaW9uIDogJzAnLFxuICAgICAgICBzY29wZTogQXJyYXkuaXNBcnJheShzaGFyZUFyZ3Muc2NvcGUpID8gc2hhcmVBcmdzLnNjb3BlIDogW1xuICAgICAgICAgICAgKF9zaGFyZUFyZ3Nfc2NvcGUgPSBzaGFyZUFyZ3Muc2NvcGUpICE9IG51bGwgPyBfc2hhcmVBcmdzX3Njb3BlIDogJ2RlZmF1bHQnXG4gICAgICAgIF0sXG4gICAgICAgIHN0cmF0ZWd5OiBzaGFyZUFyZ3Muc3RyYXRlZ3kgfHwgJ3ZlcnNpb24tZmlyc3QnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaGFyZUNvbmZpZ3MoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICBjb25zdCBzaGFyZUFyZ3MgPSB1c2VyT3B0aW9ucy5zaGFyZWQgfHwge307XG4gICAgY29uc3QgZnJvbSA9IHVzZXJPcHRpb25zLm5hbWU7XG4gICAgY29uc3Qgc2hhcmVJbmZvcyA9IE9iamVjdC5rZXlzKHNoYXJlQXJncykucmVkdWNlKChyZXMsIHBrZ05hbWUpPT57XG4gICAgICAgIGNvbnN0IGFycmF5U2hhcmVBcmdzID0gYXJyYXlPcHRpb25zKHNoYXJlQXJnc1twa2dOYW1lXSk7XG4gICAgICAgIHJlc1twa2dOYW1lXSA9IHJlc1twa2dOYW1lXSB8fCBbXTtcbiAgICAgICAgYXJyYXlTaGFyZUFyZ3MuZm9yRWFjaCgoc2hhcmVDb25maWcpPT57XG4gICAgICAgICAgICByZXNbcGtnTmFtZV0ucHVzaChmb3JtYXRTaGFyZShzaGFyZUNvbmZpZywgZnJvbSwgcGtnTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB7fSk7XG4gICAgY29uc3Qgc2hhcmVkID0gX2V4dGVuZHMoe30sIGdsb2JhbE9wdGlvbnMuc2hhcmVkKTtcbiAgICBPYmplY3Qua2V5cyhzaGFyZUluZm9zKS5mb3JFYWNoKChzaGFyZUtleSk9PntcbiAgICAgICAgaWYgKCFzaGFyZWRbc2hhcmVLZXldKSB7XG4gICAgICAgICAgICBzaGFyZWRbc2hhcmVLZXldID0gc2hhcmVJbmZvc1tzaGFyZUtleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFyZUluZm9zW3NoYXJlS2V5XS5mb3JFYWNoKChuZXdVc2VyU2hhcmVkT3B0aW9ucyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NhbWVWZXJzaW9uID0gc2hhcmVkW3NoYXJlS2V5XS5maW5kKChzaGFyZWRWYWwpPT5zaGFyZWRWYWwudmVyc2lvbiA9PT0gbmV3VXNlclNoYXJlZE9wdGlvbnMudmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZFtzaGFyZUtleV0ucHVzaChuZXdVc2VyU2hhcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaGFyZWQsXG4gICAgICAgIHNoYXJlSW5mb3NcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyc2lvbkx0KGEsIGIpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1JbnZhbGlkVmVyc2lvbiA9ICh2ZXJzaW9uKT0+e1xuICAgICAgICBjb25zdCBpc051bWJlclZlcnNpb24gPSAhTnVtYmVyLmlzTmFOKE51bWJlcih2ZXJzaW9uKSk7XG4gICAgICAgIGlmIChpc051bWJlclZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0QXJyID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgbGV0IHZhbGlkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMyAtIHNwbGl0QXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YWxpZFZlcnNpb24gKz0gJy4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxpZFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfTtcbiAgICBpZiAoc2F0aXNmeSh0cmFuc2Zvcm1JbnZhbGlkVmVyc2lvbihhKSwgYDw9JHt0cmFuc2Zvcm1JbnZhbGlkVmVyc2lvbihiKX1gKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgZmluZFZlcnNpb24gPSAoc2hhcmVWZXJzaW9uTWFwLCBjYik9PntcbiAgICBjb25zdCBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICByZXR1cm4gdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2hhcmVWZXJzaW9uTWFwKS5yZWR1Y2UoKHByZXYsIGN1cik9PntcbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjayhwcmV2LCBjdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmF1bHQgdmVyc2lvbiBpcyAnMCcgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL21haW4vbGliL3NoYXJpbmcvUHJvdmlkZVNoYXJlZE1vZHVsZS5qcyNMMTM2XG4gICAgICAgIGlmIChwcmV2ID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgMCk7XG59O1xuY29uc3QgaXNMb2FkZWQgPSAoc2hhcmVkKT0+e1xuICAgIHJldHVybiBCb29sZWFuKHNoYXJlZC5sb2FkZWQpIHx8IHR5cGVvZiBzaGFyZWQubGliID09PSAnZnVuY3Rpb24nO1xufTtcbmZ1bmN0aW9uIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeVZlcnNpb24oc2hhcmVTY29wZU1hcCwgc2NvcGUsIHBrZ05hbWUpIHtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiAhaXNMb2FkZWQodmVyc2lvbnNbcHJldl0pICYmIHZlcnNpb25MdChwcmV2LCBjdXIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbmRWZXJzaW9uKHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlMb2FkZWQoc2hhcmVTY29wZU1hcCwgc2NvcGUsIHBrZ05hbWUpIHtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIGlmIChpc0xvYWRlZCh2ZXJzaW9uc1tjdXJdKSkge1xuICAgICAgICAgICAgaWYgKGlzTG9hZGVkKHZlcnNpb25zW3ByZXZdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHZlcnNpb25MdChwcmV2LCBjdXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTG9hZGVkKHZlcnNpb25zW3ByZXZdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTHQocHJldiwgY3VyKTtcbiAgICB9O1xuICAgIHJldHVybiBmaW5kVmVyc2lvbihzaGFyZVNjb3BlTWFwW3Njb3BlXVtwa2dOYW1lXSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZ2V0RmluZFNoYXJlRnVuY3Rpb24oc3RyYXRlZ3kpIHtcbiAgICBpZiAoc3RyYXRlZ3kgPT09ICdsb2FkZWQtZmlyc3QnKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlMb2FkZWQ7XG4gICAgfVxuICAgIHJldHVybiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlWZXJzaW9uO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFNoYXJlKGxvY2FsU2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvLCByZXNvbHZlU2hhcmUpIHtcbiAgICBpZiAoIWxvY2FsU2hhcmVTY29wZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2hhcmVDb25maWcsIHNjb3BlID0gREVGQVVMVF9TQ09QRSwgc3RyYXRlZ3kgfSA9IHNoYXJlSW5mbztcbiAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3BlKSA/IHNjb3BlIDogW1xuICAgICAgICBzY29wZVxuICAgIF07XG4gICAgZm9yIChjb25zdCBzYyBvZiBzY29wZXMpe1xuICAgICAgICBpZiAoc2hhcmVDb25maWcgJiYgbG9jYWxTaGFyZVNjb3BlTWFwW3NjXSAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVpcmVkVmVyc2lvbiB9ID0gc2hhcmVDb25maWc7XG4gICAgICAgICAgICBjb25zdCBmaW5kU2hhcmVGdW5jdGlvbiA9IGdldEZpbmRTaGFyZUZ1bmN0aW9uKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGNvbnN0IG1heE9yU2luZ2xldG9uVmVyc2lvbiA9IGZpbmRTaGFyZUZ1bmN0aW9uKGxvY2FsU2hhcmVTY29wZU1hcCwgc2MsIHBrZ05hbWUpO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzb2x2ZXIgPSAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaGFyZUNvbmZpZy5zaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZFZlcnNpb24gPT09ICdzdHJpbmcnICYmICFzYXRpc2Z5KG1heE9yU2luZ2xldG9uVmVyc2lvbiwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFZlcnNpb24gJHttYXhPclNpbmdsZXRvblZlcnNpb259IGZyb20gJHttYXhPclNpbmdsZXRvblZlcnNpb24gJiYgbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dLmZyb219IG9mIHNoYXJlZCBzaW5nbGV0b24gbW9kdWxlICR7cGtnTmFtZX0gZG9lcyBub3Qgc2F0aXNmeSB0aGUgcmVxdWlyZW1lbnQgb2YgJHtzaGFyZUluZm8uZnJvbX0gd2hpY2ggbmVlZHMgJHtyZXF1aXJlZFZlcnNpb259KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVDb25maWcuc3RyaWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFZlcnNpb24gPT09IGZhbHNlIHx8IHJlcXVpcmVkVmVyc2lvbiA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5KG1heE9yU2luZ2xldG9uVmVyc2lvbiwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bbWF4T3JTaW5nbGV0b25WZXJzaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt2ZXJzaW9uS2V5LCB2ZXJzaW9uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5KHZlcnNpb25LZXksIHJlcXVpcmVkVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzaGFyZVNjb3BlTWFwOiBsb2NhbFNoYXJlU2NvcGVNYXAsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHNjLFxuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWF4T3JTaW5nbGV0b25WZXJzaW9uLFxuICAgICAgICAgICAgICAgIEdsb2JhbEZlZGVyYXRpb246IEdsb2JhbC5fX0ZFREVSQVRJT05fXyxcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogZGVmYXVsdFJlc29sdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVNoYXJlZCA9IHJlc29sdmVTaGFyZS5lbWl0KHBhcmFtcykgfHwgcGFyYW1zO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVTaGFyZWQucmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFNoYXJlU2NvcGUoKSB7XG4gICAgcmV0dXJuIEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX1NIQVJFX187XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBrZ05hbWUsIGV4dHJhT3B0aW9ucywgc2hhcmVJbmZvcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkZWZhdWx0UmVzb2x2ZXIgPSAoc2hhcmVkT3B0aW9ucyk9PntcbiAgICAgICAgaWYgKCFzaGFyZWRPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYXJlVmVyc2lvbk1hcCA9IHt9O1xuICAgICAgICBzaGFyZWRPcHRpb25zLmZvckVhY2goKHNoYXJlZCk9PntcbiAgICAgICAgICAgIHNoYXJlVmVyc2lvbk1hcFtzaGFyZWQudmVyc2lvbl0gPSBzaGFyZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICAgICAgcmV0dXJuICFpc0xvYWRlZChzaGFyZVZlcnNpb25NYXBbcHJldl0pICYmIHZlcnNpb25MdChwcmV2LCBjdXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXhWZXJzaW9uID0gZmluZFZlcnNpb24oc2hhcmVWZXJzaW9uTWFwLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzaGFyZVZlcnNpb25NYXBbbWF4VmVyc2lvbl07XG4gICAgfTtcbiAgICB2YXIgX2V4dHJhT3B0aW9uc19yZXNvbHZlcjtcbiAgICBjb25zdCByZXNvbHZlciA9IChfZXh0cmFPcHRpb25zX3Jlc29sdmVyID0gZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMucmVzb2x2ZXIpICE9IG51bGwgPyBfZXh0cmFPcHRpb25zX3Jlc29sdmVyIDogZGVmYXVsdFJlc29sdmVyO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXNvbHZlcihzaGFyZUluZm9zW3BrZ05hbWVdKSwgZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuY3VzdG9tU2hhcmVJbmZvKTtcbn1cblxuZXhwb3J0IHsgYWRkVW5pcXVlSXRlbSBhcyBBLCBnZXRCdWlsZGVySWQgYXMgQiwgc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yIGFzIEMsIERFRkFVTFRfUkVNT1RFX1RZUEUgYXMgRCwgZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIGFzIEUsIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciBhcyBGLCBHbG9iYWwgYXMgRywgc2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIGFzIEgsIHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyBhcyBJLCBuYXRpdmVHbG9iYWwgYXMgSiwgcmVzZXRGZWRlcmF0aW9uR2xvYmFsSW5mbyBhcyBLLCBnZXRUYXJnZXRTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gYXMgTCwgZ2xvYmFsTG9hZGluZyBhcyBhLCBERUZBVUxUX1NDT1BFIGFzIGIsIGdldFJlbW90ZUVudHJ5RXhwb3J0cyBhcyBjLCBhc3NlcnQgYXMgZCwgZ2V0Rk1JZCBhcyBlLCBlcnJvciBhcyBmLCBnZXRHbG9iYWxIb3N0UGx1Z2lucyBhcyBnLCBpc1BsYWluT2JqZWN0IGFzIGgsIGlzT2JqZWN0IGFzIGksIGlzUmVtb3RlSW5mb1dpdGhFbnRyeSBhcyBqLCBpc1B1cmVSZW1vdGVFbnRyeSBhcyBrLCBpc0Jyb3dzZXJFbnYgYXMgbCwgZ2V0SW5mb1dpdGhvdXRUeXBlIGFzIG0sIGdldFByZWxvYWRlZCBhcyBuLCBzZXRQcmVsb2FkZWQgYXMgbywgZ2V0UmVnaXN0ZXJlZFNoYXJlIGFzIHAsIGFycmF5T3B0aW9ucyBhcyBxLCBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gYXMgciwgc2FmZVRvU3RyaW5nIGFzIHMsIGFkZEdsb2JhbFNuYXBzaG90IGFzIHQsIHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyBhcyB1LCBnZXRHbG9iYWxTbmFwc2hvdCBhcyB2LCB3YXJuIGFzIHcsIGZvcm1hdFNoYXJlQ29uZmlncyBhcyB4LCBnZXRUYXJnZXRTaGFyZWRPcHRpb25zIGFzIHksIGdldEdsb2JhbFNoYXJlU2NvcGUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/share.esm.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.cjs.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.cjs.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _define_property$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar FederationModuleManifest = 'federation-manifest.json';\nvar MANIFEST_EXT = '.json';\nvar BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nvar BROWSER_LOG_VALUE = '1';\nvar NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nvar _obj;\nvar NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, 'scope_'), _define_property$3(_obj, NameTransformSymbol.HYPHEN, '_'), _define_property$3(_obj, NameTransformSymbol.SLASH, '__'), _obj);\nvar _obj1;\nvar EncodedNameTransformMap = (_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH), _obj1);\nvar SEPARATOR = ':';\nvar ManifestFileName = 'mf-manifest.json';\nvar StatsFileName = 'mf-stats.json';\nvar MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nvar MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nvar getProcessEnv = function getProcessEnv() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction _array_like_to_array$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array$2(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array$1(arr) || _unsupported_iterable_to_array$2(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);\n}\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nvar DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nvar Logger = /*#__PURE__*/ function() {\n    function Logger(identifier) {\n        _class_call_check(this, Logger);\n        _define_property$2(this, \"enable\", false);\n        _define_property$2(this, \"identifier\", void 0);\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n    _create_class(Logger, [\n        {\n            key: \"info\",\n            value: function info(msg, info) {\n                if (this.enable) {\n                    var argsToString = safeToString(info) || '';\n                    if (isBrowserEnv()) {\n                        console.info(\"%c \".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString), 'color:#3300CC');\n                    } else {\n                        console.info('\\x1b[34m%s', \"\".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString ? \"\\n\".concat(argsToString) : ''));\n                    }\n                }\n            }\n        },\n        {\n            key: \"logOriginalInfo\",\n            value: function logOriginalInfo() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (this.enable) {\n                    if (isBrowserEnv()) {\n                        var _console;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console = console).log.apply(_console, _to_consumable_array(args));\n                    } else {\n                        var _console1;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console1 = console).log.apply(_console1, _to_consumable_array(args));\n                    }\n                }\n            }\n        }\n    ]);\n    return Logger;\n}();\n\nfunction _array_like_to_array$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes$1(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit$1(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest$1() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array$1(arr, i) {\n    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$1(arr, i) || _non_iterable_rest$1();\n}\nfunction _to_array(arr) {\n    return _array_with_holes$1(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_rest$1();\n}\nfunction _unsupported_iterable_to_array$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);\n}\nvar LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nvar parseEntry = function(str, devVerOrUrl) {\n    var separator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SEPARATOR;\n    var strSplit = str.split(separator);\n    var devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    var defaultVersion = '*';\n    var isEntry = function(s) {\n        return s.startsWith('http') || s.includes(MANIFEST_EXT);\n    };\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        var _strSplit = _to_array(strSplit), name = _strSplit[0], versionOrEntryArr = _strSplit.slice(1);\n        var versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name: name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name: name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        var _strSplit1 = _sliced_to_array$1(strSplit, 1), name1 = _strSplit1[0];\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name: name1,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name: name1,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw \"Invalid entry value: \".concat(str);\n    }\n};\nvar logger = new Logger();\nvar composeKeyWithSeparator =  function composeKeyWithSeparator() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce(function(sum, cur) {\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return \"\".concat(sum).concat(SEPARATOR).concat(cur);\n    }, '');\n};\nvar encodeName =  function encodeName(name) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', withExt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        var ext = withExt ? '.js' : '';\n        return \"\".concat(prefix).concat(name.replace(new RegExp(\"\".concat(NameTransformSymbol.AT), 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(\"\".concat(NameTransformSymbol.HYPHEN), 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(\"\".concat(NameTransformSymbol.SLASH), 'g'), NameTransformMap[NameTransformSymbol.SLASH])).concat(ext);\n    } catch (err) {\n        throw err;\n    }\n};\nvar decodeName =  function decodeName(name, prefix, withExt) {\n    try {\n        var decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.AT]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.SLASH]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.HYPHEN]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nvar generateExposeFilename =  function(exposeName, withExt) {\n    if (!exposeName) {\n        return '';\n    }\n    var expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nvar generateShareFilename =  function(pkgName, withExt) {\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nvar getResourceUrl = function(module, sourceUrl) {\n    if ('getPublicPath' in module) {\n        var publicPath = new Function(module.getPublicPath)();\n        return \"\".concat(publicPath).concat(sourceUrl);\n    } else if ('publicPath' in module) {\n        return \"\".concat(module.publicPath).concat(sourceUrl);\n    } else {\n        console.warn('Can not get resource url, if in debug mode, please ignore', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar assert = function(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n};\nvar error = function(msg) {\n    throw new Error(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\nvar warn = function(msg) {\n    console.warn(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\n\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nvar simpleJoinRemoteEntry = function(rPath, rName) {\n    if (!rPath) {\n        return rName;\n    }\n    var transformPath = function(str) {\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            var strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    var transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return \"\".concat(transformedPath).concat(rName);\n    }\n    return \"\".concat(transformedPath, \"/\").concat(rName);\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _manifest_metaData, _manifest_metaData1;\n    var _options_remotes = options.remotes, remotes = _options_remotes === void 0 ? {} : _options_remotes, _options_overrides = options.overrides, overrides = _options_overrides === void 0 ? {} : _options_overrides, version = options.version;\n    var remoteSnapshot;\n    var getPublicPath = function() {\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    var overridesKeys = Object.keys(overrides);\n    var remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) === null || _manifest_remotes === void 0 ? void 0 : _manifest_remotes.reduce(function(res, next) {\n            var matchedVersion;\n            var name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion: matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach(function(key) {\n        return remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        };\n    });\n    var _manifest_metaData2 = manifest.metaData, _manifest_metaData_remoteEntry = _manifest_metaData2.remoteEntry, remoteEntryPath = _manifest_metaData_remoteEntry.path, remoteEntryName = _manifest_metaData_remoteEntry.name, remoteEntryType = _manifest_metaData_remoteEntry.type, remoteTypes = _manifest_metaData2.types, buildVersion = _manifest_metaData2.buildInfo.buildVersion, globalName = _manifest_metaData2.globalName;\n    var exposes = manifest.exposes;\n    var basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion: buildVersion,\n        globalName: globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType: remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo: remotesInfo,\n        shared: manifest === null || manifest === void 0 ? void 0 : manifest.shared.map(function(item) {\n            return {\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            };\n        }),\n        modules: exposes === null || exposes === void 0 ? void 0 : exposes.map(function(expose) {\n            return {\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            };\n        })\n    };\n    if ((_manifest_metaData = manifest.metaData) === null || _manifest_metaData === void 0 ? void 0 : _manifest_metaData.prefetchInterface) {\n        var prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchInterface: prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) === null || _manifest_metaData1 === void 0 ? void 0 : _manifest_metaData1.prefetchEntry) {\n        var _manifest_metaData_prefetchEntry = manifest.metaData.prefetchEntry, path = _manifest_metaData_prefetchEntry.path, name = _manifest_metaData_prefetchEntry.name, type = _manifest_metaData_prefetchEntry.type;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            getPublicPath: getPublicPath()\n        });\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator$1(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _ts_generator$1(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeWrapper(callback, disableWarn) {\n    return _safeWrapper.apply(this, arguments);\n}\nfunction _safeWrapper() {\n    _safeWrapper = _async_to_generator$1(function(callback, disableWarn) {\n        var res, e;\n        return _ts_generator$1(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        callback()\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res\n                    ];\n                case 2:\n                    e = _state.sent();\n                    !disableWarn && warn(e);\n                    return [\n                        2\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _safeWrapper.apply(this, arguments);\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    var REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    var relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    var relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(url, cb, attrs, createScriptHook) {\n    // Retrieve the existing script element by its src attribute\n    var script = null;\n    var needAttach = true;\n    var timeout = 20000;\n    var timeoutId;\n    var scripts = document.getElementsByTagName('script');\n    for(var i = 0; i < scripts.length; i++){\n        var s = scripts[i];\n        var scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        if (createScriptHook) {\n            var createScriptRes = createScriptHook(url);\n            if (_instanceof(createScriptRes, HTMLScriptElement)) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if (createScriptRes.script) script = createScriptRes.script;\n                if (createScriptRes.timeout) timeout = createScriptRes.timeout;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (script) {\n                if (name === 'async' || name === 'defer') {\n                    script[name] = attrs[name];\n                } else {\n                    script.setAttribute(name, attrs[name]);\n                }\n            }\n        });\n    }\n    var onScriptComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(function() {\n                (script === null || script === void 0 ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(function() {\n        onScriptComplete(null, new Error('Remote script \"'.concat(url, '\" time-outed.')));\n    }, timeout);\n    return {\n        script: script,\n        needAttach: needAttach\n    };\n}\nfunction createLink(url, cb) {\n    var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, createLinkHook = arguments.length > 3 ? arguments[3] : void 0;\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    var link = null;\n    var needAttach = true;\n    var links = document.getElementsByTagName('link');\n    for(var i = 0; i < links.length; i++){\n        var l = links[i];\n        var linkHref = l.getAttribute('href');\n        var linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, url) && linkRef === attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', url);\n        link.setAttribute('crossorigin', 'anonymous');\n        if (createLinkHook) {\n            var createLinkRes = createLinkHook(url);\n            if (_instanceof(createLinkRes, HTMLLinkElement)) {\n                link = createLinkRes;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (link) {\n                link.setAttribute(name, attrs[name]);\n            }\n        });\n    }\n    var onLinkComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(function() {\n                (link === null || link === void 0 ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link: link,\n        needAttach: needAttach\n    };\n}\nfunction loadScript(url, info) {\n    var attrs = info.attrs, createScriptHook = info.createScriptHook;\n    return new Promise(function(resolve, _reject) {\n        var _createScript = createScript(url, resolve, attrs, createScriptHook), script = _createScript.script, needAttach = _createScript.needAttach;\n        needAttach && document.getElementsByTagName('head')[0].appendChild(script);\n    });\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    var importModule = new Function('name', \"return import(name)\");\n    return importModule(name).then(function(res) {\n        return res.default;\n    }).catch(function(error) {\n        console.error(\"Error importing module \".concat(name, \":\"), error);\n        throw error;\n    });\n}\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        var hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    var urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(\"Invalid URL: \".concat(e)));\n        return;\n    }\n    var getFetch = function() {\n        var _ref = _async_to_generator(function() {\n            var fetchModule;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!(typeof fetch === 'undefined')) return [\n                            3,\n                            2\n                        ];\n                        return [\n                            4,\n                            importNodeModule('node-fetch')\n                        ];\n                    case 1:\n                        fetchModule = _state.sent();\n                        //@ts-ignore\n                        return [\n                            2,\n                            (fetchModule === null || fetchModule === void 0 ? void 0 : fetchModule.default) || fetchModule\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            fetch\n                        ];\n                    case 3:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n        return function getFetch() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    console.log('fetching', urlObj.href);\n    getFetch().then(function(f) {\n        f(urlObj.href).then(function(res) {\n            return res.text();\n        }).then(function() {\n            var _ref = _async_to_generator(function(data) {\n                var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                Promise.all([\n                                    importNodeModule('path'),\n                                    importNodeModule('vm')\n                                ])\n                            ];\n                        case 1:\n                            _ref = _sliced_to_array.apply(void 0, [\n                                _state.sent(),\n                                2\n                            ]), path = _ref[0], vm = _ref[1];\n                            scriptContext = {\n                                exports: {},\n                                module: {\n                                    exports: {}\n                                }\n                            };\n                            urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n                            filename = path.basename(urlObj.pathname);\n                            try {\n                                script = new vm.Script(\"(function(exports, module, require, __dirname, __filename) {\".concat(data, \"\\n})\"), filename);\n                                script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n                                exportedInterface = scriptContext.module.exports || scriptContext.exports;\n                                if (attrs && exportedInterface && attrs['globalName']) {\n                                    container = exportedInterface[attrs['globalName']] || exportedInterface;\n                                    cb(undefined, container);\n                                    return [\n                                        2\n                                    ];\n                                }\n                                cb(undefined, exportedInterface);\n                            } catch (e) {\n                                // console.error('Error running script:', e);\n                                cb(new Error(\"Script execution error: \".concat(e)));\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function(data) {\n                return _ref.apply(this, arguments);\n            };\n        }()).catch(function(err) {\n            // console.error('Error fetching script:', err);\n            cb(err);\n        });\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise(function(resolve, reject) {\n        createScriptNode(url, function(error, scriptContext) {\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                var remoteEntryKey = (info === null || info === void 0 ? void 0 : (_info_attrs = info.attrs) === null || _info_attrs === void 0 ? void 0 : _info_attrs['globalName']) || \"__FEDERATION_\".concat(info === null || info === void 0 ? void 0 : (_info_attrs1 = info.attrs) === null || _info_attrs1 === void 0 ? void 0 : _info_attrs1['name'], \":custom__\");\n                var entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _object_spread({}, defaultOptions, options);\n        }\n        throw new Error(\"Unexpected type for `\".concat(key, \"`, expect boolean/undefined/object, got: \").concat(typeof options === \"undefined\" ? \"undefined\" : _type_of(options)));\n    };\n}\n\nexports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;\nexports.BROWSER_LOG_VALUE = BROWSER_LOG_VALUE;\nexports.EncodedNameTransformMap = EncodedNameTransformMap;\nexports.FederationModuleManifest = FederationModuleManifest;\nexports.Logger = Logger;\nexports.MANIFEST_EXT = MANIFEST_EXT;\nexports.MFModuleType = MFModuleType;\nexports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;\nexports.ManifestFileName = ManifestFileName;\nexports.NameTransformMap = NameTransformMap;\nexports.NameTransformSymbol = NameTransformSymbol;\nexports.SEPARATOR = SEPARATOR;\nexports.StatsFileName = StatsFileName;\nexports.assert = assert;\nexports.composeKeyWithSeparator = composeKeyWithSeparator;\nexports.containerPlugin = ContainerPlugin;\nexports.containerReferencePlugin = ContainerReferencePlugin;\nexports.createLink = createLink;\nexports.createScript = createScript;\nexports.createScriptNode = createScriptNode;\nexports.decodeName = decodeName;\nexports.encodeName = encodeName;\nexports.error = error;\nexports.generateExposeFilename = generateExposeFilename;\nexports.generateShareFilename = generateShareFilename;\nexports.generateSnapshotFromManifest = generateSnapshotFromManifest;\nexports.getProcessEnv = getProcessEnv;\nexports.getResourceUrl = getResourceUrl;\nexports.inferAutoPublicPath = inferAutoPublicPath;\nexports.isBrowserEnv = isBrowserEnv;\nexports.isDebugMode = isDebugMode;\nexports.isManifestProvider = isManifestProvider;\nexports.isStaticResourcesEqual = isStaticResourcesEqual;\nexports.loadScript = loadScript;\nexports.loadScriptNode = loadScriptNode;\nexports.logger = logger;\nexports.moduleFederationPlugin = ModuleFederationPlugin;\nexports.normalizeOptions = normalizeOptions;\nexports.parseEntry = parseEntry;\nexports.safeWrapper = safeWrapper;\nexports.sharePlugin = SharePlugin;\nexports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;\nexports.warn = warn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3Nka0AwLjEuMTgvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDJHQUEyRztBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILG1CQUFtQjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QixvQ0FBb0M7QUFDcEMscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsY0FBYztBQUNkLDhCQUE4QjtBQUM5Qix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQxLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb2R1bGUtZmVkZXJhdGlvbitzZGtAMC4xLjE4L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vc2RrL2Rpc3QvaW5kZXguY2pzLmpzPzRiMDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDMob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbnZhciBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbnZhciBNQU5JRkVTVF9FWFQgPSAnLmpzb24nO1xudmFyIEJST1dTRVJfTE9HX0tFWSA9ICdGRURFUkFUSU9OX0RFQlVHJztcbnZhciBCUk9XU0VSX0xPR19WQUxVRSA9ICcxJztcbnZhciBOYW1lVHJhbnNmb3JtU3ltYm9sID0ge1xuICAgIEFUOiAnQCcsXG4gICAgSFlQSEVOOiAnLScsXG4gICAgU0xBU0g6ICcvJ1xufTtcbnZhciBfb2JqO1xudmFyIE5hbWVUcmFuc2Zvcm1NYXAgPSAoX29iaiA9IHt9LCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCwgJ3Njb3BlXycpLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4sICdfJyksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqLCBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNILCAnX18nKSwgX29iaik7XG52YXIgX29iajE7XG52YXIgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXAgPSAoX29iajEgPSB7fSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdLCBOYW1lVHJhbnNmb3JtU3ltYm9sLkFUKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSwgTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4pLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iajEsIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF0sIE5hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0gpLCBfb2JqMSk7XG52YXIgU0VQQVJBVE9SID0gJzonO1xudmFyIE1hbmlmZXN0RmlsZU5hbWUgPSAnbWYtbWFuaWZlc3QuanNvbic7XG52YXIgU3RhdHNGaWxlTmFtZSA9ICdtZi1zdGF0cy5qc29uJztcbnZhciBNRk1vZHVsZVR5cGUgPSB7XG4gICAgTlBNOiAnbnBtJyxcbiAgICBBUFA6ICdhcHAnXG59O1xudmFyIE1PRFVMRV9ERVZUT09MX0lERU5USUZJRVIgPSAnX19NRl9ERVZUT09MU19NT0RVTEVfSU5GT19fJztcblxudmFyIENvbnRhaW5lclBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIENvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIE1vZHVsZUZlZGVyYXRpb25QbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBTaGFyZVBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuZnVuY3Rpb24gaXNCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzRGVidWdNb2RlKCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwcm9jZXNzLmVudlsnRkVERVJBVElPTl9ERUJVRyddKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBGRURFUkFUSU9OX0RFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBCb29sZWFuKEZFREVSQVRJT05fREVCVUcpO1xufVxudmFyIGdldFByb2Nlc3NFbnYgPSBmdW5jdGlvbiBnZXRQcm9jZXNzRW52KCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgPyBwcm9jZXNzLmVudiA6IHt9O1xufTtcblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkkMihhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aG91dF9ob2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMihhcnIpO1xufVxuZnVuY3Rpb24gX2NsYXNzX2NhbGxfY2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlX2NsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDIob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheSQxKGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfc3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdG9fY29uc3VtYWJsZV9hcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXkkMShhcnIpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQyKGFycikgfHwgX25vbl9pdGVyYWJsZV9zcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQyKG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbnZhciBERUJVR19MT0cgPSAnWyBGRURFUkFUSU9OIERFQlVHIF0nO1xuZnVuY3Rpb24gc2FmZUdldExvY2FsU3RvcmFnZUl0ZW0oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShCUk9XU0VSX0xPR19LRVkpID09PSBCUk9XU0VSX0xPR19WQUxVRTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgTG9nZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIoaWRlbnRpZmllcikge1xuICAgICAgICBfY2xhc3NfY2FsbF9jaGVjayh0aGlzLCBMb2dnZXIpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDIodGhpcywgXCJlbmFibGVcIiwgZmFsc2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDIodGhpcywgXCJpZGVudGlmaWVyXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXIgfHwgREVCVUdfTE9HO1xuICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkgJiYgc2FmZUdldExvY2FsU3RvcmFnZUl0ZW0oKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVidWdNb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKExvZ2dlciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8obXNnLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzVG9TdHJpbmcgPSBzYWZlVG9TdHJpbmcoaW5mbykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IFwiKS5jb25jYXQobXNnLCBcIiBcIikuY29uY2F0KGFyZ3NUb1N0cmluZyksICdjb2xvcjojMzMwMENDJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1xceDFiWzM0bSVzJywgXCJcIi5jb25jYXQodGhpcy5pZGVudGlmaWVyLCBcIjogXCIpLmNvbmNhdChtc2csIFwiIFwiKS5jb25jYXQoYXJnc1RvU3RyaW5nID8gXCJcXG5cIi5jb25jYXQoYXJnc1RvU3RyaW5nKSA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsb2dPcmlnaW5hbEluZm9cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dPcmlnaW5hbEluZm8oKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnNvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIlYyBcIi5jb25jYXQodGhpcy5pZGVudGlmaWVyLCBcIjogT3JpZ2luYWxJbmZvXCIpLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBfdG9fY29uc3VtYWJsZV9hcnJheShhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnNvbGUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IE9yaWdpbmFsSW5mb1wiKSwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfY29uc29sZTEgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUxLCBfdG9fY29uc3VtYWJsZV9hcnJheShhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpO1xuXG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheSQxKGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9hcnJheV93aXRoX2hvbGVzJDEoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQkMShhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9zLCBfZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpe1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Fycjtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfcmVzdCQxKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRfdG9fYXJyYXkkMShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMkMShhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheV9saW1pdCQxKGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyLCBpKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpO1xufVxuZnVuY3Rpb24gX3RvX2FycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlfd2l0aF9ob2xlcyQxKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShvLCBtaW5MZW4pO1xufVxudmFyIExPR19DQVRFR09SWSA9ICdbIEZlZGVyYXRpb24gUnVudGltZSBdJztcbi8vIGVudHJ5OiBuYW1lOnZlcnNpb24gICB2ZXJzaW9uIDogMS4wLjAgfCBeMS4yLjNcbi8vIGVudHJ5OiBuYW1lOmVudHJ5ICBlbnRyeTogIGh0dHBzOi8vbG9jYWxob3N0OjkwMDAvZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uXG52YXIgcGFyc2VFbnRyeSA9IGZ1bmN0aW9uKHN0ciwgZGV2VmVyT3JVcmwpIHtcbiAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBTRVBBUkFUT1I7XG4gICAgdmFyIHN0clNwbGl0ID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgdmFyIGRldlZlcnNpb25PclVybCA9IGdldFByb2Nlc3NFbnYoKVsnTk9ERV9FTlYnXSA9PT0gJ2RldmVsb3BtZW50JyAmJiBkZXZWZXJPclVybDtcbiAgICB2YXIgZGVmYXVsdFZlcnNpb24gPSAnKic7XG4gICAgdmFyIGlzRW50cnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLnN0YXJ0c1dpdGgoJ2h0dHAnKSB8fCBzLmluY2x1ZGVzKE1BTklGRVNUX0VYVCk7XG4gICAgfTtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgdHlwZVxuICAgIGlmIChzdHJTcGxpdC5sZW5ndGggPj0gMikge1xuICAgICAgICB2YXIgX3N0clNwbGl0ID0gX3RvX2FycmF5KHN0clNwbGl0KSwgbmFtZSA9IF9zdHJTcGxpdFswXSwgdmVyc2lvbk9yRW50cnlBcnIgPSBfc3RyU3BsaXQuc2xpY2UoMSk7XG4gICAgICAgIHZhciB2ZXJzaW9uT3JFbnRyeSA9IGRldlZlcnNpb25PclVybCB8fCB2ZXJzaW9uT3JFbnRyeUFyci5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpc0VudHJ5KHZlcnNpb25PckVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5OiB2ZXJzaW9uT3JFbnRyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHZlcnNpb24gcnVsZVxuICAgICAgICAgICAgLy8gZGV2VmVyc2lvbk9yVXJsID0+IGlucHV0VmVyc2lvbiA9PiBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25PckVudHJ5IHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIF9zdHJTcGxpdDEgPSBfc2xpY2VkX3RvX2FycmF5JDEoc3RyU3BsaXQsIDEpLCBuYW1lMSA9IF9zdHJTcGxpdDFbMF07XG4gICAgICAgIGlmIChkZXZWZXJzaW9uT3JVcmwgJiYgaXNFbnRyeShkZXZWZXJzaW9uT3JVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUxLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBkZXZWZXJzaW9uT3JVcmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxLFxuICAgICAgICAgICAgdmVyc2lvbjogZGV2VmVyc2lvbk9yVXJsIHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGVudHJ5IHZhbHVlOiBcIi5jb25jYXQoc3RyKTtcbiAgICB9XG59O1xudmFyIGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbnZhciBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9ICBmdW5jdGlvbiBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcigpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBjdXIpIHtcbiAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN1bSkuY29uY2F0KFNFUEFSQVRPUikuY29uY2F0KGN1cik7XG4gICAgfSwgJycpO1xufTtcbnZhciBlbmNvZGVOYW1lID0gIGZ1bmN0aW9uIGVuY29kZU5hbWUobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6ICcnLCB3aXRoRXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZXh0ID0gd2l0aEV4dCA/ICcuanMnIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLkFUKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSkucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSkpLmNvbmNhdChleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbnZhciBkZWNvZGVOYW1lID0gIGZ1bmN0aW9uIGRlY29kZU5hbWUobmFtZSwgcHJlZml4LCB3aXRoRXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRlY29kZWROYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKCFkZWNvZGVkTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChwcmVmaXgsICdnJyksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdKSwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdKSwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXSk7XG4gICAgICAgIGlmICh3aXRoRXh0KSB7XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UoJy5qcycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xudmFyIGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUgPSAgZnVuY3Rpb24oZXhwb3NlTmFtZSwgd2l0aEV4dCkge1xuICAgIGlmICghZXhwb3NlTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBleHBvc2UgPSBleHBvc2VOYW1lO1xuICAgIGlmIChleHBvc2UgPT09ICcuJykge1xuICAgICAgICBleHBvc2UgPSAnZGVmYXVsdF9leHBvcnQnO1xuICAgIH1cbiAgICBpZiAoZXhwb3NlLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgZXhwb3NlID0gZXhwb3NlLnJlcGxhY2UoJy4vJywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlTmFtZShleHBvc2UsICdfX2ZlZGVyYXRpb25fZXhwb3NlXycsIHdpdGhFeHQpO1xufTtcbnZhciBnZW5lcmF0ZVNoYXJlRmlsZW5hbWUgPSAgZnVuY3Rpb24ocGtnTmFtZSwgd2l0aEV4dCkge1xuICAgIGlmICghcGtnTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKHBrZ05hbWUsICdfX2ZlZGVyYXRpb25fc2hhcmVkXycsIHdpdGhFeHQpO1xufTtcbnZhciBnZXRSZXNvdXJjZVVybCA9IGZ1bmN0aW9uKG1vZHVsZSwgc291cmNlVXJsKSB7XG4gICAgaWYgKCdnZXRQdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24obW9kdWxlLmdldFB1YmxpY1BhdGgpKCk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwdWJsaWNQYXRoKS5jb25jYXQoc291cmNlVXJsKTtcbiAgICB9IGVsc2UgaWYgKCdwdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1vZHVsZS5wdWJsaWNQYXRoKS5jb25jYXQoc291cmNlVXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbiBub3QgZ2V0IHJlc291cmNlIHVybCwgaWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZScsIG1vZHVsZSwgc291cmNlVXJsKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xudmFyIGFzc2VydCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZXJyb3IobXNnKTtcbiAgICB9XG59O1xudmFyIGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KExPR19DQVRFR09SWSwgXCI6IFwiKS5jb25jYXQobXNnKSk7XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbihtc2cpIHtcbiAgICBjb25zb2xlLndhcm4oXCJcIi5jb25jYXQoTE9HX0NBVEVHT1JZLCBcIjogXCIpLmNvbmNhdChtc2cpKTtcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkkMShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWQkMSh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVfcHJvcGVydHkkMSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICAgICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWRfcHJvcHModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UgIT0gbnVsbCA/IHNvdXJjZSA6IHt9O1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG52YXIgc2ltcGxlSm9pblJlbW90ZUVudHJ5ID0gZnVuY3Rpb24oclBhdGgsIHJOYW1lKSB7XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1QYXRoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCcuLycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgdmFyIHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgdmFyIHRyYW5zZm9ybWVkUGF0aCA9IHRyYW5zZm9ybVBhdGgoclBhdGgpO1xuICAgIGlmICghdHJhbnNmb3JtZWRQYXRoKSB7XG4gICAgICAgIHJldHVybiByTmFtZTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybWVkUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0cmFuc2Zvcm1lZFBhdGgpLmNvbmNhdChyTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0cmFuc2Zvcm1lZFBhdGgsIFwiL1wiKS5jb25jYXQock5hbWUpO1xufTtcbmZ1bmN0aW9uIGluZmVyQXV0b1B1YmxpY1BhdGgodXJsKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC8jLiokLywgJycpLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcvJyk7XG59XG4vLyBQcmlvcml0eTogb3ZlcnJpZGVzID4gcmVtb3Rlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmZ1bmN0aW9uIGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YSwgX21hbmlmZXN0X21ldGFEYXRhMTtcbiAgICB2YXIgX29wdGlvbnNfcmVtb3RlcyA9IG9wdGlvbnMucmVtb3RlcywgcmVtb3RlcyA9IF9vcHRpb25zX3JlbW90ZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfcmVtb3RlcywgX29wdGlvbnNfb3ZlcnJpZGVzID0gb3B0aW9ucy5vdmVycmlkZXMsIG92ZXJyaWRlcyA9IF9vcHRpb25zX292ZXJyaWRlcyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19vdmVycmlkZXMsIHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgdmFyIHJlbW90ZVNuYXBzaG90O1xuICAgIHZhciBnZXRQdWJsaWNQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb3ZlcnJpZGVzS2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcyk7XG4gICAgdmFyIHJlbW90ZXNJbmZvID0ge307XG4gICAgLy8gSWYgcmVtb3RlcyBhcmUgbm90IHByb3ZpZGVkLCBvbmx5IHRoZSByZW1vdGVzIGluIHRoZSBtYW5pZmVzdCB3aWxsIGJlIHJlYWRcbiAgICBpZiAoIU9iamVjdC5rZXlzKHJlbW90ZXMpLmxlbmd0aCkge1xuICAgICAgICB2YXIgX21hbmlmZXN0X3JlbW90ZXM7XG4gICAgICAgIHJlbW90ZXNJbmZvID0gKChfbWFuaWZlc3RfcmVtb3RlcyA9IG1hbmlmZXN0LnJlbW90ZXMpID09PSBudWxsIHx8IF9tYW5pZmVzdF9yZW1vdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWFuaWZlc3RfcmVtb3Rlcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZFZlcnNpb247XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uOiBtYXRjaGVkVmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHt9KSkgfHwge307XG4gICAgfVxuICAgIC8vIElmIHJlbW90ZXMgKGRlcGxveSBzY2VuYXJpbykgYXJlIHNwZWNpZmllZCwgdGhleSBuZWVkIHRvIGJlIHRyYXZlcnNlZCBhZ2FpblxuICAgIE9iamVjdC5rZXlzKHJlbW90ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiByZW1vdGVzSW5mb1trZXldID0ge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVzIHdpbGwgb3ZlcnJpZGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogb3ZlcnJpZGVzS2V5cy5pbmNsdWRlcyhrZXkpID8gb3ZlcnJpZGVzW2tleV0gOiByZW1vdGVzW2tleV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhMiA9IG1hbmlmZXN0Lm1ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkgPSBfbWFuaWZlc3RfbWV0YURhdGEyLnJlbW90ZUVudHJ5LCByZW1vdGVFbnRyeVBhdGggPSBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkucGF0aCwgcmVtb3RlRW50cnlOYW1lID0gX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5Lm5hbWUsIHJlbW90ZUVudHJ5VHlwZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9yZW1vdGVFbnRyeS50eXBlLCByZW1vdGVUeXBlcyA9IF9tYW5pZmVzdF9tZXRhRGF0YTIudHlwZXMsIGJ1aWxkVmVyc2lvbiA9IF9tYW5pZmVzdF9tZXRhRGF0YTIuYnVpbGRJbmZvLmJ1aWxkVmVyc2lvbiwgZ2xvYmFsTmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YTIuZ2xvYmFsTmFtZTtcbiAgICB2YXIgZXhwb3NlcyA9IG1hbmlmZXN0LmV4cG9zZXM7XG4gICAgdmFyIGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbjogYnVpbGRWZXJzaW9uLFxuICAgICAgICBnbG9iYWxOYW1lOiBnbG9iYWxOYW1lLFxuICAgICAgICByZW1vdGVFbnRyeTogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHJlbW90ZUVudHJ5UGF0aCwgcmVtb3RlRW50cnlOYW1lKSxcbiAgICAgICAgcmVtb3RlRW50cnlUeXBlOiByZW1vdGVFbnRyeVR5cGUsXG4gICAgICAgIHJlbW90ZVR5cGVzOiBzaW1wbGVKb2luUmVtb3RlRW50cnkocmVtb3RlVHlwZXMucGF0aCwgcmVtb3RlVHlwZXMubmFtZSksXG4gICAgICAgIHJlbW90ZVR5cGVzWmlwOiByZW1vdGVUeXBlcy56aXAgfHwgJycsXG4gICAgICAgIHJlbW90ZVR5cGVzQVBJOiByZW1vdGVUeXBlcy5hcGkgfHwgJycsXG4gICAgICAgIHJlbW90ZXNJbmZvOiByZW1vdGVzSW5mbyxcbiAgICAgICAgc2hhcmVkOiBtYW5pZmVzdCA9PT0gbnVsbCB8fCBtYW5pZmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFuaWZlc3Quc2hhcmVkLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIG1vZHVsZXM6IGV4cG9zZXMgPT09IG51bGwgfHwgZXhwb3NlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwb3Nlcy5tYXAoZnVuY3Rpb24oZXhwb3NlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IGV4cG9zZS5uYW1lLFxuICAgICAgICAgICAgICAgIG1vZHVsZVBhdGg6IGV4cG9zZS5wYXRoLFxuICAgICAgICAgICAgICAgIGFzc2V0czogZXhwb3NlLmFzc2V0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICB9O1xuICAgIGlmICgoX21hbmlmZXN0X21ldGFEYXRhID0gbWFuaWZlc3QubWV0YURhdGEpID09PSBudWxsIHx8IF9tYW5pZmVzdF9tZXRhRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hbmlmZXN0X21ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHByZWZldGNoSW50ZXJmYWNlOiBwcmVmZXRjaEludGVyZmFjZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGExID0gbWFuaWZlc3QubWV0YURhdGEpID09PSBudWxsIHx8IF9tYW5pZmVzdF9tZXRhRGF0YTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YTEucHJlZmV0Y2hFbnRyeSkge1xuICAgICAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkgPSBtYW5pZmVzdC5tZXRhRGF0YS5wcmVmZXRjaEVudHJ5LCBwYXRoID0gX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkucGF0aCwgbmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5Lm5hbWUsIHR5cGUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcHJlZmV0Y2hFbnRyeS50eXBlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHByZWZldGNoRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShwYXRoLCBuYW1lKSxcbiAgICAgICAgICAgIHByZWZldGNoRW50cnlUeXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJ3B1YmxpY1BhdGgnIGluIG1hbmlmZXN0Lm1ldGFEYXRhKSB7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGg6IGdldFB1YmxpY1BhdGgoKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBnZXRQdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIGlzTWFuaWZlc3RQcm92aWRlcihtb2R1bGVJbmZvKSB7XG4gICAgaWYgKCdyZW1vdGVFbnRyeScgaW4gbW9kdWxlSW5mbyAmJiBtb2R1bGVJbmZvLnJlbW90ZUVudHJ5LmluY2x1ZGVzKE1BTklGRVNUX0VYVCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvciQxKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXSkge1xuICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvciQxKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2FmZVdyYXBwZXIoY2FsbGJhY2ssIGRpc2FibGVXYXJuKSB7XG4gICAgcmV0dXJuIF9zYWZlV3JhcHBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3NhZmVXcmFwcGVyKCkge1xuICAgIF9zYWZlV3JhcHBlciA9IF9hc3luY190b19nZW5lcmF0b3IkMShmdW5jdGlvbihjYWxsYmFjaywgZGlzYWJsZVdhcm4pIHtcbiAgICAgICAgdmFyIHJlcywgZTtcbiAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAhZGlzYWJsZVdhcm4gJiYgd2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBfc2FmZVdyYXBwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwodXJsMSwgdXJsMikge1xuICAgIHZhciBSRUdfRVhQID0gL14oaHR0cHM/Oik/XFwvXFwvL2k7XG4gICAgLy8gVHJhbnNmb3JtIHVybDEgYW5kIHVybDIgaW50byByZWxhdGl2ZSBwYXRoc1xuICAgIHZhciByZWxhdGl2ZVVybDEgPSB1cmwxLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgdmFyIHJlbGF0aXZlVXJsMiA9IHVybDIucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVsYXRpdmUgcGF0aHMgYXJlIGlkZW50aWNhbFxuICAgIHJldHVybiByZWxhdGl2ZVVybDEgPT09IHJlbGF0aXZlVXJsMjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjcmlwdCh1cmwsIGNiLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vaykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIHZhciBzY3JpcHQgPSBudWxsO1xuICAgIHZhciBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICB2YXIgdGltZW91dCA9IDIwMDAwO1xuICAgIHZhciB0aW1lb3V0SWQ7XG4gICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHNjcmlwdHNbaV07XG4gICAgICAgIHZhciBzY3JpcHRTcmMgPSBzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIGlmIChzY3JpcHRTcmMgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChzY3JpcHRTcmMsIHVybCkpIHtcbiAgICAgICAgICAgIHNjcmlwdCA9IHM7XG4gICAgICAgICAgICBuZWVkQXR0YWNoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVTY3JpcHRSZXMgPSBjcmVhdGVTY3JpcHRIb29rKHVybCk7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YoY3JlYXRlU2NyaXB0UmVzLCBIVE1MU2NyaXB0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVTY3JpcHRSZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQpIHNjcmlwdCA9IGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0KSB0aW1lb3V0ID0gY3JlYXRlU2NyaXB0UmVzLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2FzeW5jJyB8fCBuYW1lID09PSAnZGVmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdFtuYW1lXSA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBvblNjcmlwdENvbXBsZXRlID0gZnVuY3Rpb24ocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUUuXG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc2FmZVdyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgKHNjcmlwdCA9PT0gbnVsbCB8fCBzY3JpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmlwdC5wYXJlbnROb2RlKSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHByZXYoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25TY3JpcHRDb21wbGV0ZShudWxsLCBuZXcgRXJyb3IoJ1JlbW90ZSBzY3JpcHQgXCInLmNvbmNhdCh1cmwsICdcIiB0aW1lLW91dGVkLicpKSk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgICAgIG5lZWRBdHRhY2g6IG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGluayh1cmwsIGNiKSB7XG4gICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgY3JlYXRlTGlua0hvb2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHZvaWQgMDtcbiAgICAvLyA8bGluayByZWw9XCJwcmVsb2FkXCIgaHJlZj1cInNjcmlwdC5qc1wiIGFzPVwic2NyaXB0XCI+XG4gICAgLy8gUmV0cmlldmUgdGhlIGV4aXN0aW5nIHNjcmlwdCBlbGVtZW50IGJ5IGl0cyBzcmMgYXR0cmlidXRlXG4gICAgdmFyIGxpbmsgPSBudWxsO1xuICAgIHZhciBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICB2YXIgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsID0gbGlua3NbaV07XG4gICAgICAgIHZhciBsaW5rSHJlZiA9IGwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIHZhciBsaW5rUmVmID0gbC5nZXRBdHRyaWJ1dGUoJ3JlZicpO1xuICAgICAgICBpZiAobGlua0hyZWYgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChsaW5rSHJlZiwgdXJsKSAmJiBsaW5rUmVmID09PSBhdHRyc1sncmVmJ10pIHtcbiAgICAgICAgICAgIGxpbmsgPSBsO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJywgJ2Fub255bW91cycpO1xuICAgICAgICBpZiAoY3JlYXRlTGlua0hvb2spIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVMaW5rUmVzID0gY3JlYXRlTGlua0hvb2sodXJsKTtcbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZihjcmVhdGVMaW5rUmVzLCBIVE1MTGlua0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IGNyZWF0ZUxpbmtSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIG9uTGlua0NvbXBsZXRlID0gZnVuY3Rpb24ocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCkge1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAobGluayA9PT0gbnVsbCB8fCBsaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5rLnBhcmVudE5vZGUpICYmIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIGxpbmsub25lcnJvciA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmVycm9yKTtcbiAgICBsaW5rLm9ubG9hZCA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmxvYWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbms6IGxpbmssXG4gICAgICAgIG5lZWRBdHRhY2g6IG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmwsIGluZm8pIHtcbiAgICB2YXIgYXR0cnMgPSBpbmZvLmF0dHJzLCBjcmVhdGVTY3JpcHRIb29rID0gaW5mby5jcmVhdGVTY3JpcHRIb29rO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCBfcmVqZWN0KSB7XG4gICAgICAgIHZhciBfY3JlYXRlU2NyaXB0ID0gY3JlYXRlU2NyaXB0KHVybCwgcmVzb2x2ZSwgYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2spLCBzY3JpcHQgPSBfY3JlYXRlU2NyaXB0LnNjcmlwdCwgbmVlZEF0dGFjaCA9IF9jcmVhdGVTY3JpcHQubmVlZEF0dGFjaDtcbiAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9hcnJheV93aXRoX2hvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfcywgX2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKXtcbiAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hcnI7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3Jlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NsaWNlZF90b19hcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkoYXJyLCBpKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBmLCB5LCB0LCBnLCBfID0ge1xuICAgICAgICBsYWJlbDogMCxcbiAgICAgICAgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ5czogW10sXG4gICAgICAgIG9wczogW11cbiAgICB9O1xuICAgIHJldHVybiBnID0ge1xuICAgICAgICBuZXh0OiB2ZXJiKDApLFxuICAgICAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgICB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUoXyl0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtcbiAgICAgICAgICAgICAgICBvcFswXSAmIDIsXG4gICAgICAgICAgICAgICAgdC52YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHN3aXRjaChvcFswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGltcG9ydE5vZGVNb2R1bGUobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9ydCBzcGVjaWZpZXIgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgdmFyIGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbignbmFtZScsIFwicmV0dXJuIGltcG9ydChuYW1lKVwiKTtcbiAgICByZXR1cm4gaW1wb3J0TW9kdWxlKG5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiByZXMuZGVmYXVsdDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSBcIi5jb25jYXQobmFtZSwgXCI6XCIpLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NyaXB0Tm9kZSh1cmwsIGNiLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vaykge1xuICAgIGlmIChjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgIHZhciBob29rUmVzdWx0ID0gY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgICAgICBpZiAoaG9va1Jlc3VsdCAmJiB0eXBlb2YgaG9va1Jlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3VybCcgaW4gaG9va1Jlc3VsdCkge1xuICAgICAgICAgICAgdXJsID0gaG9va1Jlc3VsdC51cmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVybE9iajtcbiAgICB0cnkge1xuICAgICAgICB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb25zdHJ1Y3RpbmcgVVJMOicsIGUpO1xuICAgICAgICBjYihuZXcgRXJyb3IoXCJJbnZhbGlkIFVSTDogXCIuY29uY2F0KGUpKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdldEZldGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaE1vZHVsZTtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgnbm9kZS1mZXRjaCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE1vZHVsZSA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmV0Y2hNb2R1bGUgPT09IG51bGwgfHwgZmV0Y2hNb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoTW9kdWxlLmRlZmF1bHQpIHx8IGZldGNoTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSgpO1xuICAgIGNvbnNvbGUubG9nKCdmZXRjaGluZycsIHVybE9iai5ocmVmKTtcbiAgICBnZXRGZXRjaCgpLnRoZW4oZnVuY3Rpb24oZikge1xuICAgICAgICBmKHVybE9iai5ocmVmKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmLCBwYXRoLCB2bSwgc2NyaXB0Q29udGV4dCwgdXJsRGlybmFtZSwgZmlsZW5hbWUsIHNjcmlwdCwgZXhwb3J0ZWRJbnRlcmZhY2UsIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgncGF0aCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9zbGljZWRfdG9fYXJyYXkuYXBwbHkodm9pZCAwLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgcGF0aCA9IF9yZWZbMF0sIHZtID0gX3JlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxEaXJuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUodXJsT2JqLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBuZXcgdm0uU2NyaXB0KFwiKGZ1bmN0aW9uKGV4cG9ydHMsIG1vZHVsZSwgcmVxdWlyZSwgX19kaXJuYW1lLCBfX2ZpbGVuYW1lKSB7XCIuY29uY2F0KGRhdGEsIFwiXFxufSlcIiksIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnJ1bkluVGhpc0NvbnRleHQoKShzY3JpcHRDb250ZXh0LmV4cG9ydHMsIHNjcmlwdENvbnRleHQubW9kdWxlLCBldmFsKCdyZXF1aXJlJyksIHVybERpcm5hbWUsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRJbnRlcmZhY2UgPSBzY3JpcHRDb250ZXh0Lm1vZHVsZS5leHBvcnRzIHx8IHNjcmlwdENvbnRleHQuZXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzICYmIGV4cG9ydGVkSW50ZXJmYWNlICYmIGF0dHJzWydnbG9iYWxOYW1lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGV4cG9ydGVkSW50ZXJmYWNlW2F0dHJzWydnbG9iYWxOYW1lJ11dIHx8IGV4cG9ydGVkSW50ZXJmYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignRXJyb3IgcnVubmluZyBzY3JpcHQ6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBFcnJvcihcIlNjcmlwdCBleGVjdXRpb24gZXJyb3I6IFwiLmNvbmNhdChlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCkpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc2NyaXB0OicsIGVycik7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxvYWRTY3JpcHROb2RlKHVybCwgaW5mbykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY3JlYXRlU2NyaXB0Tm9kZSh1cmwsIGZ1bmN0aW9uKGVycm9yLCBzY3JpcHRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlRW50cnlLZXkgPSAoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PT0gbnVsbCB8fCBfaW5mb19hdHRycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgXCJfX0ZFREVSQVRJT05fXCIuY29uY2F0KGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9pbmZvX2F0dHJzMSA9IGluZm8uYXR0cnMpID09PSBudWxsIHx8IF9pbmZvX2F0dHJzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ10sIFwiOmN1c3RvbV9fXCIpO1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmNyZWF0ZVNjcmlwdEhvb2spO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfdHlwZV9vZihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhlbmFibGVEZWZhdWx0LCBkZWZhdWx0T3B0aW9ucywga2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3Rfc3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0eXBlIGZvciBgXCIuY29uY2F0KGtleSwgXCJgLCBleHBlY3QgYm9vbGVhbi91bmRlZmluZWQvb2JqZWN0LCBnb3Q6IFwiKS5jb25jYXQodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yob3B0aW9ucykpKTtcbiAgICB9O1xufVxuXG5leHBvcnRzLkJST1dTRVJfTE9HX0tFWSA9IEJST1dTRVJfTE9HX0tFWTtcbmV4cG9ydHMuQlJPV1NFUl9MT0dfVkFMVUUgPSBCUk9XU0VSX0xPR19WQUxVRTtcbmV4cG9ydHMuRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXAgPSBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcDtcbmV4cG9ydHMuRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0ID0gRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0O1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG5leHBvcnRzLk1BTklGRVNUX0VYVCA9IE1BTklGRVNUX0VYVDtcbmV4cG9ydHMuTUZNb2R1bGVUeXBlID0gTUZNb2R1bGVUeXBlO1xuZXhwb3J0cy5NT0RVTEVfREVWVE9PTF9JREVOVElGSUVSID0gTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUjtcbmV4cG9ydHMuTWFuaWZlc3RGaWxlTmFtZSA9IE1hbmlmZXN0RmlsZU5hbWU7XG5leHBvcnRzLk5hbWVUcmFuc2Zvcm1NYXAgPSBOYW1lVHJhbnNmb3JtTWFwO1xuZXhwb3J0cy5OYW1lVHJhbnNmb3JtU3ltYm9sID0gTmFtZVRyYW5zZm9ybVN5bWJvbDtcbmV4cG9ydHMuU0VQQVJBVE9SID0gU0VQQVJBVE9SO1xuZXhwb3J0cy5TdGF0c0ZpbGVOYW1lID0gU3RhdHNGaWxlTmFtZTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5jb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9IGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yO1xuZXhwb3J0cy5jb250YWluZXJQbHVnaW4gPSBDb250YWluZXJQbHVnaW47XG5leHBvcnRzLmNvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiA9IENvbnRhaW5lclJlZmVyZW5jZVBsdWdpbjtcbmV4cG9ydHMuY3JlYXRlTGluayA9IGNyZWF0ZUxpbms7XG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGNyZWF0ZVNjcmlwdDtcbmV4cG9ydHMuY3JlYXRlU2NyaXB0Tm9kZSA9IGNyZWF0ZVNjcmlwdE5vZGU7XG5leHBvcnRzLmRlY29kZU5hbWUgPSBkZWNvZGVOYW1lO1xuZXhwb3J0cy5lbmNvZGVOYW1lID0gZW5jb2RlTmFtZTtcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMuZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZSA9IGdlbmVyYXRlRXhwb3NlRmlsZW5hbWU7XG5leHBvcnRzLmdlbmVyYXRlU2hhcmVGaWxlbmFtZSA9IGdlbmVyYXRlU2hhcmVGaWxlbmFtZTtcbmV4cG9ydHMuZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCA9IGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3Q7XG5leHBvcnRzLmdldFByb2Nlc3NFbnYgPSBnZXRQcm9jZXNzRW52O1xuZXhwb3J0cy5nZXRSZXNvdXJjZVVybCA9IGdldFJlc291cmNlVXJsO1xuZXhwb3J0cy5pbmZlckF1dG9QdWJsaWNQYXRoID0gaW5mZXJBdXRvUHVibGljUGF0aDtcbmV4cG9ydHMuaXNCcm93c2VyRW52ID0gaXNCcm93c2VyRW52O1xuZXhwb3J0cy5pc0RlYnVnTW9kZSA9IGlzRGVidWdNb2RlO1xuZXhwb3J0cy5pc01hbmlmZXN0UHJvdmlkZXIgPSBpc01hbmlmZXN0UHJvdmlkZXI7XG5leHBvcnRzLmlzU3RhdGljUmVzb3VyY2VzRXF1YWwgPSBpc1N0YXRpY1Jlc291cmNlc0VxdWFsO1xuZXhwb3J0cy5sb2FkU2NyaXB0ID0gbG9hZFNjcmlwdDtcbmV4cG9ydHMubG9hZFNjcmlwdE5vZGUgPSBsb2FkU2NyaXB0Tm9kZTtcbmV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyO1xuZXhwb3J0cy5tb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gTW9kdWxlRmVkZXJhdGlvblBsdWdpbjtcbmV4cG9ydHMubm9ybWFsaXplT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnM7XG5leHBvcnRzLnBhcnNlRW50cnkgPSBwYXJzZUVudHJ5O1xuZXhwb3J0cy5zYWZlV3JhcHBlciA9IHNhZmVXcmFwcGVyO1xuZXhwb3J0cy5zaGFyZVBsdWdpbiA9IFNoYXJlUGx1Z2luO1xuZXhwb3J0cy5zaW1wbGVKb2luUmVtb3RlRW50cnkgPSBzaW1wbGVKb2luUmVtb3RlRW50cnk7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.cjs.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.esm.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROWSER_LOG_KEY: () => (/* binding */ BROWSER_LOG_KEY),\n/* harmony export */   BROWSER_LOG_VALUE: () => (/* binding */ BROWSER_LOG_VALUE),\n/* harmony export */   EncodedNameTransformMap: () => (/* binding */ EncodedNameTransformMap),\n/* harmony export */   FederationModuleManifest: () => (/* binding */ FederationModuleManifest),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MANIFEST_EXT: () => (/* binding */ MANIFEST_EXT),\n/* harmony export */   MFModuleType: () => (/* binding */ MFModuleType),\n/* harmony export */   MODULE_DEVTOOL_IDENTIFIER: () => (/* binding */ MODULE_DEVTOOL_IDENTIFIER),\n/* harmony export */   ManifestFileName: () => (/* binding */ ManifestFileName),\n/* harmony export */   NameTransformMap: () => (/* binding */ NameTransformMap),\n/* harmony export */   NameTransformSymbol: () => (/* binding */ NameTransformSymbol),\n/* harmony export */   SEPARATOR: () => (/* binding */ SEPARATOR),\n/* harmony export */   StatsFileName: () => (/* binding */ StatsFileName),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   composeKeyWithSeparator: () => (/* binding */ composeKeyWithSeparator),\n/* harmony export */   containerPlugin: () => (/* binding */ ContainerPlugin),\n/* harmony export */   containerReferencePlugin: () => (/* binding */ ContainerReferencePlugin),\n/* harmony export */   createLink: () => (/* binding */ createLink),\n/* harmony export */   createScript: () => (/* binding */ createScript),\n/* harmony export */   createScriptNode: () => (/* binding */ createScriptNode),\n/* harmony export */   decodeName: () => (/* binding */ decodeName),\n/* harmony export */   encodeName: () => (/* binding */ encodeName),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   generateExposeFilename: () => (/* binding */ generateExposeFilename),\n/* harmony export */   generateShareFilename: () => (/* binding */ generateShareFilename),\n/* harmony export */   generateSnapshotFromManifest: () => (/* binding */ generateSnapshotFromManifest),\n/* harmony export */   getProcessEnv: () => (/* binding */ getProcessEnv),\n/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl),\n/* harmony export */   inferAutoPublicPath: () => (/* binding */ inferAutoPublicPath),\n/* harmony export */   isBrowserEnv: () => (/* binding */ isBrowserEnv),\n/* harmony export */   isDebugMode: () => (/* binding */ isDebugMode),\n/* harmony export */   isManifestProvider: () => (/* binding */ isManifestProvider),\n/* harmony export */   isStaticResourcesEqual: () => (/* binding */ isStaticResourcesEqual),\n/* harmony export */   loadScript: () => (/* binding */ loadScript),\n/* harmony export */   loadScriptNode: () => (/* binding */ loadScriptNode),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   moduleFederationPlugin: () => (/* binding */ ModuleFederationPlugin),\n/* harmony export */   normalizeOptions: () => (/* binding */ normalizeOptions),\n/* harmony export */   parseEntry: () => (/* binding */ parseEntry),\n/* harmony export */   safeWrapper: () => (/* binding */ safeWrapper),\n/* harmony export */   sharePlugin: () => (/* binding */ SharePlugin),\n/* harmony export */   simpleJoinRemoteEntry: () => (/* binding */ simpleJoinRemoteEntry),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\nfunction _define_property$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar FederationModuleManifest = 'federation-manifest.json';\nvar MANIFEST_EXT = '.json';\nvar BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nvar BROWSER_LOG_VALUE = '1';\nvar NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nvar _obj;\nvar NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, 'scope_'), _define_property$3(_obj, NameTransformSymbol.HYPHEN, '_'), _define_property$3(_obj, NameTransformSymbol.SLASH, '__'), _obj);\nvar _obj1;\nvar EncodedNameTransformMap = (_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH), _obj1);\nvar SEPARATOR = ':';\nvar ManifestFileName = 'mf-manifest.json';\nvar StatsFileName = 'mf-stats.json';\nvar MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nvar MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nvar getProcessEnv = function getProcessEnv() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction _array_like_to_array$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array$2(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array$1(arr) || _unsupported_iterable_to_array$2(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);\n}\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nvar DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nvar Logger = /*#__PURE__*/ function() {\n    function Logger(identifier) {\n        _class_call_check(this, Logger);\n        _define_property$2(this, \"enable\", false);\n        _define_property$2(this, \"identifier\", void 0);\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n    _create_class(Logger, [\n        {\n            key: \"info\",\n            value: function info(msg, info) {\n                if (this.enable) {\n                    var argsToString = safeToString(info) || '';\n                    if (isBrowserEnv()) {\n                        console.info(\"%c \".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString), 'color:#3300CC');\n                    } else {\n                        console.info('\\x1b[34m%s', \"\".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString ? \"\\n\".concat(argsToString) : ''));\n                    }\n                }\n            }\n        },\n        {\n            key: \"logOriginalInfo\",\n            value: function logOriginalInfo() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (this.enable) {\n                    if (isBrowserEnv()) {\n                        var _console;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console = console).log.apply(_console, _to_consumable_array(args));\n                    } else {\n                        var _console1;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console1 = console).log.apply(_console1, _to_consumable_array(args));\n                    }\n                }\n            }\n        }\n    ]);\n    return Logger;\n}();\n\nfunction _array_like_to_array$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes$1(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit$1(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest$1() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array$1(arr, i) {\n    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$1(arr, i) || _non_iterable_rest$1();\n}\nfunction _to_array(arr) {\n    return _array_with_holes$1(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_rest$1();\n}\nfunction _unsupported_iterable_to_array$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);\n}\nvar LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nvar parseEntry = function(str, devVerOrUrl) {\n    var separator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SEPARATOR;\n    var strSplit = str.split(separator);\n    var devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    var defaultVersion = '*';\n    var isEntry = function(s) {\n        return s.startsWith('http') || s.includes(MANIFEST_EXT);\n    };\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        var _strSplit = _to_array(strSplit), name = _strSplit[0], versionOrEntryArr = _strSplit.slice(1);\n        var versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name: name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name: name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        var _strSplit1 = _sliced_to_array$1(strSplit, 1), name1 = _strSplit1[0];\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name: name1,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name: name1,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw \"Invalid entry value: \".concat(str);\n    }\n};\nvar logger = new Logger();\nvar composeKeyWithSeparator =  function composeKeyWithSeparator() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce(function(sum, cur) {\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return \"\".concat(sum).concat(SEPARATOR).concat(cur);\n    }, '');\n};\nvar encodeName =  function encodeName(name) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', withExt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        var ext = withExt ? '.js' : '';\n        return \"\".concat(prefix).concat(name.replace(new RegExp(\"\".concat(NameTransformSymbol.AT), 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(\"\".concat(NameTransformSymbol.HYPHEN), 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(\"\".concat(NameTransformSymbol.SLASH), 'g'), NameTransformMap[NameTransformSymbol.SLASH])).concat(ext);\n    } catch (err) {\n        throw err;\n    }\n};\nvar decodeName =  function decodeName(name, prefix, withExt) {\n    try {\n        var decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.AT]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.SLASH]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.HYPHEN]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nvar generateExposeFilename =  function(exposeName, withExt) {\n    if (!exposeName) {\n        return '';\n    }\n    var expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nvar generateShareFilename =  function(pkgName, withExt) {\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nvar getResourceUrl = function(module, sourceUrl) {\n    if ('getPublicPath' in module) {\n        var publicPath = new Function(module.getPublicPath)();\n        return \"\".concat(publicPath).concat(sourceUrl);\n    } else if ('publicPath' in module) {\n        return \"\".concat(module.publicPath).concat(sourceUrl);\n    } else {\n        console.warn('Can not get resource url, if in debug mode, please ignore', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar assert = function(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n};\nvar error = function(msg) {\n    throw new Error(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\nvar warn = function(msg) {\n    console.warn(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\n\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nvar simpleJoinRemoteEntry = function(rPath, rName) {\n    if (!rPath) {\n        return rName;\n    }\n    var transformPath = function(str) {\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            var strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    var transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return \"\".concat(transformedPath).concat(rName);\n    }\n    return \"\".concat(transformedPath, \"/\").concat(rName);\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _manifest_metaData, _manifest_metaData1;\n    var _options_remotes = options.remotes, remotes = _options_remotes === void 0 ? {} : _options_remotes, _options_overrides = options.overrides, overrides = _options_overrides === void 0 ? {} : _options_overrides, version = options.version;\n    var remoteSnapshot;\n    var getPublicPath = function() {\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    var overridesKeys = Object.keys(overrides);\n    var remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) === null || _manifest_remotes === void 0 ? void 0 : _manifest_remotes.reduce(function(res, next) {\n            var matchedVersion;\n            var name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion: matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach(function(key) {\n        return remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        };\n    });\n    var _manifest_metaData2 = manifest.metaData, _manifest_metaData_remoteEntry = _manifest_metaData2.remoteEntry, remoteEntryPath = _manifest_metaData_remoteEntry.path, remoteEntryName = _manifest_metaData_remoteEntry.name, remoteEntryType = _manifest_metaData_remoteEntry.type, remoteTypes = _manifest_metaData2.types, buildVersion = _manifest_metaData2.buildInfo.buildVersion, globalName = _manifest_metaData2.globalName;\n    var exposes = manifest.exposes;\n    var basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion: buildVersion,\n        globalName: globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType: remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo: remotesInfo,\n        shared: manifest === null || manifest === void 0 ? void 0 : manifest.shared.map(function(item) {\n            return {\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            };\n        }),\n        modules: exposes === null || exposes === void 0 ? void 0 : exposes.map(function(expose) {\n            return {\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            };\n        })\n    };\n    if ((_manifest_metaData = manifest.metaData) === null || _manifest_metaData === void 0 ? void 0 : _manifest_metaData.prefetchInterface) {\n        var prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchInterface: prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) === null || _manifest_metaData1 === void 0 ? void 0 : _manifest_metaData1.prefetchEntry) {\n        var _manifest_metaData_prefetchEntry = manifest.metaData.prefetchEntry, path = _manifest_metaData_prefetchEntry.path, name = _manifest_metaData_prefetchEntry.name, type = _manifest_metaData_prefetchEntry.type;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            getPublicPath: getPublicPath()\n        });\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator$1(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _ts_generator$1(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeWrapper(callback, disableWarn) {\n    return _safeWrapper.apply(this, arguments);\n}\nfunction _safeWrapper() {\n    _safeWrapper = _async_to_generator$1(function(callback, disableWarn) {\n        var res, e;\n        return _ts_generator$1(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        callback()\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res\n                    ];\n                case 2:\n                    e = _state.sent();\n                    !disableWarn && warn(e);\n                    return [\n                        2\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _safeWrapper.apply(this, arguments);\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    var REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    var relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    var relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(url, cb, attrs, createScriptHook) {\n    // Retrieve the existing script element by its src attribute\n    var script = null;\n    var needAttach = true;\n    var timeout = 20000;\n    var timeoutId;\n    var scripts = document.getElementsByTagName('script');\n    for(var i = 0; i < scripts.length; i++){\n        var s = scripts[i];\n        var scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        if (createScriptHook) {\n            var createScriptRes = createScriptHook(url);\n            if (_instanceof(createScriptRes, HTMLScriptElement)) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if (createScriptRes.script) script = createScriptRes.script;\n                if (createScriptRes.timeout) timeout = createScriptRes.timeout;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (script) {\n                if (name === 'async' || name === 'defer') {\n                    script[name] = attrs[name];\n                } else {\n                    script.setAttribute(name, attrs[name]);\n                }\n            }\n        });\n    }\n    var onScriptComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(function() {\n                (script === null || script === void 0 ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(function() {\n        onScriptComplete(null, new Error('Remote script \"'.concat(url, '\" time-outed.')));\n    }, timeout);\n    return {\n        script: script,\n        needAttach: needAttach\n    };\n}\nfunction createLink(url, cb) {\n    var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, createLinkHook = arguments.length > 3 ? arguments[3] : void 0;\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    var link = null;\n    var needAttach = true;\n    var links = document.getElementsByTagName('link');\n    for(var i = 0; i < links.length; i++){\n        var l = links[i];\n        var linkHref = l.getAttribute('href');\n        var linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, url) && linkRef === attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', url);\n        link.setAttribute('crossorigin', 'anonymous');\n        if (createLinkHook) {\n            var createLinkRes = createLinkHook(url);\n            if (_instanceof(createLinkRes, HTMLLinkElement)) {\n                link = createLinkRes;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (link) {\n                link.setAttribute(name, attrs[name]);\n            }\n        });\n    }\n    var onLinkComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(function() {\n                (link === null || link === void 0 ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link: link,\n        needAttach: needAttach\n    };\n}\nfunction loadScript(url, info) {\n    var attrs = info.attrs, createScriptHook = info.createScriptHook;\n    return new Promise(function(resolve, _reject) {\n        var _createScript = createScript(url, resolve, attrs, createScriptHook), script = _createScript.script, needAttach = _createScript.needAttach;\n        needAttach && document.getElementsByTagName('head')[0].appendChild(script);\n    });\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    var importModule = new Function('name', \"return import(name)\");\n    return importModule(name).then(function(res) {\n        return res.default;\n    }).catch(function(error) {\n        console.error(\"Error importing module \".concat(name, \":\"), error);\n        throw error;\n    });\n}\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        var hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    var urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(\"Invalid URL: \".concat(e)));\n        return;\n    }\n    var getFetch = function() {\n        var _ref = _async_to_generator(function() {\n            var fetchModule;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!(typeof fetch === 'undefined')) return [\n                            3,\n                            2\n                        ];\n                        return [\n                            4,\n                            importNodeModule('node-fetch')\n                        ];\n                    case 1:\n                        fetchModule = _state.sent();\n                        //@ts-ignore\n                        return [\n                            2,\n                            (fetchModule === null || fetchModule === void 0 ? void 0 : fetchModule.default) || fetchModule\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            fetch\n                        ];\n                    case 3:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n        return function getFetch() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    console.log('fetching', urlObj.href);\n    getFetch().then(function(f) {\n        f(urlObj.href).then(function(res) {\n            return res.text();\n        }).then(function() {\n            var _ref = _async_to_generator(function(data) {\n                var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                Promise.all([\n                                    importNodeModule('path'),\n                                    importNodeModule('vm')\n                                ])\n                            ];\n                        case 1:\n                            _ref = _sliced_to_array.apply(void 0, [\n                                _state.sent(),\n                                2\n                            ]), path = _ref[0], vm = _ref[1];\n                            scriptContext = {\n                                exports: {},\n                                module: {\n                                    exports: {}\n                                }\n                            };\n                            urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n                            filename = path.basename(urlObj.pathname);\n                            try {\n                                script = new vm.Script(\"(function(exports, module, require, __dirname, __filename) {\".concat(data, \"\\n})\"), filename);\n                                script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n                                exportedInterface = scriptContext.module.exports || scriptContext.exports;\n                                if (attrs && exportedInterface && attrs['globalName']) {\n                                    container = exportedInterface[attrs['globalName']] || exportedInterface;\n                                    cb(undefined, container);\n                                    return [\n                                        2\n                                    ];\n                                }\n                                cb(undefined, exportedInterface);\n                            } catch (e) {\n                                // console.error('Error running script:', e);\n                                cb(new Error(\"Script execution error: \".concat(e)));\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function(data) {\n                return _ref.apply(this, arguments);\n            };\n        }()).catch(function(err) {\n            // console.error('Error fetching script:', err);\n            cb(err);\n        });\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise(function(resolve, reject) {\n        createScriptNode(url, function(error, scriptContext) {\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                var remoteEntryKey = (info === null || info === void 0 ? void 0 : (_info_attrs = info.attrs) === null || _info_attrs === void 0 ? void 0 : _info_attrs['globalName']) || \"__FEDERATION_\".concat(info === null || info === void 0 ? void 0 : (_info_attrs1 = info.attrs) === null || _info_attrs1 === void 0 ? void 0 : _info_attrs1['name'], \":custom__\");\n                var entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _object_spread({}, defaultOptions, options);\n        }\n        throw new Error(\"Unexpected type for `\".concat(key, \"`, expect boolean/undefined/object, got: \").concat(typeof options === \"undefined\" ? \"undefined\" : _type_of(options)));\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3Nka0AwLjEuMTgvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsYUFBYTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsMkdBQTJHO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ04saUVBQWlFO0FBQ2pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsbUJBQW1CO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRTJ6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3Nka0AwLjEuMTgvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5lc20uanM/MGEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDMob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbnZhciBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbnZhciBNQU5JRkVTVF9FWFQgPSAnLmpzb24nO1xudmFyIEJST1dTRVJfTE9HX0tFWSA9ICdGRURFUkFUSU9OX0RFQlVHJztcbnZhciBCUk9XU0VSX0xPR19WQUxVRSA9ICcxJztcbnZhciBOYW1lVHJhbnNmb3JtU3ltYm9sID0ge1xuICAgIEFUOiAnQCcsXG4gICAgSFlQSEVOOiAnLScsXG4gICAgU0xBU0g6ICcvJ1xufTtcbnZhciBfb2JqO1xudmFyIE5hbWVUcmFuc2Zvcm1NYXAgPSAoX29iaiA9IHt9LCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCwgJ3Njb3BlXycpLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4sICdfJyksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqLCBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNILCAnX18nKSwgX29iaik7XG52YXIgX29iajE7XG52YXIgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXAgPSAoX29iajEgPSB7fSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdLCBOYW1lVHJhbnNmb3JtU3ltYm9sLkFUKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSwgTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4pLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iajEsIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF0sIE5hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0gpLCBfb2JqMSk7XG52YXIgU0VQQVJBVE9SID0gJzonO1xudmFyIE1hbmlmZXN0RmlsZU5hbWUgPSAnbWYtbWFuaWZlc3QuanNvbic7XG52YXIgU3RhdHNGaWxlTmFtZSA9ICdtZi1zdGF0cy5qc29uJztcbnZhciBNRk1vZHVsZVR5cGUgPSB7XG4gICAgTlBNOiAnbnBtJyxcbiAgICBBUFA6ICdhcHAnXG59O1xudmFyIE1PRFVMRV9ERVZUT09MX0lERU5USUZJRVIgPSAnX19NRl9ERVZUT09MU19NT0RVTEVfSU5GT19fJztcblxudmFyIENvbnRhaW5lclBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIENvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIE1vZHVsZUZlZGVyYXRpb25QbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBTaGFyZVBsdWdpbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuZnVuY3Rpb24gaXNCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzRGVidWdNb2RlKCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwcm9jZXNzLmVudlsnRkVERVJBVElPTl9ERUJVRyddKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBGRURFUkFUSU9OX0RFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBCb29sZWFuKEZFREVSQVRJT05fREVCVUcpO1xufVxudmFyIGdldFByb2Nlc3NFbnYgPSBmdW5jdGlvbiBnZXRQcm9jZXNzRW52KCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgPyBwcm9jZXNzLmVudiA6IHt9O1xufTtcblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkkMihhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aG91dF9ob2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMihhcnIpO1xufVxuZnVuY3Rpb24gX2NsYXNzX2NhbGxfY2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlX2NsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDIob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheSQxKGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfc3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdG9fY29uc3VtYWJsZV9hcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXkkMShhcnIpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQyKGFycikgfHwgX25vbl9pdGVyYWJsZV9zcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQyKG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbnZhciBERUJVR19MT0cgPSAnWyBGRURFUkFUSU9OIERFQlVHIF0nO1xuZnVuY3Rpb24gc2FmZUdldExvY2FsU3RvcmFnZUl0ZW0oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShCUk9XU0VSX0xPR19LRVkpID09PSBCUk9XU0VSX0xPR19WQUxVRTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgTG9nZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIoaWRlbnRpZmllcikge1xuICAgICAgICBfY2xhc3NfY2FsbF9jaGVjayh0aGlzLCBMb2dnZXIpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDIodGhpcywgXCJlbmFibGVcIiwgZmFsc2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDIodGhpcywgXCJpZGVudGlmaWVyXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXIgfHwgREVCVUdfTE9HO1xuICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkgJiYgc2FmZUdldExvY2FsU3RvcmFnZUl0ZW0oKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVidWdNb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKExvZ2dlciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8obXNnLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzVG9TdHJpbmcgPSBzYWZlVG9TdHJpbmcoaW5mbykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IFwiKS5jb25jYXQobXNnLCBcIiBcIikuY29uY2F0KGFyZ3NUb1N0cmluZyksICdjb2xvcjojMzMwMENDJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1xceDFiWzM0bSVzJywgXCJcIi5jb25jYXQodGhpcy5pZGVudGlmaWVyLCBcIjogXCIpLmNvbmNhdChtc2csIFwiIFwiKS5jb25jYXQoYXJnc1RvU3RyaW5nID8gXCJcXG5cIi5jb25jYXQoYXJnc1RvU3RyaW5nKSA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsb2dPcmlnaW5hbEluZm9cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dPcmlnaW5hbEluZm8oKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnNvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIlYyBcIi5jb25jYXQodGhpcy5pZGVudGlmaWVyLCBcIjogT3JpZ2luYWxJbmZvXCIpLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBfdG9fY29uc3VtYWJsZV9hcnJheShhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnNvbGUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IE9yaWdpbmFsSW5mb1wiKSwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfY29uc29sZTEgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUxLCBfdG9fY29uc3VtYWJsZV9hcnJheShhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpO1xuXG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheSQxKGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9hcnJheV93aXRoX2hvbGVzJDEoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQkMShhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9zLCBfZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpe1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Fycjtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfcmVzdCQxKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRfdG9fYXJyYXkkMShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMkMShhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheV9saW1pdCQxKGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyLCBpKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpO1xufVxuZnVuY3Rpb24gX3RvX2FycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlfd2l0aF9ob2xlcyQxKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDEobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShvLCBtaW5MZW4pO1xufVxudmFyIExPR19DQVRFR09SWSA9ICdbIEZlZGVyYXRpb24gUnVudGltZSBdJztcbi8vIGVudHJ5OiBuYW1lOnZlcnNpb24gICB2ZXJzaW9uIDogMS4wLjAgfCBeMS4yLjNcbi8vIGVudHJ5OiBuYW1lOmVudHJ5ICBlbnRyeTogIGh0dHBzOi8vbG9jYWxob3N0OjkwMDAvZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uXG52YXIgcGFyc2VFbnRyeSA9IGZ1bmN0aW9uKHN0ciwgZGV2VmVyT3JVcmwpIHtcbiAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBTRVBBUkFUT1I7XG4gICAgdmFyIHN0clNwbGl0ID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgdmFyIGRldlZlcnNpb25PclVybCA9IGdldFByb2Nlc3NFbnYoKVsnTk9ERV9FTlYnXSA9PT0gJ2RldmVsb3BtZW50JyAmJiBkZXZWZXJPclVybDtcbiAgICB2YXIgZGVmYXVsdFZlcnNpb24gPSAnKic7XG4gICAgdmFyIGlzRW50cnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLnN0YXJ0c1dpdGgoJ2h0dHAnKSB8fCBzLmluY2x1ZGVzKE1BTklGRVNUX0VYVCk7XG4gICAgfTtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgdHlwZVxuICAgIGlmIChzdHJTcGxpdC5sZW5ndGggPj0gMikge1xuICAgICAgICB2YXIgX3N0clNwbGl0ID0gX3RvX2FycmF5KHN0clNwbGl0KSwgbmFtZSA9IF9zdHJTcGxpdFswXSwgdmVyc2lvbk9yRW50cnlBcnIgPSBfc3RyU3BsaXQuc2xpY2UoMSk7XG4gICAgICAgIHZhciB2ZXJzaW9uT3JFbnRyeSA9IGRldlZlcnNpb25PclVybCB8fCB2ZXJzaW9uT3JFbnRyeUFyci5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpc0VudHJ5KHZlcnNpb25PckVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5OiB2ZXJzaW9uT3JFbnRyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHZlcnNpb24gcnVsZVxuICAgICAgICAgICAgLy8gZGV2VmVyc2lvbk9yVXJsID0+IGlucHV0VmVyc2lvbiA9PiBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25PckVudHJ5IHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIF9zdHJTcGxpdDEgPSBfc2xpY2VkX3RvX2FycmF5JDEoc3RyU3BsaXQsIDEpLCBuYW1lMSA9IF9zdHJTcGxpdDFbMF07XG4gICAgICAgIGlmIChkZXZWZXJzaW9uT3JVcmwgJiYgaXNFbnRyeShkZXZWZXJzaW9uT3JVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUxLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBkZXZWZXJzaW9uT3JVcmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxLFxuICAgICAgICAgICAgdmVyc2lvbjogZGV2VmVyc2lvbk9yVXJsIHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGVudHJ5IHZhbHVlOiBcIi5jb25jYXQoc3RyKTtcbiAgICB9XG59O1xudmFyIGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbnZhciBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9ICBmdW5jdGlvbiBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcigpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBjdXIpIHtcbiAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN1bSkuY29uY2F0KFNFUEFSQVRPUikuY29uY2F0KGN1cik7XG4gICAgfSwgJycpO1xufTtcbnZhciBlbmNvZGVOYW1lID0gIGZ1bmN0aW9uIGVuY29kZU5hbWUobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6ICcnLCB3aXRoRXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZXh0ID0gd2l0aEV4dCA/ICcuanMnIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLkFUKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSkucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIKSwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSkpLmNvbmNhdChleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbnZhciBkZWNvZGVOYW1lID0gIGZ1bmN0aW9uIGRlY29kZU5hbWUobmFtZSwgcHJlZml4LCB3aXRoRXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRlY29kZWROYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKCFkZWNvZGVkTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChwcmVmaXgsICdnJyksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdKSwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdKSwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXSk7XG4gICAgICAgIGlmICh3aXRoRXh0KSB7XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UoJy5qcycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xudmFyIGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUgPSAgZnVuY3Rpb24oZXhwb3NlTmFtZSwgd2l0aEV4dCkge1xuICAgIGlmICghZXhwb3NlTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBleHBvc2UgPSBleHBvc2VOYW1lO1xuICAgIGlmIChleHBvc2UgPT09ICcuJykge1xuICAgICAgICBleHBvc2UgPSAnZGVmYXVsdF9leHBvcnQnO1xuICAgIH1cbiAgICBpZiAoZXhwb3NlLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgZXhwb3NlID0gZXhwb3NlLnJlcGxhY2UoJy4vJywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlTmFtZShleHBvc2UsICdfX2ZlZGVyYXRpb25fZXhwb3NlXycsIHdpdGhFeHQpO1xufTtcbnZhciBnZW5lcmF0ZVNoYXJlRmlsZW5hbWUgPSAgZnVuY3Rpb24ocGtnTmFtZSwgd2l0aEV4dCkge1xuICAgIGlmICghcGtnTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKHBrZ05hbWUsICdfX2ZlZGVyYXRpb25fc2hhcmVkXycsIHdpdGhFeHQpO1xufTtcbnZhciBnZXRSZXNvdXJjZVVybCA9IGZ1bmN0aW9uKG1vZHVsZSwgc291cmNlVXJsKSB7XG4gICAgaWYgKCdnZXRQdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24obW9kdWxlLmdldFB1YmxpY1BhdGgpKCk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwdWJsaWNQYXRoKS5jb25jYXQoc291cmNlVXJsKTtcbiAgICB9IGVsc2UgaWYgKCdwdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1vZHVsZS5wdWJsaWNQYXRoKS5jb25jYXQoc291cmNlVXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbiBub3QgZ2V0IHJlc291cmNlIHVybCwgaWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZScsIG1vZHVsZSwgc291cmNlVXJsKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xudmFyIGFzc2VydCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZXJyb3IobXNnKTtcbiAgICB9XG59O1xudmFyIGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KExPR19DQVRFR09SWSwgXCI6IFwiKS5jb25jYXQobXNnKSk7XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbihtc2cpIHtcbiAgICBjb25zb2xlLndhcm4oXCJcIi5jb25jYXQoTE9HX0NBVEVHT1JZLCBcIjogXCIpLmNvbmNhdChtc2cpKTtcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkkMShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWQkMSh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVfcHJvcGVydHkkMSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICAgICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWRfcHJvcHModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UgIT0gbnVsbCA/IHNvdXJjZSA6IHt9O1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG52YXIgc2ltcGxlSm9pblJlbW90ZUVudHJ5ID0gZnVuY3Rpb24oclBhdGgsIHJOYW1lKSB7XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1QYXRoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCcuLycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgdmFyIHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgdmFyIHRyYW5zZm9ybWVkUGF0aCA9IHRyYW5zZm9ybVBhdGgoclBhdGgpO1xuICAgIGlmICghdHJhbnNmb3JtZWRQYXRoKSB7XG4gICAgICAgIHJldHVybiByTmFtZTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybWVkUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0cmFuc2Zvcm1lZFBhdGgpLmNvbmNhdChyTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0cmFuc2Zvcm1lZFBhdGgsIFwiL1wiKS5jb25jYXQock5hbWUpO1xufTtcbmZ1bmN0aW9uIGluZmVyQXV0b1B1YmxpY1BhdGgodXJsKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC8jLiokLywgJycpLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcvJyk7XG59XG4vLyBQcmlvcml0eTogb3ZlcnJpZGVzID4gcmVtb3Rlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmZ1bmN0aW9uIGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YSwgX21hbmlmZXN0X21ldGFEYXRhMTtcbiAgICB2YXIgX29wdGlvbnNfcmVtb3RlcyA9IG9wdGlvbnMucmVtb3RlcywgcmVtb3RlcyA9IF9vcHRpb25zX3JlbW90ZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfcmVtb3RlcywgX29wdGlvbnNfb3ZlcnJpZGVzID0gb3B0aW9ucy5vdmVycmlkZXMsIG92ZXJyaWRlcyA9IF9vcHRpb25zX292ZXJyaWRlcyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19vdmVycmlkZXMsIHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgdmFyIHJlbW90ZVNuYXBzaG90O1xuICAgIHZhciBnZXRQdWJsaWNQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb3ZlcnJpZGVzS2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcyk7XG4gICAgdmFyIHJlbW90ZXNJbmZvID0ge307XG4gICAgLy8gSWYgcmVtb3RlcyBhcmUgbm90IHByb3ZpZGVkLCBvbmx5IHRoZSByZW1vdGVzIGluIHRoZSBtYW5pZmVzdCB3aWxsIGJlIHJlYWRcbiAgICBpZiAoIU9iamVjdC5rZXlzKHJlbW90ZXMpLmxlbmd0aCkge1xuICAgICAgICB2YXIgX21hbmlmZXN0X3JlbW90ZXM7XG4gICAgICAgIHJlbW90ZXNJbmZvID0gKChfbWFuaWZlc3RfcmVtb3RlcyA9IG1hbmlmZXN0LnJlbW90ZXMpID09PSBudWxsIHx8IF9tYW5pZmVzdF9yZW1vdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWFuaWZlc3RfcmVtb3Rlcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZFZlcnNpb247XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uOiBtYXRjaGVkVmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHt9KSkgfHwge307XG4gICAgfVxuICAgIC8vIElmIHJlbW90ZXMgKGRlcGxveSBzY2VuYXJpbykgYXJlIHNwZWNpZmllZCwgdGhleSBuZWVkIHRvIGJlIHRyYXZlcnNlZCBhZ2FpblxuICAgIE9iamVjdC5rZXlzKHJlbW90ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiByZW1vdGVzSW5mb1trZXldID0ge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVzIHdpbGwgb3ZlcnJpZGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogb3ZlcnJpZGVzS2V5cy5pbmNsdWRlcyhrZXkpID8gb3ZlcnJpZGVzW2tleV0gOiByZW1vdGVzW2tleV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhMiA9IG1hbmlmZXN0Lm1ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkgPSBfbWFuaWZlc3RfbWV0YURhdGEyLnJlbW90ZUVudHJ5LCByZW1vdGVFbnRyeVBhdGggPSBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkucGF0aCwgcmVtb3RlRW50cnlOYW1lID0gX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5Lm5hbWUsIHJlbW90ZUVudHJ5VHlwZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9yZW1vdGVFbnRyeS50eXBlLCByZW1vdGVUeXBlcyA9IF9tYW5pZmVzdF9tZXRhRGF0YTIudHlwZXMsIGJ1aWxkVmVyc2lvbiA9IF9tYW5pZmVzdF9tZXRhRGF0YTIuYnVpbGRJbmZvLmJ1aWxkVmVyc2lvbiwgZ2xvYmFsTmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YTIuZ2xvYmFsTmFtZTtcbiAgICB2YXIgZXhwb3NlcyA9IG1hbmlmZXN0LmV4cG9zZXM7XG4gICAgdmFyIGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbjogYnVpbGRWZXJzaW9uLFxuICAgICAgICBnbG9iYWxOYW1lOiBnbG9iYWxOYW1lLFxuICAgICAgICByZW1vdGVFbnRyeTogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHJlbW90ZUVudHJ5UGF0aCwgcmVtb3RlRW50cnlOYW1lKSxcbiAgICAgICAgcmVtb3RlRW50cnlUeXBlOiByZW1vdGVFbnRyeVR5cGUsXG4gICAgICAgIHJlbW90ZVR5cGVzOiBzaW1wbGVKb2luUmVtb3RlRW50cnkocmVtb3RlVHlwZXMucGF0aCwgcmVtb3RlVHlwZXMubmFtZSksXG4gICAgICAgIHJlbW90ZVR5cGVzWmlwOiByZW1vdGVUeXBlcy56aXAgfHwgJycsXG4gICAgICAgIHJlbW90ZVR5cGVzQVBJOiByZW1vdGVUeXBlcy5hcGkgfHwgJycsXG4gICAgICAgIHJlbW90ZXNJbmZvOiByZW1vdGVzSW5mbyxcbiAgICAgICAgc2hhcmVkOiBtYW5pZmVzdCA9PT0gbnVsbCB8fCBtYW5pZmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFuaWZlc3Quc2hhcmVkLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIG1vZHVsZXM6IGV4cG9zZXMgPT09IG51bGwgfHwgZXhwb3NlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwb3Nlcy5tYXAoZnVuY3Rpb24oZXhwb3NlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IGV4cG9zZS5uYW1lLFxuICAgICAgICAgICAgICAgIG1vZHVsZVBhdGg6IGV4cG9zZS5wYXRoLFxuICAgICAgICAgICAgICAgIGFzc2V0czogZXhwb3NlLmFzc2V0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICB9O1xuICAgIGlmICgoX21hbmlmZXN0X21ldGFEYXRhID0gbWFuaWZlc3QubWV0YURhdGEpID09PSBudWxsIHx8IF9tYW5pZmVzdF9tZXRhRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hbmlmZXN0X21ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHByZWZldGNoSW50ZXJmYWNlOiBwcmVmZXRjaEludGVyZmFjZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGExID0gbWFuaWZlc3QubWV0YURhdGEpID09PSBudWxsIHx8IF9tYW5pZmVzdF9tZXRhRGF0YTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YTEucHJlZmV0Y2hFbnRyeSkge1xuICAgICAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkgPSBtYW5pZmVzdC5tZXRhRGF0YS5wcmVmZXRjaEVudHJ5LCBwYXRoID0gX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkucGF0aCwgbmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5Lm5hbWUsIHR5cGUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcHJlZmV0Y2hFbnRyeS50eXBlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHByZWZldGNoRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShwYXRoLCBuYW1lKSxcbiAgICAgICAgICAgIHByZWZldGNoRW50cnlUeXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJ3B1YmxpY1BhdGgnIGluIG1hbmlmZXN0Lm1ldGFEYXRhKSB7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90ID0gX29iamVjdF9zcHJlYWRfcHJvcHMoX29iamVjdF9zcHJlYWQkMSh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCksIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGg6IGdldFB1YmxpY1BhdGgoKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBnZXRQdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIGlzTWFuaWZlc3RQcm92aWRlcihtb2R1bGVJbmZvKSB7XG4gICAgaWYgKCdyZW1vdGVFbnRyeScgaW4gbW9kdWxlSW5mbyAmJiBtb2R1bGVJbmZvLnJlbW90ZUVudHJ5LmluY2x1ZGVzKE1BTklGRVNUX0VYVCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvciQxKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwJDEoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXSkge1xuICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvciQxKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2FmZVdyYXBwZXIoY2FsbGJhY2ssIGRpc2FibGVXYXJuKSB7XG4gICAgcmV0dXJuIF9zYWZlV3JhcHBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3NhZmVXcmFwcGVyKCkge1xuICAgIF9zYWZlV3JhcHBlciA9IF9hc3luY190b19nZW5lcmF0b3IkMShmdW5jdGlvbihjYWxsYmFjaywgZGlzYWJsZVdhcm4pIHtcbiAgICAgICAgdmFyIHJlcywgZTtcbiAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAhZGlzYWJsZVdhcm4gJiYgd2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBfc2FmZVdyYXBwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwodXJsMSwgdXJsMikge1xuICAgIHZhciBSRUdfRVhQID0gL14oaHR0cHM/Oik/XFwvXFwvL2k7XG4gICAgLy8gVHJhbnNmb3JtIHVybDEgYW5kIHVybDIgaW50byByZWxhdGl2ZSBwYXRoc1xuICAgIHZhciByZWxhdGl2ZVVybDEgPSB1cmwxLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgdmFyIHJlbGF0aXZlVXJsMiA9IHVybDIucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVsYXRpdmUgcGF0aHMgYXJlIGlkZW50aWNhbFxuICAgIHJldHVybiByZWxhdGl2ZVVybDEgPT09IHJlbGF0aXZlVXJsMjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjcmlwdCh1cmwsIGNiLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vaykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIHZhciBzY3JpcHQgPSBudWxsO1xuICAgIHZhciBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICB2YXIgdGltZW91dCA9IDIwMDAwO1xuICAgIHZhciB0aW1lb3V0SWQ7XG4gICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHNjcmlwdHNbaV07XG4gICAgICAgIHZhciBzY3JpcHRTcmMgPSBzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIGlmIChzY3JpcHRTcmMgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChzY3JpcHRTcmMsIHVybCkpIHtcbiAgICAgICAgICAgIHNjcmlwdCA9IHM7XG4gICAgICAgICAgICBuZWVkQXR0YWNoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVTY3JpcHRSZXMgPSBjcmVhdGVTY3JpcHRIb29rKHVybCk7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YoY3JlYXRlU2NyaXB0UmVzLCBIVE1MU2NyaXB0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVTY3JpcHRSZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQpIHNjcmlwdCA9IGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0KSB0aW1lb3V0ID0gY3JlYXRlU2NyaXB0UmVzLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2FzeW5jJyB8fCBuYW1lID09PSAnZGVmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdFtuYW1lXSA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBvblNjcmlwdENvbXBsZXRlID0gZnVuY3Rpb24ocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUUuXG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc2FmZVdyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgKHNjcmlwdCA9PT0gbnVsbCB8fCBzY3JpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmlwdC5wYXJlbnROb2RlKSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHByZXYoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25TY3JpcHRDb21wbGV0ZShudWxsLCBuZXcgRXJyb3IoJ1JlbW90ZSBzY3JpcHQgXCInLmNvbmNhdCh1cmwsICdcIiB0aW1lLW91dGVkLicpKSk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgICAgIG5lZWRBdHRhY2g6IG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGluayh1cmwsIGNiKSB7XG4gICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgY3JlYXRlTGlua0hvb2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHZvaWQgMDtcbiAgICAvLyA8bGluayByZWw9XCJwcmVsb2FkXCIgaHJlZj1cInNjcmlwdC5qc1wiIGFzPVwic2NyaXB0XCI+XG4gICAgLy8gUmV0cmlldmUgdGhlIGV4aXN0aW5nIHNjcmlwdCBlbGVtZW50IGJ5IGl0cyBzcmMgYXR0cmlidXRlXG4gICAgdmFyIGxpbmsgPSBudWxsO1xuICAgIHZhciBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICB2YXIgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsID0gbGlua3NbaV07XG4gICAgICAgIHZhciBsaW5rSHJlZiA9IGwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIHZhciBsaW5rUmVmID0gbC5nZXRBdHRyaWJ1dGUoJ3JlZicpO1xuICAgICAgICBpZiAobGlua0hyZWYgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChsaW5rSHJlZiwgdXJsKSAmJiBsaW5rUmVmID09PSBhdHRyc1sncmVmJ10pIHtcbiAgICAgICAgICAgIGxpbmsgPSBsO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJywgJ2Fub255bW91cycpO1xuICAgICAgICBpZiAoY3JlYXRlTGlua0hvb2spIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVMaW5rUmVzID0gY3JlYXRlTGlua0hvb2sodXJsKTtcbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZihjcmVhdGVMaW5rUmVzLCBIVE1MTGlua0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IGNyZWF0ZUxpbmtSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIG9uTGlua0NvbXBsZXRlID0gZnVuY3Rpb24ocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCkge1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAobGluayA9PT0gbnVsbCB8fCBsaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5rLnBhcmVudE5vZGUpICYmIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIGxpbmsub25lcnJvciA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmVycm9yKTtcbiAgICBsaW5rLm9ubG9hZCA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmxvYWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbms6IGxpbmssXG4gICAgICAgIG5lZWRBdHRhY2g6IG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmwsIGluZm8pIHtcbiAgICB2YXIgYXR0cnMgPSBpbmZvLmF0dHJzLCBjcmVhdGVTY3JpcHRIb29rID0gaW5mby5jcmVhdGVTY3JpcHRIb29rO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCBfcmVqZWN0KSB7XG4gICAgICAgIHZhciBfY3JlYXRlU2NyaXB0ID0gY3JlYXRlU2NyaXB0KHVybCwgcmVzb2x2ZSwgYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2spLCBzY3JpcHQgPSBfY3JlYXRlU2NyaXB0LnNjcmlwdCwgbmVlZEF0dGFjaCA9IF9jcmVhdGVTY3JpcHQubmVlZEF0dGFjaDtcbiAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9hcnJheV93aXRoX2hvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfcywgX2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKXtcbiAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hcnI7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3Jlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NsaWNlZF90b19hcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkoYXJyLCBpKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBmLCB5LCB0LCBnLCBfID0ge1xuICAgICAgICBsYWJlbDogMCxcbiAgICAgICAgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ5czogW10sXG4gICAgICAgIG9wczogW11cbiAgICB9O1xuICAgIHJldHVybiBnID0ge1xuICAgICAgICBuZXh0OiB2ZXJiKDApLFxuICAgICAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgICB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUoXyl0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtcbiAgICAgICAgICAgICAgICBvcFswXSAmIDIsXG4gICAgICAgICAgICAgICAgdC52YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHN3aXRjaChvcFswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGltcG9ydE5vZGVNb2R1bGUobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9ydCBzcGVjaWZpZXIgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgdmFyIGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbignbmFtZScsIFwicmV0dXJuIGltcG9ydChuYW1lKVwiKTtcbiAgICByZXR1cm4gaW1wb3J0TW9kdWxlKG5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiByZXMuZGVmYXVsdDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSBcIi5jb25jYXQobmFtZSwgXCI6XCIpLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NyaXB0Tm9kZSh1cmwsIGNiLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vaykge1xuICAgIGlmIChjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgIHZhciBob29rUmVzdWx0ID0gY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgICAgICBpZiAoaG9va1Jlc3VsdCAmJiB0eXBlb2YgaG9va1Jlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3VybCcgaW4gaG9va1Jlc3VsdCkge1xuICAgICAgICAgICAgdXJsID0gaG9va1Jlc3VsdC51cmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVybE9iajtcbiAgICB0cnkge1xuICAgICAgICB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb25zdHJ1Y3RpbmcgVVJMOicsIGUpO1xuICAgICAgICBjYihuZXcgRXJyb3IoXCJJbnZhbGlkIFVSTDogXCIuY29uY2F0KGUpKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdldEZldGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaE1vZHVsZTtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgnbm9kZS1mZXRjaCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE1vZHVsZSA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmV0Y2hNb2R1bGUgPT09IG51bGwgfHwgZmV0Y2hNb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoTW9kdWxlLmRlZmF1bHQpIHx8IGZldGNoTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSgpO1xuICAgIGNvbnNvbGUubG9nKCdmZXRjaGluZycsIHVybE9iai5ocmVmKTtcbiAgICBnZXRGZXRjaCgpLnRoZW4oZnVuY3Rpb24oZikge1xuICAgICAgICBmKHVybE9iai5ocmVmKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmLCBwYXRoLCB2bSwgc2NyaXB0Q29udGV4dCwgdXJsRGlybmFtZSwgZmlsZW5hbWUsIHNjcmlwdCwgZXhwb3J0ZWRJbnRlcmZhY2UsIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgncGF0aCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9zbGljZWRfdG9fYXJyYXkuYXBwbHkodm9pZCAwLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSwgcGF0aCA9IF9yZWZbMF0sIHZtID0gX3JlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxEaXJuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUodXJsT2JqLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBuZXcgdm0uU2NyaXB0KFwiKGZ1bmN0aW9uKGV4cG9ydHMsIG1vZHVsZSwgcmVxdWlyZSwgX19kaXJuYW1lLCBfX2ZpbGVuYW1lKSB7XCIuY29uY2F0KGRhdGEsIFwiXFxufSlcIiksIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnJ1bkluVGhpc0NvbnRleHQoKShzY3JpcHRDb250ZXh0LmV4cG9ydHMsIHNjcmlwdENvbnRleHQubW9kdWxlLCBldmFsKCdyZXF1aXJlJyksIHVybERpcm5hbWUsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRJbnRlcmZhY2UgPSBzY3JpcHRDb250ZXh0Lm1vZHVsZS5leHBvcnRzIHx8IHNjcmlwdENvbnRleHQuZXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzICYmIGV4cG9ydGVkSW50ZXJmYWNlICYmIGF0dHJzWydnbG9iYWxOYW1lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGV4cG9ydGVkSW50ZXJmYWNlW2F0dHJzWydnbG9iYWxOYW1lJ11dIHx8IGV4cG9ydGVkSW50ZXJmYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignRXJyb3IgcnVubmluZyBzY3JpcHQ6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBFcnJvcihcIlNjcmlwdCBleGVjdXRpb24gZXJyb3I6IFwiLmNvbmNhdChlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCkpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc2NyaXB0OicsIGVycik7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxvYWRTY3JpcHROb2RlKHVybCwgaW5mbykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY3JlYXRlU2NyaXB0Tm9kZSh1cmwsIGZ1bmN0aW9uKGVycm9yLCBzY3JpcHRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlRW50cnlLZXkgPSAoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PT0gbnVsbCB8fCBfaW5mb19hdHRycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgXCJfX0ZFREVSQVRJT05fXCIuY29uY2F0KGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9pbmZvX2F0dHJzMSA9IGluZm8uYXR0cnMpID09PSBudWxsIHx8IF9pbmZvX2F0dHJzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ10sIFwiOmN1c3RvbV9fXCIpO1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmNyZWF0ZVNjcmlwdEhvb2spO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfdHlwZV9vZihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhlbmFibGVEZWZhdWx0LCBkZWZhdWx0T3B0aW9ucywga2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3Rfc3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0eXBlIGZvciBgXCIuY29uY2F0KGtleSwgXCJgLCBleHBlY3QgYm9vbGVhbi91bmRlZmluZWQvb2JqZWN0LCBnb3Q6IFwiKS5jb25jYXQodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yob3B0aW9ucykpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBCUk9XU0VSX0xPR19LRVksIEJST1dTRVJfTE9HX1ZBTFVFLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCwgRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0LCBMb2dnZXIsIE1BTklGRVNUX0VYVCwgTUZNb2R1bGVUeXBlLCBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSLCBNYW5pZmVzdEZpbGVOYW1lLCBOYW1lVHJhbnNmb3JtTWFwLCBOYW1lVHJhbnNmb3JtU3ltYm9sLCBTRVBBUkFUT1IsIFN0YXRzRmlsZU5hbWUsIGFzc2VydCwgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IsIENvbnRhaW5lclBsdWdpbiBhcyBjb250YWluZXJQbHVnaW4sIENvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiBhcyBjb250YWluZXJSZWZlcmVuY2VQbHVnaW4sIGNyZWF0ZUxpbmssIGNyZWF0ZVNjcmlwdCwgY3JlYXRlU2NyaXB0Tm9kZSwgZGVjb2RlTmFtZSwgZW5jb2RlTmFtZSwgZXJyb3IsIGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUsIGdlbmVyYXRlU2hhcmVGaWxlbmFtZSwgZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCwgZ2V0UHJvY2Vzc0VudiwgZ2V0UmVzb3VyY2VVcmwsIGluZmVyQXV0b1B1YmxpY1BhdGgsIGlzQnJvd3NlckVudiwgaXNEZWJ1Z01vZGUsIGlzTWFuaWZlc3RQcm92aWRlciwgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbCwgbG9hZFNjcmlwdCwgbG9hZFNjcmlwdE5vZGUsIGxvZ2dlciwgTW9kdWxlRmVkZXJhdGlvblBsdWdpbiBhcyBtb2R1bGVGZWRlcmF0aW9uUGx1Z2luLCBub3JtYWxpemVPcHRpb25zLCBwYXJzZUVudHJ5LCBzYWZlV3JhcHBlciwgU2hhcmVQbHVnaW4gYXMgc2hhcmVQbHVnaW4sIHNpbXBsZUpvaW5SZW1vdGVFbnRyeSwgd2FybiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nvar FEDERATION_SUPPORTED_TYPES = [\n    'script'\n];\n\nexports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;\nexports.FEDERATION_SUPPORTED_TYPES = FEDERATION_SUPPORTED_TYPES;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3dlYnBhY2stYnVuZGxlci1ydW50aW1lQDAuMS4xOC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvY29uc3RhbnQuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3dlYnBhY2stYnVuZGxlci1ydW50aW1lQDAuMS4xOC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvY29uc3RhbnQuY2pzLmpzPzExMTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgRU5DT0RFX05BTUVfUFJFRklYID0gJ0VOQ09ERV9OQU1FX1BSRUZJWCc7XG52YXIgRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVMgPSBbXG4gICAgJ3NjcmlwdCdcbl07XG5cbmV4cG9ydHMuRU5DT0RFX05BTUVfUFJFRklYID0gRU5DT0RFX05BTUVfUFJFRklYO1xuZXhwb3J0cy5GRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUyA9IEZFREVSQVRJT05fU1VQUE9SVEVEX1RZUEVTO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js ***!
  \********************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar runtime = __webpack_require__(/*! @module-federation/runtime */ \"./node_modules/.pnpm/@module-federation+runtime@0.1.18/node_modules/@module-federation/runtime/dist/index.esm.js\");\nvar sdk = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/.pnpm/@module-federation+sdk@0.1.18/node_modules/@module-federation/sdk/dist/index.cjs.js\");\nvar constant = __webpack_require__(/*! ./constant.cjs.js */ \"./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar runtime__namespace = /*#__PURE__*/_interopNamespace(runtime);\n\nfunction attachShareScopeMap(webpackRequire) {\n    if (!webpackRequire.S || webpackRequire.federation.hasAttachShareScopeMap || !webpackRequire.federation.instance || !webpackRequire.federation.instance.shareScopeMap) {\n        return;\n    }\n    webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;\n    webpackRequire.federation.hasAttachShareScopeMap = true;\n}\n\nfunction remotes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, idToExternalAndNameMapping = options.idToExternalAndNameMapping, webpackRequire = options.webpackRequire, idToRemoteMap = options.idToRemoteMap;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            var getScope = webpackRequire.R;\n            if (!getScope) {\n                getScope = [];\n            }\n            var data = idToExternalAndNameMapping[id];\n            var remoteInfos = idToRemoteMap[id];\n            // @ts-ignore seems not work\n            if (getScope.indexOf(data) >= 0) {\n                return;\n            }\n            // @ts-ignore seems not work\n            getScope.push(data);\n            if (data.p) {\n                return promises.push(data.p);\n            }\n            var onError = function(error) {\n                if (!error) {\n                    error = new Error('Container missing');\n                }\n                if (typeof error.message === 'string') {\n                    error.message += '\\nwhile loading \"'.concat(data[1], '\" from ').concat(data[2]);\n                }\n                webpackRequire.m[id] = function() {\n                    throw error;\n                };\n                data.p = 0;\n            };\n            var handleFunction = function(fn, arg1, arg2, d, next, first) {\n                try {\n                    var promise = fn(arg1, arg2);\n                    if (promise && promise.then) {\n                        var p = promise.then(function(result) {\n                            return next(result, d);\n                        }, onError);\n                        if (first) {\n                            promises.push(data.p = p);\n                        } else {\n                            return p;\n                        }\n                    } else {\n                        return next(promise, d, first);\n                    }\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var onExternal = function(external, _, first) {\n                return external ? handleFunction(webpackRequire.I, data[0], 0, external, onInitialized, first) : onError();\n            };\n            // eslint-disable-next-line no-var\n            var onInitialized = function(_, external, first) {\n                return handleFunction(external.get, data[1], getScope, 0, onFactory, first);\n            };\n            // eslint-disable-next-line no-var\n            var onFactory = function(factory) {\n                data.p = 1;\n                webpackRequire.m[id] = function(module) {\n                    module.exports = factory();\n                };\n            };\n            var onRemoteLoaded = function() {\n                try {\n                    var remoteName = sdk.decodeName(remoteInfos[0].name, constant.ENCODE_NAME_PREFIX);\n                    var remoteModuleName = remoteName + data[1].slice(1);\n                    return webpackRequire.federation.instance.loadRemote(remoteModuleName, {\n                        loadFactory: false,\n                        from: 'build'\n                    });\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var useRuntimeLoad = remoteInfos.length === 1 && [\n                'script'\n            ].includes(remoteInfos[0].externalType) && remoteInfos[0].name;\n            if (useRuntimeLoad) {\n                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);\n            } else {\n                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);\n            }\n        });\n    }\n}\n\nfunction consumes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, installedModules = options.installedModules, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            if (webpackRequire.o(installedModules, id)) {\n                return promises.push(installedModules[id]);\n            }\n            var onFactory = function(factory) {\n                installedModules[id] = 0;\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    module.exports = factory();\n                };\n            };\n            var onError = function(error) {\n                delete installedModules[id];\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    throw error;\n                };\n            };\n            try {\n                var federationInstance = webpackRequire.federation.instance;\n                if (!federationInstance) {\n                    throw new Error('Federation instance not found!');\n                }\n                var _moduleToHandlerMapping_id = moduleToHandlerMapping[id], shareKey = _moduleToHandlerMapping_id.shareKey, getter = _moduleToHandlerMapping_id.getter, shareInfo = _moduleToHandlerMapping_id.shareInfo;\n                var promise = federationInstance.loadShare(shareKey, {\n                    customShareInfo: shareInfo\n                }).then(function(factory) {\n                    if (factory === false) {\n                        return getter();\n                    }\n                    return factory;\n                });\n                if (promise.then) {\n                    promises.push(installedModules[id] = promise.then(onFactory).catch(onError));\n                } else {\n                    // @ts-ignore maintain previous logic\n                    onFactory(promise);\n                }\n            } catch (e) {\n                onError(e);\n            }\n        });\n    }\n}\n\nfunction initializeSharing(param) {\n    var shareScopeName = param.shareScopeName, webpackRequire = param.webpackRequire, initPromises = param.initPromises, initTokens = param.initTokens, initScope = param.initScope;\n    if (!initScope) initScope = [];\n    // handling circular init calls\n    var initToken = initTokens[shareScopeName];\n    if (!initToken) initToken = initTokens[shareScopeName] = {};\n    if (initScope.indexOf(initToken) >= 0) return;\n    initScope.push(initToken);\n    var promise = initPromises[shareScopeName];\n    if (promise) return promise;\n    var warn = function(msg) {\n        return typeof console !== 'undefined' && console.warn && console.warn(msg);\n    };\n    var initExternal = function(id) {\n        var handleError = function(err) {\n            return warn('Initialization of sharing external failed: ' + err);\n        };\n        try {\n            var module = webpackRequire(id);\n            if (!module) return;\n            var initFn = function(module) {\n                return module && module.init && // @ts-ignore compat legacy mf shared behavior\n                module.init(webpackRequire.S[shareScopeName], initScope);\n            };\n            if (module.then) return promises.push(module.then(initFn, handleError));\n            var initResult = initFn(module);\n            // @ts-ignore\n            if (initResult && typeof initResult !== 'boolean' && initResult.then) // @ts-ignore\n            return promises.push(initResult['catch'](handleError));\n        } catch (err) {\n            handleError(err);\n        }\n    };\n    var promises = webpackRequire.federation.instance.initializeSharing(shareScopeName);\n    attachShareScopeMap(webpackRequire);\n    var bundlerRuntimeRemotesOptions = webpackRequire.federation.bundlerRuntimeOptions.remotes;\n    if (bundlerRuntimeRemotesOptions) {\n        Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach(function(moduleId) {\n            var info = bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];\n            var externalModuleId = bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[moduleId][2];\n            if (info.length > 1) {\n                initExternal(externalModuleId);\n            } else if (info.length === 1) {\n                var remoteInfo = info[0];\n                if (!constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfo.externalType)) {\n                    initExternal(externalModuleId);\n                }\n            }\n        });\n    }\n    if (!promises.length) {\n        return initPromises[shareScopeName] = true;\n    }\n    return initPromises[shareScopeName] = Promise.all(promises).then(function() {\n        return initPromises[shareScopeName] = true;\n    });\n}\n\nfunction handleInitialConsumes(options) {\n    var moduleId = options.moduleId, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    var federationInstance = webpackRequire.federation.instance;\n    if (!federationInstance) {\n        throw new Error('Federation instance not found!');\n    }\n    var _moduleToHandlerMapping_moduleId = moduleToHandlerMapping[moduleId], shareKey = _moduleToHandlerMapping_moduleId.shareKey, shareInfo = _moduleToHandlerMapping_moduleId.shareInfo;\n    try {\n        return federationInstance.loadShareSync(shareKey, {\n            customShareInfo: shareInfo\n        });\n    } catch (err) {\n        console.error('loadShareSync failed! The function should not be called unless you set \"eager:true\". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.');\n        console.error('The original error message is as follows: ');\n        throw err;\n    }\n}\nfunction installInitialConsumes(options) {\n    var moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire, installedModules = options.installedModules, initialConsumes = options.initialConsumes;\n    initialConsumes.forEach(function(id) {\n        webpackRequire.m[id] = function(module) {\n            // Handle scenario when module is used synchronously\n            installedModules[id] = 0;\n            delete webpackRequire.c[id];\n            var factory = handleInitialConsumes({\n                moduleId: id,\n                moduleToHandlerMapping: moduleToHandlerMapping,\n                webpackRequire: webpackRequire\n            });\n            if (typeof factory !== 'function') {\n                throw new Error(\"Shared module is not available for eager consumption: \".concat(id));\n            }\n            module.exports = factory();\n        };\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction initContainerEntry(options) {\n    var webpackRequire = options.webpackRequire, shareScope = options.shareScope, initScope = options.initScope, shareScopeKey = options.shareScopeKey, remoteEntryInitOptions = options.remoteEntryInitOptions;\n    if (!webpackRequire.S) return;\n    if (!webpackRequire.federation || !webpackRequire.federation.instance || !webpackRequire.federation.initOptions) return;\n    var federationInstance = webpackRequire.federation.instance;\n    var name = shareScopeKey || 'default';\n    federationInstance.initOptions(_object_spread({\n        name: webpackRequire.federation.initOptions.name,\n        remotes: []\n    }, remoteEntryInitOptions));\n    federationInstance.initShareScopeMap(name, shareScope);\n    if (webpackRequire.federation.attachShareScopeMap) {\n        webpackRequire.federation.attachShareScopeMap(webpackRequire);\n    }\n    // @ts-ignore\n    return webpackRequire.I(name, initScope);\n}\n\nvar federation = {\n    runtime: runtime__namespace,\n    instance: undefined,\n    initOptions: undefined,\n    bundlerRuntime: {\n        remotes: remotes,\n        consumes: consumes,\n        I: initializeSharing,\n        S: {},\n        installInitialConsumes: installInitialConsumes,\n        initContainerEntry: initContainerEntry\n    },\n    attachShareScopeMap: attachShareScopeMap,\n    bundlerRuntimeOptions: {}\n};\n\nmodule.exports = federation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3dlYnBhY2stYnVuZGxlci1ydW50aW1lQDAuMS4xOC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvaW5kZXguY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxvSkFBNEI7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLHdJQUF3QjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsOEtBQW1COztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK3dlYnBhY2stYnVuZGxlci1ydW50aW1lQDAuMS4xOC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvaW5kZXguY2pzLmpzP2ViN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcnVudGltZSA9IHJlcXVpcmUoJ0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lJyk7XG52YXIgc2RrID0gcmVxdWlyZSgnQG1vZHVsZS1mZWRlcmF0aW9uL3NkaycpO1xudmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudC5janMuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIHJ1bnRpbWVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShydW50aW1lKTtcblxuZnVuY3Rpb24gYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSkge1xuICAgIGlmICghd2VicGFja1JlcXVpcmUuUyB8fCB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmhhc0F0dGFjaFNoYXJlU2NvcGVNYXAgfHwgIXdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UgfHwgIXdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2Uuc2hhcmVTY29wZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdlYnBhY2tSZXF1aXJlLlMgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlLnNoYXJlU2NvcGVNYXA7XG4gICAgd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5oYXNBdHRhY2hTaGFyZVNjb3BlTWFwID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVtb3RlcyhvcHRpb25zKSB7XG4gICAgdmFyIGNodW5rSWQgPSBvcHRpb25zLmNodW5rSWQsIHByb21pc2VzID0gb3B0aW9ucy5wcm9taXNlcywgY2h1bmtNYXBwaW5nID0gb3B0aW9ucy5jaHVua01hcHBpbmcsIGlkVG9FeHRlcm5hbEFuZE5hbWVNYXBwaW5nID0gb3B0aW9ucy5pZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZywgd2VicGFja1JlcXVpcmUgPSBvcHRpb25zLndlYnBhY2tSZXF1aXJlLCBpZFRvUmVtb3RlTWFwID0gb3B0aW9ucy5pZFRvUmVtb3RlTWFwO1xuICAgIGF0dGFjaFNoYXJlU2NvcGVNYXAod2VicGFja1JlcXVpcmUpO1xuICAgIGlmICh3ZWJwYWNrUmVxdWlyZS5vKGNodW5rTWFwcGluZywgY2h1bmtJZCkpIHtcbiAgICAgICAgY2h1bmtNYXBwaW5nW2NodW5rSWRdLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBnZXRTY29wZSA9IHdlYnBhY2tSZXF1aXJlLlI7XG4gICAgICAgICAgICBpZiAoIWdldFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgZ2V0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhID0gaWRUb0V4dGVybmFsQW5kTmFtZU1hcHBpbmdbaWRdO1xuICAgICAgICAgICAgdmFyIHJlbW90ZUluZm9zID0gaWRUb1JlbW90ZU1hcFtpZF07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHNlZW1zIG5vdCB3b3JrXG4gICAgICAgICAgICBpZiAoZ2V0U2NvcGUuaW5kZXhPZihkYXRhKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzZWVtcyBub3Qgd29ya1xuICAgICAgICAgICAgZ2V0U2NvcGUucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChkYXRhLnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbnRhaW5lciBtaXNzaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSAnXFxud2hpbGUgbG9hZGluZyBcIicuY29uY2F0KGRhdGFbMV0sICdcIiBmcm9tICcpLmNvbmNhdChkYXRhWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkYXRhLnAgPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZuLCBhcmcxLCBhcmcyLCBkLCBuZXh0LCBmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZm4oYXJnMSwgYXJnMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlICYmIHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQocmVzdWx0LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYXRhLnAgPSBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChwcm9taXNlLCBkLCBmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uRXh0ZXJuYWwgPSBmdW5jdGlvbihleHRlcm5hbCwgXywgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwgPyBoYW5kbGVGdW5jdGlvbih3ZWJwYWNrUmVxdWlyZS5JLCBkYXRhWzBdLCAwLCBleHRlcm5hbCwgb25Jbml0aWFsaXplZCwgZmlyc3QpIDogb25FcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgICAgICAgICAgIHZhciBvbkluaXRpYWxpemVkID0gZnVuY3Rpb24oXywgZXh0ZXJuYWwsIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUZ1bmN0aW9uKGV4dGVybmFsLmdldCwgZGF0YVsxXSwgZ2V0U2NvcGUsIDAsIG9uRmFjdG9yeSwgZmlyc3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgICAgICAgICAgIHZhciBvbkZhY3RvcnkgPSBmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wID0gMTtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvblJlbW90ZUxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVOYW1lID0gc2RrLmRlY29kZU5hbWUocmVtb3RlSW5mb3NbMF0ubmFtZSwgY29uc3RhbnQuRU5DT0RFX05BTUVfUFJFRklYKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZU1vZHVsZU5hbWUgPSByZW1vdGVOYW1lICsgZGF0YVsxXS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UubG9hZFJlbW90ZShyZW1vdGVNb2R1bGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRmFjdG9yeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnYnVpbGQnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdXNlUnVudGltZUxvYWQgPSByZW1vdGVJbmZvcy5sZW5ndGggPT09IDEgJiYgW1xuICAgICAgICAgICAgICAgICdzY3JpcHQnXG4gICAgICAgICAgICBdLmluY2x1ZGVzKHJlbW90ZUluZm9zWzBdLmV4dGVybmFsVHlwZSkgJiYgcmVtb3RlSW5mb3NbMF0ubmFtZTtcbiAgICAgICAgICAgIGlmICh1c2VSdW50aW1lTG9hZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZ1bmN0aW9uKG9uUmVtb3RlTG9hZGVkLCBkYXRhWzJdLCAwLCAwLCBvbkZhY3RvcnksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVGdW5jdGlvbih3ZWJwYWNrUmVxdWlyZSwgZGF0YVsyXSwgMCwgMCwgb25FeHRlcm5hbCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZXMob3B0aW9ucykge1xuICAgIHZhciBjaHVua0lkID0gb3B0aW9ucy5jaHVua0lkLCBwcm9taXNlcyA9IG9wdGlvbnMucHJvbWlzZXMsIGNodW5rTWFwcGluZyA9IG9wdGlvbnMuY2h1bmtNYXBwaW5nLCBpbnN0YWxsZWRNb2R1bGVzID0gb3B0aW9ucy5pbnN0YWxsZWRNb2R1bGVzLCBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nID0gb3B0aW9ucy5tb2R1bGVUb0hhbmRsZXJNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmU7XG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgaWYgKHdlYnBhY2tSZXF1aXJlLm8oY2h1bmtNYXBwaW5nLCBjaHVua0lkKSkge1xuICAgICAgICBjaHVua01hcHBpbmdbY2h1bmtJZF0uZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgaWYgKHdlYnBhY2tSZXF1aXJlLm8oaW5zdGFsbGVkTW9kdWxlcywgaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2goaW5zdGFsbGVkTW9kdWxlc1tpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9uRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IDA7XG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdlYnBhY2tSZXF1aXJlLmNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1tpZF07XG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdlYnBhY2tSZXF1aXJlLmNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlZGVyYXRpb25JbnN0YW5jZSA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKCFmZWRlcmF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWRlcmF0aW9uIGluc3RhbmNlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9tb2R1bGVUb0hhbmRsZXJNYXBwaW5nX2lkID0gbW9kdWxlVG9IYW5kbGVyTWFwcGluZ1tpZF0sIHNoYXJlS2V5ID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQuc2hhcmVLZXksIGdldHRlciA9IF9tb2R1bGVUb0hhbmRsZXJNYXBwaW5nX2lkLmdldHRlciwgc2hhcmVJbmZvID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQuc2hhcmVJbmZvO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZShzaGFyZUtleSwge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21TaGFyZUluZm86IHNoYXJlSW5mb1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFjdG9yeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5zdGFsbGVkTW9kdWxlc1tpZF0gPSBwcm9taXNlLnRoZW4ob25GYWN0b3J5KS5jYXRjaChvbkVycm9yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBtYWludGFpbiBwcmV2aW91cyBsb2dpY1xuICAgICAgICAgICAgICAgICAgICBvbkZhY3RvcnkocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNoYXJpbmcocGFyYW0pIHtcbiAgICB2YXIgc2hhcmVTY29wZU5hbWUgPSBwYXJhbS5zaGFyZVNjb3BlTmFtZSwgd2VicGFja1JlcXVpcmUgPSBwYXJhbS53ZWJwYWNrUmVxdWlyZSwgaW5pdFByb21pc2VzID0gcGFyYW0uaW5pdFByb21pc2VzLCBpbml0VG9rZW5zID0gcGFyYW0uaW5pdFRva2VucywgaW5pdFNjb3BlID0gcGFyYW0uaW5pdFNjb3BlO1xuICAgIGlmICghaW5pdFNjb3BlKSBpbml0U2NvcGUgPSBbXTtcbiAgICAvLyBoYW5kbGluZyBjaXJjdWxhciBpbml0IGNhbGxzXG4gICAgdmFyIGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZU5hbWVdO1xuICAgIGlmICghaW5pdFRva2VuKSBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXSA9IHt9O1xuICAgIGlmIChpbml0U2NvcGUuaW5kZXhPZihpbml0VG9rZW4pID49IDApIHJldHVybjtcbiAgICBpbml0U2NvcGUucHVzaChpbml0VG9rZW4pO1xuICAgIHZhciBwcm9taXNlID0gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVOYW1lXTtcbiAgICBpZiAocHJvbWlzZSkgcmV0dXJuIHByb21pc2U7XG4gICAgdmFyIHdhcm4gPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfTtcbiAgICB2YXIgaW5pdEV4dGVybmFsID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FybignSW5pdGlhbGl6YXRpb24gb2Ygc2hhcmluZyBleHRlcm5hbCBmYWlsZWQ6ICcgKyBlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IHdlYnBhY2tSZXF1aXJlKGlkKTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5pdEZuID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZSAmJiBtb2R1bGUuaW5pdCAmJiAvLyBAdHMtaWdub3JlIGNvbXBhdCBsZWdhY3kgbWYgc2hhcmVkIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgbW9kdWxlLmluaXQod2VicGFja1JlcXVpcmUuU1tzaGFyZVNjb3BlTmFtZV0sIGluaXRTY29wZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1vZHVsZS50aGVuKSByZXR1cm4gcHJvbWlzZXMucHVzaChtb2R1bGUudGhlbihpbml0Rm4sIGhhbmRsZUVycm9yKSk7XG4gICAgICAgICAgICB2YXIgaW5pdFJlc3VsdCA9IGluaXRGbihtb2R1bGUpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKGluaXRSZXN1bHQgJiYgdHlwZW9mIGluaXRSZXN1bHQgIT09ICdib29sZWFuJyAmJiBpbml0UmVzdWx0LnRoZW4pIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5wdXNoKGluaXRSZXN1bHRbJ2NhdGNoJ10oaGFuZGxlRXJyb3IpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZXMgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGVOYW1lKTtcbiAgICBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKTtcbiAgICB2YXIgYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucyA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uYnVuZGxlclJ1bnRpbWVPcHRpb25zLnJlbW90ZXM7XG4gICAgaWYgKGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvUmVtb3RlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMuaWRUb1JlbW90ZU1hcFttb2R1bGVJZF07XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxNb2R1bGVJZCA9IGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMuaWRUb0V4dGVybmFsQW5kTmFtZU1hcHBpbmdbbW9kdWxlSWRdWzJdO1xuICAgICAgICAgICAgaWYgKGluZm8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGluaXRFeHRlcm5hbChleHRlcm5hbE1vZHVsZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5mby5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlSW5mbyA9IGluZm9bMF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudC5GRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUy5pbmNsdWRlcyhyZW1vdGVJbmZvLmV4dGVybmFsVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEV4dGVybmFsKGV4dGVybmFsTW9kdWxlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbml0UHJvbWlzZXNbc2hhcmVTY29wZU5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRQcm9taXNlc1tzaGFyZVNjb3BlTmFtZV0gPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluaXRQcm9taXNlc1tzaGFyZVNjb3BlTmFtZV0gPSB0cnVlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVJbml0aWFsQ29uc3VtZXMob3B0aW9ucykge1xuICAgIHZhciBtb2R1bGVJZCA9IG9wdGlvbnMubW9kdWxlSWQsIG1vZHVsZVRvSGFuZGxlck1hcHBpbmcgPSBvcHRpb25zLm1vZHVsZVRvSGFuZGxlck1hcHBpbmcsIHdlYnBhY2tSZXF1aXJlID0gb3B0aW9ucy53ZWJwYWNrUmVxdWlyZTtcbiAgICB2YXIgZmVkZXJhdGlvbkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICBpZiAoIWZlZGVyYXRpb25JbnN0YW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZGVyYXRpb24gaW5zdGFuY2Ugbm90IGZvdW5kIScpO1xuICAgIH1cbiAgICB2YXIgX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfbW9kdWxlSWQgPSBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nW21vZHVsZUlkXSwgc2hhcmVLZXkgPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19tb2R1bGVJZC5zaGFyZUtleSwgc2hhcmVJbmZvID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfbW9kdWxlSWQuc2hhcmVJbmZvO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmZWRlcmF0aW9uSW5zdGFuY2UubG9hZFNoYXJlU3luYyhzaGFyZUtleSwge1xuICAgICAgICAgICAgY3VzdG9tU2hhcmVJbmZvOiBzaGFyZUluZm9cbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2xvYWRTaGFyZVN5bmMgZmFpbGVkISBUaGUgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgdW5sZXNzIHlvdSBzZXQgXCJlYWdlcjp0cnVlXCIuIElmIHlvdSBkbyBub3Qgc2V0IGl0LCBhbmQgZW5jb3VudGVyIHRoaXMgaXNzdWUsIHlvdSBjYW4gY2hlY2sgd2hldGhlciBhbiBhc3luYyBib3VuZGFyeSBpcyBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgaXMgYXMgZm9sbG93czogJyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnN0YWxsSW5pdGlhbENvbnN1bWVzKG9wdGlvbnMpIHtcbiAgICB2YXIgbW9kdWxlVG9IYW5kbGVyTWFwcGluZyA9IG9wdGlvbnMubW9kdWxlVG9IYW5kbGVyTWFwcGluZywgd2VicGFja1JlcXVpcmUgPSBvcHRpb25zLndlYnBhY2tSZXF1aXJlLCBpbnN0YWxsZWRNb2R1bGVzID0gb3B0aW9ucy5pbnN0YWxsZWRNb2R1bGVzLCBpbml0aWFsQ29uc3VtZXMgPSBvcHRpb25zLmluaXRpYWxDb25zdW1lcztcbiAgICBpbml0aWFsQ29uc3VtZXMuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNjZW5hcmlvIHdoZW4gbW9kdWxlIGlzIHVzZWQgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgaW5zdGFsbGVkTW9kdWxlc1tpZF0gPSAwO1xuICAgICAgICAgICAgZGVsZXRlIHdlYnBhY2tSZXF1aXJlLmNbaWRdO1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBoYW5kbGVJbml0aWFsQ29uc3VtZXMoe1xuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nOiBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgIHdlYnBhY2tSZXF1aXJlOiB3ZWJwYWNrUmVxdWlyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFyZWQgbW9kdWxlIGlzIG5vdCBhdmFpbGFibGUgZm9yIGVhZ2VyIGNvbnN1bXB0aW9uOiBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpbml0Q29udGFpbmVyRW50cnkob3B0aW9ucykge1xuICAgIHZhciB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmUsIHNoYXJlU2NvcGUgPSBvcHRpb25zLnNoYXJlU2NvcGUsIGluaXRTY29wZSA9IG9wdGlvbnMuaW5pdFNjb3BlLCBzaGFyZVNjb3BlS2V5ID0gb3B0aW9ucy5zaGFyZVNjb3BlS2V5LCByZW1vdGVFbnRyeUluaXRPcHRpb25zID0gb3B0aW9ucy5yZW1vdGVFbnRyeUluaXRPcHRpb25zO1xuICAgIGlmICghd2VicGFja1JlcXVpcmUuUykgcmV0dXJuO1xuICAgIGlmICghd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbiB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZSB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbml0T3B0aW9ucykgcmV0dXJuO1xuICAgIHZhciBmZWRlcmF0aW9uSW5zdGFuY2UgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlO1xuICAgIHZhciBuYW1lID0gc2hhcmVTY29wZUtleSB8fCAnZGVmYXVsdCc7XG4gICAgZmVkZXJhdGlvbkluc3RhbmNlLmluaXRPcHRpb25zKF9vYmplY3Rfc3ByZWFkKHtcbiAgICAgICAgbmFtZTogd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbml0T3B0aW9ucy5uYW1lLFxuICAgICAgICByZW1vdGVzOiBbXVxuICAgIH0sIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMpKTtcbiAgICBmZWRlcmF0aW9uSW5zdGFuY2UuaW5pdFNoYXJlU2NvcGVNYXAobmFtZSwgc2hhcmVTY29wZSk7XG4gICAgaWYgKHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uYXR0YWNoU2hhcmVTY29wZU1hcCkge1xuICAgICAgICB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXAod2VicGFja1JlcXVpcmUpO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHdlYnBhY2tSZXF1aXJlLkkobmFtZSwgaW5pdFNjb3BlKTtcbn1cblxudmFyIGZlZGVyYXRpb24gPSB7XG4gICAgcnVudGltZTogcnVudGltZV9fbmFtZXNwYWNlLFxuICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgaW5pdE9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICBidW5kbGVyUnVudGltZToge1xuICAgICAgICByZW1vdGVzOiByZW1vdGVzLFxuICAgICAgICBjb25zdW1lczogY29uc3VtZXMsXG4gICAgICAgIEk6IGluaXRpYWxpemVTaGFyaW5nLFxuICAgICAgICBTOiB7fSxcbiAgICAgICAgaW5zdGFsbEluaXRpYWxDb25zdW1lczogaW5zdGFsbEluaXRpYWxDb25zdW1lcyxcbiAgICAgICAgaW5pdENvbnRhaW5lckVudHJ5OiBpbml0Q29udGFpbmVyRW50cnlcbiAgICB9LFxuICAgIGF0dGFjaFNoYXJlU2NvcGVNYXA6IGF0dGFjaFNoYXJlU2NvcGVNYXAsXG4gICAgYnVuZGxlclJ1bnRpbWVPcHRpb25zOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmZWRlcmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+webpack-bundler-runtime@0.1.18/node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\n");

/***/ }),

/***/ "webpack/container/entry/client1":
/*!***********************!*\
  !*** container entry ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var moduleMap = {
	"./noop": () => {
		return __webpack_require__.e(/*! __federation_expose_noop */ "__federation_expose_noop").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.js */ "./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.js")))));
	},
	"./react": () => {
		return __webpack_require__.e(/*! __federation_expose_react */ "__federation_expose_react").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/react@18.3.1/node_modules/react/index.js */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/index.js")))));
	},
	"./react-dom": () => {
		return __webpack_require__.e(/*! __federation_expose_react_dom */ "__federation_expose_react_dom").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js */ "./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js")))));
	},
	"./next/router": () => {
		return __webpack_require__.e(/*! __federation_expose_next__router */ "__federation_expose_next__router").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js")))));
	},
	"./index": () => {
		return __webpack_require__.e(/*! __federation_expose_index */ "__federation_expose_index").then(() => (() => ((__webpack_require__(/*! ./src/pages/index.js */ "./src/pages/index.js")))));
	},
	"./newpage": () => {
		return __webpack_require__.e(/*! __federation_expose_newpage */ "__federation_expose_newpage").then(() => (() => ((__webpack_require__(/*! ./src/pages/newpage.js */ "./src/pages/newpage.js")))));
	},
	"./pages-map": () => {
		return __webpack_require__.e(/*! __federation_expose_pages_map */ "__federation_expose_pages_map").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js!./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js */ "./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js!./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js")))));
	},
	"./pages-map-v2": () => {
		return __webpack_require__.e(/*! __federation_expose_pages_map_v2 */ "__federation_expose_pages_map_v2").then(() => (() => ((__webpack_require__(/*! ./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js?v2!./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js */ "./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js?v2!./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/loaders/nextPageMapLoader.js")))));
	},
	"./pages/index": () => {
		return __webpack_require__.e(/*! __federation_expose_pages__index */ "__federation_expose_index").then(() => (() => ((__webpack_require__(/*! ./src/pages/index.js */ "./src/pages/index.js")))));
	},
	"./pages/newpage": () => {
		return __webpack_require__.e(/*! __federation_expose_pages__newpage */ "__federation_expose_newpage").then(() => (() => ((__webpack_require__(/*! ./src/pages/newpage.js */ "./src/pages/newpage.js")))));
	}
};
var get = (module, getScope) => {
	__webpack_require__.R = getScope;
	getScope = (
		__webpack_require__.o(moduleMap, module)
			? moduleMap[module]()
			: Promise.resolve().then(() => {
				throw new Error('Module "' + module + '" does not exist in container.');
			})
	);
	__webpack_require__.R = undefined;
	return getScope;
};
var init = (shareScope, initScope, remoteEntryInitOptions) => {
	return __webpack_require__.federation.bundlerRuntime.initContainerEntry({	webpackRequire: __webpack_require__,
		shareScope: shareScope,
		initScope: initScope,
		remoteEntryInitOptions: remoteEntryInitOptions,
		shareScopeKey: "default"
	})
};
__webpack_require__(/*! ./node_modules/.federation/entry.b6ace3e62ebeee3273eefa6e13da0b93.js */ "./node_modules/.federation/entry.b6ace3e62ebeee3273eefa6e13da0b93.js")

// This exports getters to disallow modifications
__webpack_require__.d(exports, {
	get: () => (get),
	init: () => (init)
});

/***/ }),

/***/ "next/amp":
/*!***************************!*\
  !*** external "next/amp" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("next/amp");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "next/error":
/*!*****************************!*\
  !*** external "next/error" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("next/error");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("react-dom");

/***/ }),

/***/ "styled-jsx/style":
/*!***********************************!*\
  !*** external "styled-jsx/style" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("styled-jsx/style");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction default_1() {\n    return {\n        name: 'next-internal-plugin',\n        errorLoadRemote({ id, error, from, origin }) {\n            console.error(id, 'offline');\n            const pg = function () {\n                console.error(id, 'offline', error);\n                return null;\n            };\n            pg.getInitialProps = function (ctx) {\n                return {};\n            };\n            let mod;\n            if (from === 'build') {\n                mod = () => ({\n                    __esModule: true,\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                });\n            }\n            else {\n                mod = {\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                };\n            }\n            return mod;\n        },\n        beforeInit(args) {\n            const { userOptions, shareInfo } = args;\n            const { shared } = userOptions;\n            if (!globalThis.usedChunks)\n                globalThis.usedChunks = new Set();\n            if (shared) {\n                Object.keys(shared || {}).forEach((sharedKey) => {\n                    const rawShared = shared[sharedKey];\n                    const arrayShared = Array.isArray(rawShared)\n                        ? rawShared\n                        : [rawShared];\n                    arrayShared.forEach((s) => {\n                        if (!s.strategy) {\n                            s.strategy = 'loaded-first';\n                        }\n                    });\n                });\n            }\n            if (typeof __webpack_require__.j === 'string' &&\n                !__webpack_require__.j.startsWith('webpack')) {\n                return args;\n            }\n            // if (__webpack_runtime_id__ && !__webpack_runtime_id__.startsWith('webpack')) return args;\n            const { moduleCache, name } = args.origin;\n            const gs = new Function('return globalThis')();\n            const attachedRemote = gs[name];\n            if (attachedRemote) {\n                moduleCache.set(name, attachedRemote);\n            }\n            return args;\n        },\n        init(args) {\n            return args;\n        },\n        beforeRequest: (args) => {\n            const { options, id } = args;\n            const remoteName = id.split('/').shift();\n            const remote = options.remotes.find((remote) => remote.name === remoteName);\n            if (!remote)\n                return args;\n            //@ts-ignore\n            if (remote?.entry?.includes('?t=')) {\n                return args;\n            }\n            //@ts-ignore\n            remote.entry = `${remote?.entry}?t=${Date.now()}`;\n            return args;\n        },\n        createScript({ url }) {\n            return;\n        },\n        afterResolve(args) {\n            return args;\n        },\n        onLoad(args) {\n            const { exposeModuleFactory, exposeModule, id } = args;\n            const moduleOrFactory = exposeModuleFactory || exposeModule;\n            if (!moduleOrFactory)\n                return args; // Ensure moduleOrFactory is defined\n            if (typeof window === 'undefined') {\n                let exposedModuleExports;\n                try {\n                    exposedModuleExports = moduleOrFactory();\n                }\n                catch (e) {\n                    exposedModuleExports = moduleOrFactory;\n                }\n                const handler = {\n                    get(target, prop, receiver) {\n                        // Check if accessing a static property of the function itself\n                        if (target === exposedModuleExports &&\n                            typeof exposedModuleExports[prop] === 'function') {\n                            return function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return exposedModuleExports[prop].apply(this, args);\n                            };\n                        }\n                        const originalMethod = target[prop];\n                        if (typeof originalMethod === 'function') {\n                            const proxiedFunction = function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return originalMethod.apply(this, args);\n                            };\n                            // Copy all enumerable properties from the original method to the proxied function\n                            Object.keys(originalMethod).forEach((prop) => {\n                                Object.defineProperty(proxiedFunction, prop, {\n                                    value: originalMethod[prop],\n                                    writable: true,\n                                    enumerable: true,\n                                    configurable: true,\n                                });\n                            });\n                            return proxiedFunction;\n                        }\n                        return Reflect.get(target, prop, receiver);\n                    },\n                };\n                if (typeof exposedModuleExports === 'function') {\n                    // If the module export is a function, we create a proxy that can handle both its\n                    // call (as a function) and access to its properties (including static methods).\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                    // Proxy static properties specifically\n                    const staticProps = Object.getOwnPropertyNames(exposedModuleExports);\n                    staticProps.forEach((prop) => {\n                        if (typeof exposedModuleExports[prop] === 'function') {\n                            exposedModuleExports[prop] = new Proxy(exposedModuleExports[prop], handler);\n                        }\n                    });\n                    return () => exposedModuleExports;\n                }\n                else {\n                    // For objects, just wrap the exported object itself\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                }\n                return exposedModuleExports;\n            }\n            return args;\n        },\n        resolveShare(args) {\n            if (args.pkgName !== 'react' &&\n                args.pkgName !== 'react-dom' &&\n                !args.pkgName.startsWith('next/')) {\n                return args;\n            }\n            const { shareScopeMap, scope, pkgName, version, GlobalFederation } = args;\n            const host = GlobalFederation['__INSTANCES__'][0];\n            if (!host) {\n                return args;\n            }\n            args.resolver = function () {\n                shareScopeMap[scope][pkgName][version] =\n                    host.options.shared[pkgName][0]; // replace local share scope manually with desired module\n                return shareScopeMap[scope][pkgName][version];\n            };\n            return args;\n        },\n        async beforeLoadShare(args) {\n            return args;\n        },\n    };\n}\nexports[\"default\"] = default_1;\n//# sourceMappingURL=runtimePlugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK25leHRqcy1tZkA4LjMuMTlfbmV4dEAxNC4yLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfdHlwZXNjcmlwdEA1LjQuNV93ZWJwYWNrQDUuOTEuMC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLHVCQUF1QixxQkFBc0I7QUFDN0MsaUJBQWlCLHFCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsS0FBSyxXQUFXO0FBQzVEO0FBQ0EsU0FBUztBQUNULHVCQUF1QixLQUFLO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQTJEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudDEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vZHVsZS1mZWRlcmF0aW9uK25leHRqcy1tZkA4LjMuMTlfbmV4dEAxNC4yLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfdHlwZXNjcmlwdEA1LjQuNV93ZWJwYWNrQDUuOTEuMC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzPzFkMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ25leHQtaW50ZXJuYWwtcGx1Z2luJyxcbiAgICAgICAgZXJyb3JMb2FkUmVtb3RlKHsgaWQsIGVycm9yLCBmcm9tLCBvcmlnaW4gfSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihpZCwgJ29mZmxpbmUnKTtcbiAgICAgICAgICAgIGNvbnN0IHBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoaWQsICdvZmZsaW5lJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBnLmdldEluaXRpYWxQcm9wcyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG1vZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSAnYnVpbGQnKSB7XG4gICAgICAgICAgICAgICAgbW9kID0gKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGcsXG4gICAgICAgICAgICAgICAgICAgIGdldFNlcnZlclNpZGVQcm9wczogKCkgPT4gKHsgcHJvcHM6IHt9IH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2VydmVyU2lkZVByb3BzOiAoKSA9PiAoeyBwcm9wczoge30gfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUluaXQoYXJncykge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyT3B0aW9ucywgc2hhcmVJbmZvIH0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgeyBzaGFyZWQgfSA9IHVzZXJPcHRpb25zO1xuICAgICAgICAgICAgaWYgKCFnbG9iYWxUaGlzLnVzZWRDaHVua3MpXG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy51c2VkQ2h1bmtzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNoYXJlZCB8fCB7fSkuZm9yRWFjaCgoc2hhcmVkS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1NoYXJlZCA9IHNoYXJlZFtzaGFyZWRLZXldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVNoYXJlZCA9IEFycmF5LmlzQXJyYXkocmF3U2hhcmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByYXdTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3Jhd1NoYXJlZF07XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U2hhcmVkLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcy5zdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc3RyYXRlZ3kgPSAnbG9hZGVkLWZpcnN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9fd2VicGFja19ydW50aW1lX2lkX18gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgIV9fd2VicGFja19ydW50aW1lX2lkX18uc3RhcnRzV2l0aCgnd2VicGFjaycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiAoX193ZWJwYWNrX3J1bnRpbWVfaWRfXyAmJiAhX193ZWJwYWNrX3J1bnRpbWVfaWRfXy5zdGFydHNXaXRoKCd3ZWJwYWNrJykpIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGVDYWNoZSwgbmFtZSB9ID0gYXJncy5vcmlnaW47XG4gICAgICAgICAgICBjb25zdCBncyA9IG5ldyBGdW5jdGlvbigncmV0dXJuIGdsb2JhbFRoaXMnKSgpO1xuICAgICAgICAgICAgY29uc3QgYXR0YWNoZWRSZW1vdGUgPSBnc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRhY2hlZFJlbW90ZSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZUNhY2hlLnNldChuYW1lLCBhdHRhY2hlZFJlbW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgYmVmb3JlUmVxdWVzdDogKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgaWQgfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVOYW1lID0gaWQuc3BsaXQoJy8nKS5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlID0gb3B0aW9ucy5yZW1vdGVzLmZpbmQoKHJlbW90ZSkgPT4gcmVtb3RlLm5hbWUgPT09IHJlbW90ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFyZW1vdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChyZW1vdGU/LmVudHJ5Py5pbmNsdWRlcygnP3Q9JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVtb3RlLmVudHJ5ID0gYCR7cmVtb3RlPy5lbnRyeX0/dD0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JpcHQoeyB1cmwgfSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclJlc29sdmUoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTG9hZChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGV4cG9zZU1vZHVsZUZhY3RvcnksIGV4cG9zZU1vZHVsZSwgaWQgfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVPckZhY3RvcnkgPSBleHBvc2VNb2R1bGVGYWN0b3J5IHx8IGV4cG9zZU1vZHVsZTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlT3JGYWN0b3J5KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzOyAvLyBFbnN1cmUgbW9kdWxlT3JGYWN0b3J5IGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBleHBvc2VkTW9kdWxlRXhwb3J0cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG1vZHVsZU9yRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG1vZHVsZU9yRmFjdG9yeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFjY2Vzc2luZyBhIHN0YXRpYyBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb24gaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBleHBvc2VkTW9kdWxlRXhwb3J0cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHBvc2VkTW9kdWxlRXhwb3J0c1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxNZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm94aWVkRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZCB0byB0aGUgcHJveGllZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9yaWdpbmFsTWV0aG9kKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94aWVkRnVuY3Rpb24sIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbE1ldGhvZFtwcm9wXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3hpZWRGdW5jdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZE1vZHVsZUV4cG9ydHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1vZHVsZSBleHBvcnQgaXMgYSBmdW5jdGlvbiwgd2UgY3JlYXRlIGEgcHJveHkgdGhhdCBjYW4gaGFuZGxlIGJvdGggaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgKGFzIGEgZnVuY3Rpb24pIGFuZCBhY2Nlc3MgdG8gaXRzIHByb3BlcnRpZXMgKGluY2x1ZGluZyBzdGF0aWMgbWV0aG9kcykuXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbmV3IFByb3h5KGV4cG9zZWRNb2R1bGVFeHBvcnRzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJveHkgc3RhdGljIHByb3BlcnRpZXMgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY1Byb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXhwb3NlZE1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0gPSBuZXcgUHJveHkoZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0sIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG9iamVjdHMsIGp1c3Qgd3JhcCB0aGUgZXhwb3J0ZWQgb2JqZWN0IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG5ldyBQcm94eShleHBvc2VkTW9kdWxlRXhwb3J0cywgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvc2VkTW9kdWxlRXhwb3J0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlU2hhcmUoYXJncykge1xuICAgICAgICAgICAgaWYgKGFyZ3MucGtnTmFtZSAhPT0gJ3JlYWN0JyAmJlxuICAgICAgICAgICAgICAgIGFyZ3MucGtnTmFtZSAhPT0gJ3JlYWN0LWRvbScgJiZcbiAgICAgICAgICAgICAgICAhYXJncy5wa2dOYW1lLnN0YXJ0c1dpdGgoJ25leHQvJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcmVTY29wZU1hcCwgc2NvcGUsIHBrZ05hbWUsIHZlcnNpb24sIEdsb2JhbEZlZGVyYXRpb24gfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCBob3N0ID0gR2xvYmFsRmVkZXJhdGlvblsnX19JTlNUQU5DRVNfXyddWzBdO1xuICAgICAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdW3ZlcnNpb25dID1cbiAgICAgICAgICAgICAgICAgICAgaG9zdC5vcHRpb25zLnNoYXJlZFtwa2dOYW1lXVswXTsgLy8gcmVwbGFjZSBsb2NhbCBzaGFyZSBzY29wZSBtYW51YWxseSB3aXRoIGRlc2lyZWQgbW9kdWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdW3ZlcnNpb25dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBiZWZvcmVMb2FkU2hhcmUoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWVQbHVnaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@module-federation+nextjs-mf@8.3.19_next@14.2.3_react-dom@18.3.1_react@18.3.1_typescript@5.4.5_webpack@5.91.0/node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/federation runtime */
/******/ 	(() => {
/******/ 		if(!__webpack_require__.federation){
/******/ 			__webpack_require__.federation = {
/******/ 				initOptions: {"name":"client1","remotes":[]},
/******/ 				chunkMatcher: function(chunkId) {return true},
/******/ 				rootOutputDir: "",
/******/ 				initialConsumes: undefined,
/******/ 				bundlerRuntimeOptions: {}
/******/ 			};
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "-" + {"__federation_expose_noop":"54ec661738a31a79","__federation_expose_react":"f8a0ce130bd3e7f4","__federation_expose_react_dom":"15fbb19ed0c11d0e","__federation_expose_next__router":"027b6fc4e91b3ce3","__federation_expose_index":"dd1fd7e838664174","__federation_expose_newpage":"bd7b62b0cc7066ad","__federation_expose_pages_map":"bb8508b74ec733ba","__federation_expose_pages_map_v2":"39c6aed1563f05ca","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e1":"53c3499d729b45de","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac71":"c97de0d17b94d286","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde81":"b2b2b60e9cb764cf","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d51":"722b11fc3a31fc0e","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3311":"63af69dd34af7004","node_modules_pnpm_react_18_3_1_node_modules_react_jsx-dev-runtime_js":"d235777ac62e4625","node_modules_pnpm_react_18_3_1_node_modules_react_jsx-runtime_js":"27c6c93f986db293","node_modules_pnpm_styled-jsx_5_1_1_react_18_3_1_node_modules_styled-jsx_index_js":"3f12934928c399f1","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac70":"ef1316fde3256109","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_router_js":"0341c486061e09a9","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d50":"7a2232c6ed520be8","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3310":"1596e7ef1151a3dd","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde80":"2f50e2434c90f5fb","node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e0":"5aa2f2303c367b15"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	(() => {
/******/ 		__webpack_require__.j = "webpack-runtime";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	(() => {
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = (name, initScope) => {
/******/ 			if(!initScope) initScope = [];
/******/ 			// handling circular init calls
/******/ 			var initToken = initTokens[name];
/******/ 			if(!initToken) initToken = initTokens[name] = {};
/******/ 			if(initScope.indexOf(initToken) >= 0) return;
/******/ 			initScope.push(initToken);
/******/ 			// only runs once
/******/ 			if(initPromises[name]) return initPromises[name];
/******/ 			// creates a new share scope if needed
/******/ 			if(!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};
/******/ 			// runs all init snippets from all modules reachable
/******/ 			var scope = __webpack_require__.S[name];
/******/ 			var warn = (msg) => {
/******/ 				if (typeof console !== "undefined" && console.warn) console.warn(msg);
/******/ 			};
/******/ 			var uniqueName = "client1";
/******/ 			var register = (name, version, factory, eager) => {
/******/ 				var versions = scope[name] = scope[name] || {};
/******/ 				var activeVersion = versions[version];
/******/ 				if(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };
/******/ 			};
/******/ 			var initExternal = (id) => {
/******/ 				var handleError = (err) => (warn("Initialization of sharing external failed: " + err));
/******/ 				try {
/******/ 					var module = __webpack_require__(id);
/******/ 					if(!module) return;
/******/ 					var initFn = (module) => (module && module.init && module.init(__webpack_require__.S[name], initScope))
/******/ 					if(module.then) return promises.push(module.then(initFn, handleError));
/******/ 					var initResult = initFn(module);
/******/ 					if(initResult && initResult.then) return promises.push(initResult['catch'](handleError));
/******/ 				} catch(err) { handleError(err); }
/******/ 			}
/******/ 			var promises = [];
/******/ 			switch(name) {
/******/ 				case "default": {
/******/ 					register("next/dynamic", "14.2.3", () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e1").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/dynamic.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/dynamic.js"))))));
/******/ 					register("next/head", "14.2.3", () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac71").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/head.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/head.js"))))));
/******/ 					register("next/image", "14.2.3", () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde81").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/image.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/image.js"))))));
/******/ 					register("next/link", "14.2.3", () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d51").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/link.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/link.js"))))));
/******/ 					register("next/router", "14.2.3", () => (__webpack_require__.e("__federation_expose_next__router").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js"))))));
/******/ 					register("next/script", "14.2.3", () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3311").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/script.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/script.js"))))));
/******/ 					register("react/jsx-dev-runtime", "18.3.1", () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-dev-runtime_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-dev-runtime.js */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-dev-runtime.js"))))));
/******/ 					register("react/jsx-runtime", "18.3.1", () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-runtime_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js"))))));
/******/ 					register("styled-jsx", "5.1.1", () => (__webpack_require__.e("node_modules_pnpm_styled-jsx_5_1_1_react_18_3_1_node_modules_styled-jsx_index_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/styled-jsx@5.1.1_react@18.3.1/node_modules/styled-jsx/index.js */ "./node_modules/.pnpm/styled-jsx@5.1.1_react@18.3.1/node_modules/styled-jsx/index.js"))))));
/******/ 				}
/******/ 				break;
/******/ 			}
/******/ 			if(!promises.length) return initPromises[name] = 1;
/******/ 			return initPromises[name] = Promise.all(promises).then(() => (initPromises[name] = 1));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup entrypoint */
/******/ 	(() => {
/******/ 		__webpack_require__.X = (result, chunkIds, fn) => {
/******/ 			// arguments: chunkIds, moduleId are deprecated
/******/ 			var moduleId = chunkIds;
/******/ 			if(!fn) chunkIds = result, fn = () => (__webpack_require__(__webpack_require__.s = moduleId));
/******/ 			return Promise.all(chunkIds.map(__webpack_require__.e, __webpack_require__)).then(() => {
/******/ 				var r = fn();
/******/ 				return r === undefined ? result : r;
/******/ 			})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	(() => {
/******/ 		__webpack_require__.federation.initOptions.shared = {	"next/dynamic": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e1").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/dynamic.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/dynamic.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/head": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac71").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/head.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/head.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/image": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde81").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/image.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/image.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/link": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d51").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/link.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/link.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/router": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("__federation_expose_next__router").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/script": [{	version: "14.2.3",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3311").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/script.js */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/script.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react/jsx-dev-runtime": [{	version: "18.3.1",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-dev-runtime_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-dev-runtime.js */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-dev-runtime.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react/jsx-runtime": [{	version: "18.3.1",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-runtime_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"styled-jsx": [{	version: "5.1.1",
/******/ 				get: () => (__webpack_require__.e("node_modules_pnpm_styled-jsx_5_1_1_react_18_3_1_node_modules_styled-jsx_index_js").then(() => (() => (__webpack_require__(/*! ./node_modules/.pnpm/styled-jsx@5.1.1_react@18.3.1/node_modules/styled-jsx/index.js */ "./node_modules/.pnpm/styled-jsx@5.1.1_react@18.3.1/node_modules/styled-jsx/index.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":"^5.1.1","strictVersion":false,"singleton":true}},],}
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = (name, initScope) => {
/******/ 			return __webpack_require__.federation.bundlerRuntime.I({	shareScopeName: name,
/******/ 				webpackRequire: __webpack_require__,
/******/ 				initPromises: initPromises,
/******/ 				initTokens: initTokens,
/******/ 				initScope: initScope,
/******/ 			})
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		
/******/ 		function getPathFromFederation() {
/******/ 		  // Access the global federation manager or create a fallback object
/******/ 		  var federationManager = globalThis.__FEDERATION__ || {};
/******/ 		  // Access the current Webpack instance's federation details or create a fallback object
/******/ 		  var instance = __webpack_require__.federation.instance || {};
/******/ 		
/******/ 		  // Function to aggregate all known remote module paths
/******/ 		  var getAllKnownRemotes = function() {
/******/ 		    var found = {};
/******/ 		    // Iterate over all federation instances to collect module cache entries
/******/ 		    (federationManager.__INSTANCES__ || []).forEach((instance) => {
/******/ 		      instance.moduleCache.forEach((value, key) => {
/******/ 		        found[key] = value;
/******/ 		      });
/******/ 		    });
/******/ 		    return found;
/******/ 		  };
/******/ 		
/******/ 		  // Retrieve the combined remote cache from all federation instances
/******/ 		  const combinedRemoteCache = getAllKnownRemotes();
/******/ 		  // Get the name of the current host from the instance
/******/ 		  const hostName = instance.name;
/******/ 		  // Find the path for the current host in the remote cache
/******/ 		  const foundPath = combinedRemoteCache[hostName];
/******/ 		  // If a path is not found, return undefined to indicate the absence of an entry path
/******/ 		  if (!foundPath) { return undefined; }
/******/ 		  // Return the entry path for the found remote module
/******/ 		  const entryPath = foundPath.remoteInfo.entry;
/******/ 		  return entryPath;
/******/ 		}
/******/ 		
/******/ 		
/******/ 		Object.defineProperty(__webpack_require__, "p", {
/******/ 		  get: function() {
/******/ 		    var scriptUrl;
/******/ 		
/******/ 		    // Attempt to get the script URL based on the environment
/******/ 		    var scriptType = false;
/******/ 		    var chunkLoading = "async-node";
/******/ 		    var isModuleEnvironment = ['module', 'node', 'async-node', 'require'].includes(scriptType) || chunkLoading;
/******/ 		
/******/ 		    if (isModuleEnvironment) {
/******/ 		      try {
/******/ 		        // Use Function constructor to avoid direct reference to import.meta in environments that do not support it
/******/ 		        scriptUrl = (new Function('return typeof import.meta.url === "string" ? import.meta.url : undefined;'))();
/******/ 		      } catch (e) {
/******/ 		        // Handle cases where import.meta is not available or other errors occur
/******/ 		        var scriptPath = getPathFromFederation();
/******/ 		        if (scriptPath) {
/******/ 		          scriptUrl = scriptPath;
/******/ 		        } else if (typeof __filename !== "undefined") {
/******/ 		          scriptUrl = __filename;
/******/ 		        } else {
/******/ 		          scriptUrl = "/_next/";
/******/ 		        }
/******/ 		      }
/******/ 		    } else {
/******/ 		      // Fallback for non-module environments, such as browsers
/******/ 		      if (__webpack_require__.g.importScripts) {
/******/ 		        scriptUrl = __webpack_require__.g.location + "";
/******/ 		      }
/******/ 		      var document = __webpack_require__.g.document;
/******/ 		      if (!scriptUrl && document) {
/******/ 		        if (document.currentScript) {
/******/ 		          scriptUrl = document.currentScript.src;
/******/ 		        } else {
/******/ 		          var scripts = document.getElementsByTagName("script");
/******/ 		          if (scripts.length) {
/******/ 		            scriptUrl = scripts[scripts.length - 1].src;
/******/ 		          }
/******/ 		        }
/******/ 		      }
/******/ 		    }
/******/ 		
/******/ 		    if (!scriptUrl) {
/******/ 		      throw new Error("Unable to calculate automatic public path");
/******/ 		    }
/******/ 		
/******/ 		    // Clean up the script URL by removing any hash or query parameters
/******/ 		    scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		
/******/ 		    // Apply any undo path that might be necessary for nested public paths
/******/ 		    var finalScript = "" ? scriptUrl + "" : scriptUrl;
/******/ 		
/******/ 		    // Helper function to ensure the URL has a protocol if it starts with '//'
/******/ 		    var addProtocol = function(url) {
/******/ 		      return url.startsWith('//') ? 'https:' + url : url;
/******/ 		    };
/******/ 		
/******/ 		    // Set the global variable for the public path
/******/ 		    globalThis.currentVmokPublicPath = addProtocol(finalScript) || '/';
/******/ 		
/******/ 		    // Return the final public path
/******/ 		    return finalScript
/******/ 		  }
/******/ 		});
/******/ 	
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/consumes */
/******/ 	(() => {
/******/ 		var installedModules = {};
/******/ 		var moduleToHandlerMapping = {
/******/ 			"webpack/sharing/consume/default/next/head/next/head": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac70").then(() => (() => (__webpack_require__(/*! next/head */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/head.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/head",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/router/next/router": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_router_js").then(() => (() => (__webpack_require__(/*! next/router */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/router.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/router",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/link/next/link": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d50").then(() => (() => (__webpack_require__(/*! next/link */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/link.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/link",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/script/next/script": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3310").then(() => (() => (__webpack_require__(/*! next/script */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/script.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/script",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/image/next/image": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde80").then(() => (() => (__webpack_require__(/*! next/image */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/image.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/image",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/dynamic/next/dynamic": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e0").then(() => (() => (__webpack_require__(/*! next/dynamic */ "./node_modules/.pnpm/next@14.2.3_react-dom@18.3.1_react@18.3.1/node_modules/next/dynamic.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/dynamic",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/styled-jsx/styled-jsx": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_styled-jsx_5_1_1_react_18_3_1_node_modules_styled-jsx_index_js").then(() => (() => (__webpack_require__(/*! styled-jsx */ "./node_modules/.pnpm/styled-jsx@5.1.1_react@18.3.1/node_modules/styled-jsx/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^5.1.1",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "styled-jsx",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-runtime_js").then(() => (() => (__webpack_require__(/*! react/jsx-runtime */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react/jsx-runtime",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime": {
/******/ 				getter: () => (__webpack_require__.e("node_modules_pnpm_react_18_3_1_node_modules_react_jsx-dev-runtime_js").then(() => (() => (__webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-dev-runtime.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react/jsx-dev-runtime",
/******/ 			}
/******/ 		};
/******/ 		// no consumes in initial chunks
/******/ 		var chunkMapping = {
/******/ 			"__federation_expose_noop": [
/******/ 				"webpack/sharing/consume/default/next/head/next/head",
/******/ 				"webpack/sharing/consume/default/next/router/next/router",
/******/ 				"webpack/sharing/consume/default/next/link/next/link",
/******/ 				"webpack/sharing/consume/default/next/script/next/script",
/******/ 				"webpack/sharing/consume/default/next/image/next/image",
/******/ 				"webpack/sharing/consume/default/next/dynamic/next/dynamic",
/******/ 				"webpack/sharing/consume/default/styled-jsx/styled-jsx",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"__federation_expose_next__router": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"__federation_expose_index": [
/******/ 				"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime"
/******/ 			],
/******/ 			"__federation_expose_newpage": [
/******/ 				"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime"
/******/ 			],
/******/ 			"node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_dynamic_js-_da5e1": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_head_js-_3ac71": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_image_js-_fde81": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_link_js-_81d51": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"node_modules_pnpm_next_14_2_3_react-dom_18_3_1_react_18_3_1_node_modules_next_script_js-_c3311": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			]
/******/ 		};
/******/ 		__webpack_require__.f.consumes = (chunkId, promises) => {
/******/ 			__webpack_require__.federation.bundlerRuntime.consumes({
/******/ 			chunkMapping: chunkMapping,
/******/ 			installedModules: installedModules,
/******/ 			chunkId: chunkId,
/******/ 			moduleToHandlerMapping: moduleToHandlerMapping,
/******/ 			promises: promises,
/******/ 			webpackRequire:__webpack_require__
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/readFile chunk loading */
/******/ 	(() => {
/******/ 		async function fileSystemRunInContextStrategy(chunkId, rootOutputDir, remotes, callback) {
/******/ 		    const fs = require('fs');
/******/ 		    const path = require('path');
/******/ 		    const vm = require('vm');
/******/ 		    const filename = path.join(__dirname, rootOutputDir + __webpack_require__.u(chunkId));
/******/ 		    if (fs.existsSync(filename)) {
/******/ 		        fs.readFile(filename, 'utf-8', (err, content) => {
/******/ 		            if (err) {
/******/ 		                callback(err, null);
/******/ 		                return;
/******/ 		            }
/******/ 		            const chunk = {};
/******/ 		            try {
/******/ 		                vm.runInThisContext('(function(exports, require, __dirname, __filename) {' +
/******/ 		                    content +
/******/ 		                    '\n})', filename)(chunk, require, path.dirname(filename), filename);
/******/ 		                callback(null, chunk);
/******/ 		            }
/******/ 		            catch (e) {
/******/ 		                console.log("'runInThisContext threw'", e);
/******/ 		                callback(e, null);
/******/ 		            }
/******/ 		        });
/******/ 		    }
/******/ 		    else {
/******/ 		        const err = new Error(`File ${filename} does not exist`);
/******/ 		        callback(err, null);
/******/ 		    }
/******/ 		}
/******/ 		async function httpEvalStrategy(chunkName, remoteName, remotes, callback) {
/******/ 		    let url;
/******/ 		    try {
/******/ 		        url = new URL(chunkName, __webpack_require__.p);
/******/ 		    }
/******/ 		    catch (e) {
/******/ 		        console.error('module-federation: failed to construct absolute chunk path of', remoteName, 'for', chunkName);
/******/ 		        url = new URL(remotes[remoteName]);
/******/ 		        const getBasenameFromUrl = (url) => {
/******/ 		            const urlParts = url.split('/');
/******/ 		            return urlParts[urlParts.length - 1];
/******/ 		        };
/******/ 		        const fileToReplace = getBasenameFromUrl(url.pathname);
/******/ 		        url.pathname = url.pathname.replace(fileToReplace, chunkName);
/******/ 		    }
/******/ 		    const data = await fetch(url).then((res) => res.text());
/******/ 		    const chunk = {};
/******/ 		    try {
/******/ 		        const urlDirname = url.pathname.split('/').slice(0, -1).join('/');
/******/ 		        eval('(function(exports, require, __dirname, __filename) {' + data + '\n})')(chunk, require, urlDirname, chunkName);
/******/ 		        callback(null, chunk);
/******/ 		    }
/******/ 		    catch (e) {
/******/ 		        callback(e, null);
/******/ 		    }
/******/ 		}
/******/ 		async function httpVmStrategy(chunkName, remoteName, remotes, callback) {
/******/ 		    const http = require('http');
/******/ 		    const https = require('https');
/******/ 		    const vm = require('vm');
/******/ 		    const path = require('path');
/******/ 		    let url;
/******/ 		    const globalThisVal = new Function('return globalThis')();
/******/ 		    try {
/******/ 		        url = new URL(chunkName, __webpack_require__.p);
/******/ 		    }
/******/ 		    catch (e) {
/******/ 		        console.error('module-federation: failed to construct absolute chunk path of', remoteName, 'for', chunkName);
/******/ 		        // search all instances to see if any have the remote
/******/ 		        const container = globalThisVal['__FEDERATION__']['__INSTANCES__'].find((instance) => {
/******/ 		            if (!instance.moduleCache.has(remoteName))
/******/ 		                return;
/******/ 		            const container = instance.moduleCache.get(remoteName);
/******/ 		            if (!container.remoteInfo)
/******/ 		                return;
/******/ 		            return container.remoteInfo.entry;
/******/ 		        });
/******/ 		        if (!container) {
/******/ 		            throw new Error('Container not found');
/******/ 		        }
/******/ 		        url = new URL(container.moduleCache.get(remoteName).remoteInfo.entry);
/******/ 		        const fileToReplace = path.basename(url.pathname);
/******/ 		        url.pathname = url.pathname.replace(fileToReplace, chunkName);
/******/ 		    }
/******/ 		    const protocol = url.protocol === 'https:' ? https : http;
/******/ 		    protocol.get(url.href, (res) => {
/******/ 		        let data = '';
/******/ 		        res.on('data', (chunk) => {
/******/ 		            data += chunk.toString();
/******/ 		        });
/******/ 		        res.on('end', () => {
/******/ 		            const chunk = {};
/******/ 		            const urlDirname = url.pathname.split('/').slice(0, -1).join('/');
/******/ 		            vm.runInThisContext(`(function(exports, require, __dirname, __filename) {${data}\n})`, chunkName)(chunk, require, urlDirname, chunkName);
/******/ 		            callback(null, chunk);
/******/ 		        });
/******/ 		        res.on('error', (err) => {
/******/ 		            callback(err, null);
/******/ 		        });
/******/ 		    });
/******/ 		}
/******/ 		const loadChunkStrategy = async (strategyType,chunkId,rootOutputDir, remotes, callback) => {
/******/ 			switch (strategyType) {
/******/ 				case "filesystem": return await fileSystemRunInContextStrategy(chunkId,rootOutputDir, remotes, callback);
/******/ 				case "http-eval": return await httpEvalStrategy(chunkId,rootOutputDir, remotes, callback);
/******/ 				case "http-vm": return await httpVmStrategy(chunkId,rootOutputDir, remotes, callback);
/******/ 				default: throw new Error("Invalid strategy type");
/******/ 			}
/******/ 		};
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "0" means "already loaded", Promise means loading
/******/ 		var installedChunks = {
/******/ 			"webpack-runtime": 0
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++) {
/******/ 				if(installedChunks[chunkIds[i]]) {
/******/ 					installedChunks[chunkIds[i]][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// load script equivalent for server side
/******/ 		__webpack_require__.l = (url, callback, chunkId) => {
/******/ 				async function executeLoad(url, callback, name) {
/******/ 				            if (!name) {
/******/ 				              throw new Error('__webpack_require__.l name is required for ' + url);
/******/ 				            }
/******/ 				            const usesInternalRef = name.startsWith('__webpack_require__')
/******/ 				            if (usesInternalRef) {
/******/ 				              const regex = /__webpack_require__\.federation\.instance\.moduleCache\.get\(([^)]+)\)/;
/******/ 				              const match = name.match(regex);
/******/ 				              if (match) {
/******/ 				                name = match[1].replace(/["']/g, '');
/******/ 				              }
/******/ 				            }
/******/ 				            try {
/******/ 				              const federation = __webpack_require__.federation;
/******/ 				              const res = await __webpack_require__.federation.runtime.loadScriptNode(url, { attrs: {} });
/******/ 				              const enhancedRemote = federation.instance.initRawContainer(name, url, res);
/******/ 				              // use normal global assignment
/******/ 				              if(!usesInternalRef && !globalThis[name]) {
/******/ 				                globalThis[name] = enhancedRemote
/******/ 				              }
/******/ 				              callback(enhancedRemote);
/******/ 				            } catch (error) {
/******/ 				              callback(error);
/******/ 				            }
/******/ 		
/******/ 				          }
/******/ 				executeLoad(url, callback, chunkId);
/******/ 		}
/******/ 		// Dynamic filesystem chunk loading for javascript
/******/ 		__webpack_require__.f.readFileVm = function(chunkId, promises) {
/******/ 			var installedChunkData = installedChunks[chunkId];
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 				// array of [resolve, reject, promise] means "currently loading"
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[2]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// load the chunk and return promise to it
/******/ 						var promise = new Promise(async function(resolve, reject) {
/******/ 							installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 							function installChunkCallback(error,chunk){
/******/ 								if(error) return reject(error);
/******/ 								installChunk(chunk);
/******/ 							}
/******/ 							var fs = typeof process !== "undefined" ? require('fs') : false;
/******/ 							var filename = typeof process !== "undefined" ? require('path').join(__dirname, "" + __webpack_require__.u(chunkId)) : false;
/******/ 							if(fs && fs.existsSync(filename)) {
/******/ 								loadChunkStrategy('filesystem', chunkId, "", remotes, installChunkCallback);
/******/ 							} else {
/******/ 								var remotes = {};
/******/ 								var chunkName = __webpack_require__.u(chunkId);
/******/ 								const loadingStrategy = typeof process !== 'undefined' ?  'http-vm' : 'http-eval';
/******/ 								loadChunkStrategy(loadingStrategy, chunkName,__webpack_require__.federation.initOptions.name, __webpack_require__.federation.initOptions.remotes, installChunkCallback);
/******/ 							}
/******/ 						});
/******/ 						promises.push(installedChunkData[2] = promise);
/******/ 					} else installedChunks[chunkId] = 0;
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		module.exports = __webpack_require__;
/******/ 		__webpack_require__.C = function(){
/******/ 		
/******/ 		return installChunk.apply(this, arguments)};
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/inverted container startup */
/******/ 	(() => {
/******/ 		var innerRemote;
/******/ 		function attachRemote (resolve) {
/******/ 			if(__webpack_require__.m["webpack/container/entry/client1"]) {
/******/ 				innerRemote = __webpack_require__("webpack/container/entry/client1");
/******/ 			}
/******/ 			var gs = __webpack_require__.g || globalThis
/******/ 			gs["client1"] = innerRemote
/******/ 			if(resolve) resolve(innerRemote);
/******/ 			return innerRemote;
/******/ 		};
/******/ 		__webpack_require__.federation.attachRemote = attachRemote;
/******/ 		attachRemote();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	
/******/ })()
;